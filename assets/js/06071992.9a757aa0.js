"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[129],{2251:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>_,frontMatter:()=>a,metadata:()=>i,toc:()=>p});const i=JSON.parse('{"id":"module-4-locomotion-mobility/gait-generation","title":"Gait Generation and Pattern Formation","description":"Introduction: Creating Natural Walking Patterns","source":"@site/docs/module-4-locomotion-mobility/gait-generation.md","sourceDirName":"module-4-locomotion-mobility","slug":"/module-4-locomotion-mobility/gait-generation","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/gait-generation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-locomotion-mobility/gait-generation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Dynamic Walking and Balance Control","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/dynamic-walking"},"next":{"title":"Terrain Adaptation and Footstep Planning","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/terrain-adaptation"}}');var o=t(4848),r=t(8453);const a={},s="Gait Generation and Pattern Formation",l={},p=[{value:"Introduction: Creating Natural Walking Patterns",id:"introduction-creating-natural-walking-patterns",level:2},{value:"Biological Inspiration and Central Pattern Generators",id:"biological-inspiration-and-central-pattern-generators",level:3},{value:"Mathematical Models for Gait Generation",id:"mathematical-models-for-gait-generation",level:2},{value:"Central Pattern Generator (CPG) Models",id:"central-pattern-generator-cpg-models",level:3},{value:"Coupled Oscillator Networks",id:"coupled-oscillator-networks",level:3},{value:"Trajectory Generation Methods",id:"trajectory-generation-methods",level:2},{value:"Fourier Series-Based Trajectory Generation",id:"fourier-series-based-trajectory-generation",level:3},{value:"B\xe9zier Curve-Based Trajectory Generation",id:"b\xe9zier-curve-based-trajectory-generation",level:3},{value:"Pattern Formation Algorithms",id:"pattern-formation-algorithms",level:2},{value:"Phase Oscillator Networks",id:"phase-oscillator-networks",level:3},{value:"Neural Network-Based Pattern Generation",id:"neural-network-based-pattern-generation",level:3},{value:"Gait Adaptation and Learning",id:"gait-adaptation-and-learning",level:2},{value:"Adaptive Gait Control",id:"adaptive-gait-control",level:3},{value:"Rhythmic Movement Primitives",id:"rhythmic-movement-primitives",level:2},{value:"Dynamic Movement Primitives (DMPs) for Gait",id:"dynamic-movement-primitives-dmps-for-gait",level:3},{value:"Integration with Control Systems",id:"integration-with-control-systems",level:2},{value:"Whole-Body Gait Controller",id:"whole-body-gait-controller",level:3},{value:"Conclusion",id:"conclusion",level:2}];function c(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.header,{children:(0,o.jsx)(n.h1,{id:"gait-generation-and-pattern-formation",children:"Gait Generation and Pattern Formation"})}),"\n",(0,o.jsx)(n.h2,{id:"introduction-creating-natural-walking-patterns",children:"Introduction: Creating Natural Walking Patterns"}),"\n",(0,o.jsx)(n.p,{children:"Gait generation is the process of creating rhythmic, coordinated movement patterns that enable humanoid robots to walk efficiently and stably. Unlike simple joint interpolation, gait generation involves the coordination of multiple body segments, timing of foot contacts, and synchronization of balance control systems. This section explores the biological inspiration, mathematical models, and implementation strategies for creating natural, efficient walking patterns."}),"\n",(0,o.jsx)(n.h3,{id:"biological-inspiration-and-central-pattern-generators",children:"Biological Inspiration and Central Pattern Generators"}),"\n",(0,o.jsx)(n.p,{children:"Human walking is controlled by Central Pattern Generators (CPGs) in the spinal cord that produce rhythmic motor patterns. Robotic gait generation often mimics these biological systems to create stable, adaptive walking patterns."}),"\n",(0,o.jsx)(n.h2,{id:"mathematical-models-for-gait-generation",children:"Mathematical Models for Gait Generation"}),"\n",(0,o.jsx)(n.h3,{id:"central-pattern-generator-cpg-models",children:"Central Pattern Generator (CPG) Models"}),"\n",(0,o.jsx)(n.p,{children:"CPGs are neural networks that generate rhythmic patterns without rhythmic input:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nclass CentralPatternGenerator:\n    def __init__(self, dt=0.005):\n        self.dt = dt\n        self.oscillators = {}\n        self.connections = {}\n        self.outputs = {}\n\n    def add_oscillator(self, name, frequency=1.0, phase=0.0, amplitude=1.0):\n        \"\"\"Add a neural oscillator to the CPG\"\"\"\n        self.oscillators[name] = {\n            'frequency': frequency,\n            'phase': phase,\n            'amplitude': amplitude,\n            'state': 0.0,\n            'velocity': 0.0\n        }\n\n    def connect_oscillators(self, source, target, weight=1.0, phase_offset=0.0):\n        \"\"\"Connect two oscillators with specified weight and phase offset\"\"\"\n        connection_key = (source, target)\n        self.connections[connection_key] = {\n            'weight': weight,\n            'phase_offset': phase_offset\n        }\n\n    def update(self, external_input=None):\n        \"\"\"Update all oscillators based on connections and inputs\"\"\"\n        if external_input is None:\n            external_input = {}\n\n        new_states = {}\n        new_velocities = {}\n\n        for name, osc in self.oscillators.items():\n            # Calculate input from connected oscillators\n            coupling_input = 0.0\n            for (src, tgt), conn in self.connections.items():\n                if tgt == name:\n                    src_osc = self.oscillators[src]\n                    coupling_input += conn['weight'] * np.sin(\n                        src_osc['state'] - osc['state'] + conn['phase_offset']\n                    )\n\n            # Add external input if provided\n            ext_input = external_input.get(name, 0.0)\n\n            # Van der Pol oscillator dynamics (simplified)\n            # dx/dt = y\n            # dy/dt = mu*(1-x^2)*y - x + coupling_input\n            mu = 2.0  # Nonlinearity parameter\n            x = osc['state']\n            y = osc['velocity']\n\n            dx_dt = y\n            dy_dt = mu * (1 - x**2) * y - x + coupling_input + ext_input\n\n            new_states[name] = x + dx_dt * self.dt\n            new_velocities[name] = y + dy_dt * self.dt\n\n            # Calculate output (rhythmic signal)\n            self.outputs[name] = osc['amplitude'] * np.sin(new_states[name] + osc['phase'])\n\n        # Update states\n        for name in self.oscillators:\n            self.oscillators[name]['state'] = new_states[name]\n            self.oscillators[name]['velocity'] = new_velocities[name]\n\n    def get_output(self, name):\n        \"\"\"Get the current output of an oscillator\"\"\"\n        return self.outputs.get(name, 0.0)\n\n    def get_all_outputs(self):\n        \"\"\"Get all oscillator outputs\"\"\"\n        return self.outputs.copy()\n\n# Example: Simple walking CPG\ncpg = CentralPatternGenerator(dt=0.005)\n\n# Add oscillators for left and right legs\ncpg.add_oscillator('left_hip', frequency=1.0, amplitude=0.5)\ncpg.add_oscillator('right_hip', frequency=1.0, phase=np.pi, amplitude=0.5)  # 180\xb0 phase difference\ncpg.add_oscillator('left_knee', frequency=1.0, amplitude=0.3)\ncpg.add_oscillator('right_knee', frequency=1.0, phase=np.pi, amplitude=0.3)\n\n# Connect oscillators (ipsilateral and contralateral coupling)\ncpg.connect_oscillators('left_hip', 'right_hip', weight=0.5, phase_offset=np.pi)\ncpg.connect_oscillators('right_hip', 'left_hip', weight=0.5, phase_offset=np.pi)\ncpg.connect_oscillators('left_hip', 'left_knee', weight=0.8, phase_offset=0.0)\ncpg.connect_oscillators('right_hip', 'right_knee', weight=0.8, phase_offset=0.0)\n\n# Simulate for one walking cycle\ntime_points = []\noutputs = []\nfor t in np.arange(0, 2.0, 0.005):\n    cpg.update()\n    time_points.append(t)\n    outputs.append(cpg.get_all_outputs().copy())\n\n# Convert to arrays for plotting\ntime_points = np.array(time_points)\nleft_hip = np.array([out['left_hip'] for out in outputs])\nright_hip = np.array([out['right_hip'] for out in outputs])\nleft_knee = np.array([out['left_knee'] for out in outputs])\nright_knee = np.array([out['right_knee'] for out in outputs])\n\nprint(f\"CPG simulation completed: {len(time_points)} time steps\")\nprint(f\"Left hip amplitude: {np.max(np.abs(left_hip)):.3f}\")\nprint(f\"Right hip amplitude: {np.max(np.abs(right_hip)):.3f}\")\n"})}),"\n",(0,o.jsx)(n.h3,{id:"coupled-oscillator-networks",children:"Coupled Oscillator Networks"}),"\n",(0,o.jsx)(n.p,{children:"More complex CPGs using networks of coupled oscillators:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class CoupledOscillatorNetwork:\n    def __init__(self, num_oscillators=8, dt=0.005):\n        self.num_oscillators = num_oscillators\n        self.dt = dt\n        self.phases = np.random.random(num_oscillators) * 2 * np.pi\n        self.frequencies = np.ones(num_oscillators)  # Base frequencies\n        self.amplitudes = np.ones(num_oscillators)\n        self.coupling_matrix = np.zeros((num_oscillators, num_oscillators))\n        self.biases = np.zeros(num_oscillators)\n\n    def set_coupling(self, i, j, strength):\n        """Set coupling strength between oscillators i and j"""\n        self.coupling_matrix[i, j] = strength\n        self.coupling_matrix[j, i] = strength  # Symmetric coupling\n\n    def set_chain_coupling(self, longitudinal_strength=1.0, transverse_strength=0.5):\n        """Set coupling in a chain pattern (useful for limb coordination)"""\n        for i in range(self.num_oscillators):\n            # Longitudinal coupling (along the chain)\n            if i < self.num_oscillators - 1:\n                self.set_coupling(i, i+1, longitudinal_strength)\n\n            # Transverse coupling (for bilateral coordination)\n            if i < self.num_oscillators // 2:\n                self.set_coupling(i, i + self.num_oscillators // 2, transverse_strength)\n\n    def set_gait_pattern(self, pattern=\'walking\'):\n        """Set coupling pattern for specific gait"""\n        if pattern == \'walking\':\n            # Walking pattern: alternating left/right legs\n            self.biases[:self.num_oscillators//2] = 0  # Left side\n            self.biases[self.num_oscillators//2:] = np.pi  # Right side (180\xb0 phase difference)\n\n            # Set different frequencies for different joints\n            self.frequencies[0] = 1.0  # Left hip\n            self.frequencies[1] = 1.0  # Left knee\n            self.frequencies[2] = 1.0  # Left ankle\n            self.frequencies[4] = 1.0  # Right hip\n            self.frequencies[5] = 1.0  # Right knee\n            self.frequencies[6] = 1.0  # Right ankle\n\n        elif pattern == \'running\':\n            # Running pattern: higher frequency, different phase relationships\n            self.frequencies *= 2.0  # Double the frequency\n            self.biases[:self.num_oscillators//2] = 0\n            self.biases[self.num_oscillators//2:] = np.pi * 0.5  # 90\xb0 phase difference for running\n\n    def update(self, external_inputs=None):\n        """Update all oscillators using Kuramoto model"""\n        if external_inputs is None:\n            external_inputs = np.zeros(self.num_oscillators)\n\n        # Kuramoto model: d\u03b8_i/dt = \u03c9_i + (1/N) * \u03a3 K_ij * sin(\u03b8_j - \u03b8_i) + input_i\n        dtheta = self.frequencies.copy()\n\n        for i in range(self.num_oscillators):\n            coupling_sum = 0.0\n            for j in range(self.num_oscillators):\n                if i != j:\n                    coupling_sum += self.coupling_matrix[i, j] * np.sin(self.phases[j] - self.phases[i])\n\n            dtheta[i] += (1.0 / self.num_oscillators) * coupling_sum + external_inputs[i]\n\n        # Update phases\n        self.phases += dtheta * self.dt\n\n        # Keep phases in [-\u03c0, \u03c0]\n        self.phases = np.arctan2(np.sin(self.phases), np.cos(self.phases))\n\n    def get_outputs(self):\n        """Get rhythmic outputs from all oscillators"""\n        return self.amplitudes * np.sin(self.phases)\n\n    def modulate_frequency(self, oscillator_idx, modulation_factor):\n        """Modulate frequency of specific oscillator"""\n        self.frequencies[oscillator_idx] *= modulation_factor\n\n    def reset(self):\n        """Reset oscillator phases"""\n        self.phases = np.random.random(self.num_oscillators) * 2 * np.pi\n\n# Example: Complex CPG for walking\ncpg_network = CoupledOscillatorNetwork(num_oscillators=8, dt=0.005)\n\n# Set up for walking\ncpg_network.set_chain_coupling(longitudinal_strength=0.8, transverse_strength=0.6)\ncpg_network.set_gait_pattern(\'walking\')\n\n# Simulate walking pattern\nwalking_time = np.arange(0, 3.0, 0.005)\nwalking_outputs = []\n\nfor t in walking_time:\n    cpg_network.update()\n    outputs = cpg_network.get_outputs()\n    walking_outputs.append(outputs.copy())\n\nwalking_outputs = np.array(walking_outputs)\n\nprint(f"Complex CPG simulation: {len(walking_time)} time steps")\nprint(f"Oscillator outputs range: {np.min(walking_outputs):.3f} to {np.max(walking_outputs):.3f}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"trajectory-generation-methods",children:"Trajectory Generation Methods"}),"\n",(0,o.jsx)(n.h3,{id:"fourier-series-based-trajectory-generation",children:"Fourier Series-Based Trajectory Generation"}),"\n",(0,o.jsx)(n.p,{children:"Using Fourier series to generate smooth periodic trajectories:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class FourierTrajectoryGenerator:\n    def __init__(self, num_harmonics=5):\n        self.num_harmonics = num_harmonics\n        self.coefficients = {}\n\n    def fit_trajectory(self, time_points, trajectory_values, joint_name):\n        \"\"\"Fit Fourier series to a trajectory\"\"\"\n        # Calculate Fourier coefficients\n        T = time_points[-1] - time_points[0]  # Period\n        omega = 2 * np.pi / T  # Fundamental frequency\n\n        # Calculate coefficients: a0, an, bn\n        a0 = np.trapz(trajectory_values, time_points) / T\n\n        an = []\n        bn = []\n        for n in range(1, self.num_harmonics + 1):\n            an_n = (2/T) * np.trapz(trajectory_values * np.cos(n * omega * time_points), time_points)\n            bn_n = (2/T) * np.trapz(trajectory_values * np.sin(n * omega * time_points), time_points)\n            an.append(an_n)\n            bn.append(bn_n)\n\n        self.coefficients[joint_name] = {\n            'a0': a0,\n            'an': np.array(an),\n            'bn': np.array(bn),\n            'omega': omega,\n            'T': T\n        }\n\n    def generate_trajectory(self, joint_name, time_points):\n        \"\"\"Generate trajectory using stored Fourier coefficients\"\"\"\n        if joint_name not in self.coefficients:\n            return np.zeros_like(time_points)\n\n        coeffs = self.coefficients[joint_name]\n        trajectory = np.full_like(time_points, coeffs['a0'])\n\n        for n in range(1, len(coeffs['an']) + 1):\n            trajectory += coeffs['an'][n-1] * np.cos(n * coeffs['omega'] * time_points)\n            trajectory += coeffs['bn'][n-1] * np.sin(n * coeffs['omega'] * time_points)\n\n        return trajectory\n\n    def generate_multiple_trajectories(self, joint_trajectories, duration=2.0, dt=0.005):\n        \"\"\"Generate multiple joint trajectories simultaneously\"\"\"\n        time_points = np.arange(0, duration, dt)\n\n        # Fit each trajectory\n        for joint_name, trajectory in joint_trajectories.items():\n            # Create a sample trajectory (in real use, this would come from demonstration)\n            sample_time = np.linspace(0, duration, len(trajectory))\n            self.fit_trajectory(sample_time, trajectory, joint_name)\n\n        # Generate all trajectories\n        generated_trajectories = {}\n        for joint_name in joint_trajectories.keys():\n            generated_trajectories[joint_name] = self.generate_trajectory(joint_name, time_points)\n\n        return generated_trajectories, time_points\n\n    def add_terrain_adaptation(self, joint_name, terrain_height, adaptation_gain=0.1):\n        \"\"\"Add terrain adaptation to trajectory\"\"\"\n        if joint_name not in self.coefficients:\n            return\n\n        # Modify coefficients based on terrain height\n        self.coefficients[joint_name]['a0'] += adaptation_gain * terrain_height\n\n    def get_trajectory_derivative(self, joint_name, time_points):\n        \"\"\"Get velocity (derivative) of trajectory\"\"\"\n        if joint_name not in self.coefficients:\n            return np.zeros_like(time_points)\n\n        coeffs = self.coefficients[joint_name]\n        velocity = np.zeros_like(time_points)\n\n        for n in range(1, len(coeffs['an']) + 1):\n            velocity -= n * coeffs['omega'] * coeffs['an'][n-1] * np.sin(n * coeffs['omega'] * time_points)\n            velocity += n * coeffs['omega'] * coeffs['bn'][n-1] * np.cos(n * coeffs['omega'] * time_points)\n\n        return velocity\n\n# Example: Generate walking trajectories using Fourier series\nfourier_gen = FourierTrajectoryGenerator(num_harmonics=8)\n\n# Create sample trajectories (these would come from human demonstration or optimization)\nt_demo = np.linspace(0, 2.0, 100)\nleft_hip_demo = 0.2 * np.sin(2 * np.pi * t_demo) + 0.1 * np.sin(4 * np.pi * t_demo)\nright_hip_demo = 0.2 * np.sin(2 * np.pi * t_demo + np.pi) + 0.1 * np.sin(4 * np.pi * t_demo + np.pi)\nleft_knee_demo = 0.3 * np.sin(2 * np.pi * t_demo + np.pi/2) + 0.1 * np.cos(4 * np.pi * t_demo)\nright_knee_demo = 0.3 * np.sin(2 * np.pi * t_demo + 3*np.pi/2) + 0.1 * np.cos(4 * np.pi * t_demo + np.pi)\n\n# Fit trajectories\njoint_demos = {\n    'left_hip': left_hip_demo,\n    'right_hip': right_hip_demo,\n    'left_knee': left_knee_demo,\n    'right_knee': right_knee_demo\n}\n\ngenerated_trajectories, time_points = fourier_gen.generate_multiple_trajectories(joint_demos)\n\nprint(f\"Fourier trajectory generation completed\")\nprint(f\"Generated {len(generated_trajectories)} joint trajectories\")\nprint(f\"Time duration: {time_points[-1]:.2f} seconds\")\n"})}),"\n",(0,o.jsx)(n.h3,{id:"b\xe9zier-curve-based-trajectory-generation",children:"B\xe9zier Curve-Based Trajectory Generation"}),"\n",(0,o.jsx)(n.p,{children:"Using B\xe9zier curves for smooth trajectory generation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class BezierTrajectoryGenerator:\n    def __init__(self, control_points_per_segment=4):\n        self.control_points_per_segment = control_points_per_segment\n        self.trajectories = {}\n\n    def bernstein_polynomial(self, i, n, t):\n        """Calculate Bernstein polynomial of degree n"""\n        from math import factorial\n        return (factorial(n) / (factorial(i) * factorial(n - i))) * (t**i) * ((1-t)**(n-i))\n\n    def bezier_curve(self, control_points, t_values):\n        """Generate B\xe9zier curve from control points"""\n        n = len(control_points) - 1\n        curve_points = np.zeros((len(t_values), len(control_points[0])))\n\n        for j, t in enumerate(t_values):\n            point = np.zeros(len(control_points[0]))\n            for i, cp in enumerate(control_points):\n                point += cp * self.bernstein_polynomial(i, n, t)\n            curve_points[j] = point\n\n        return curve_points\n\n    def generate_joint_trajectory(self, control_points, duration=1.0, dt=0.005):\n        """Generate smooth trajectory using B\xe9zier curves"""\n        t_values = np.arange(0, duration, dt)\n        t_normalized = t_values / duration  # Normalize to [0, 1]\n\n        # Ensure we have enough control points\n        if len(control_points) < 2:\n            raise ValueError("Need at least 2 control points")\n\n        # Generate trajectory\n        trajectory = self.bezier_curve(control_points, t_normalized)\n        return trajectory, t_values\n\n    def generate_3d_trajectory(self, start_pos, end_pos, mid_height=0.05, duration=0.8, dt=0.005):\n        """Generate 3D trajectory for foot movement (e.g., for stepping)"""\n        # Define control points for foot trajectory\n        # Start: lift foot, move forward, place foot\n        control_points = np.array([\n            start_pos,  # Start position\n            [start_pos[0] + (end_pos[0] - start_pos[0]) * 0.25,\n             start_pos[1] + (end_pos[1] - start_pos[1]) * 0.25,\n             start_pos[2] + mid_height * 0.5],  # Mid point (lifted)\n            [start_pos[0] + (end_pos[0] - start_pos[0]) * 0.75,\n             start_pos[1] + (end_pos[1] - start_pos[1]) * 0.75,\n             start_pos[2] + mid_height * 0.5],  # Another mid point\n            end_pos  # End position\n        ])\n\n        return self.generate_joint_trajectory(control_points, duration, dt)\n\n    def generate_swing_trajectory(self, start_foot_pos, target_foot_pos, step_height=0.05):\n        """Generate swing phase trajectory for foot"""\n        # Generate trajectory for swing foot\n        trajectory, times = self.generate_3d_trajectory(\n            start_foot_pos, target_foot_pos,\n            mid_height=step_height,\n            duration=0.4  # Swing phase duration\n        )\n        return trajectory, times\n\n    def generate_com_trajectory(self, start_pos, target_pos, step_height=0.02):\n        """Generate CoM trajectory with smooth transition"""\n        # CoM follows a smooth path between steps\n        control_points = np.array([\n            start_pos,\n            [start_pos[0] + (target_pos[0] - start_pos[0]) * 0.3,\n             start_pos[1] + (target_pos[1] - start_pos[1]) * 0.3,\n             start_pos[2] + step_height],  # Mid point (slightly higher)\n            [start_pos[0] + (target_pos[0] - start_pos[0]) * 0.7,\n             start_pos[1] + (target_pos[1] - start_pos[1]) * 0.7,\n             start_pos[2] + step_height],  # Another mid point\n            target_pos\n        ])\n\n        return self.generate_joint_trajectory(control_points, duration=0.8)\n\n    def generate_ankle_trajectory(self, foot_pos, body_pos, step_height=0.01):\n        """Generate ankle trajectory relative to body"""\n        # Ankle trajectory follows foot but with less vertical movement\n        control_points = np.array([\n            [foot_pos[0], foot_pos[1], body_pos[2] - 0.05],  # Start (ankle position)\n            [foot_pos[0] + 0.05, foot_pos[1], body_pos[2] - 0.04],  # Mid swing\n            [foot_pos[0] + 0.15, foot_pos[1], body_pos[2] - 0.04],  # Mid stance\n            [foot_pos[0] + 0.2, foot_pos[1], body_pos[2] - 0.05]  # End (push off)\n        ])\n\n        return self.generate_joint_trajectory(control_points, duration=0.8)\n\n# Example: Generate walking trajectories using B\xe9zier curves\nbezier_gen = BezierTrajectoryGenerator()\n\n# Generate swing trajectory for right foot\nstart_pos = np.array([0.0, -0.1, 0.0])  # Right foot starting position\ntarget_pos = np.array([0.3, -0.1, 0.0])  # Target position (step forward)\n\nfoot_trajectory, foot_times = bezier_gen.generate_swing_trajectory(start_pos, target_pos, step_height=0.05)\n\n# Generate CoM trajectory\ncom_start = np.array([0.0, 0.0, 0.85])\ncom_target = np.array([0.15, 0.0, 0.85])  # Move CoM forward\ncom_trajectory, com_times = bezier_gen.generate_com_trajectory(com_start, com_target)\n\nprint(f"Bezier trajectory generation completed")\nprint(f"Foot trajectory: {len(foot_trajectory)} points")\nprint(f"CoM trajectory: {len(com_trajectory)} points")\nprint(f"Foot movement: {start_pos} to {target_pos}")\nprint(f"CoM movement: {com_start} to {com_target}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"pattern-formation-algorithms",children:"Pattern Formation Algorithms"}),"\n",(0,o.jsx)(n.h3,{id:"phase-oscillator-networks",children:"Phase Oscillator Networks"}),"\n",(0,o.jsx)(n.p,{children:"Advanced pattern formation using networks of phase oscillators:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class PhaseOscillatorNetwork:\n    def __init__(self, num_oscillators=12, dt=0.005):\n        self.num_oscillators = num_oscillators\n        self.dt = dt\n        self.phases = np.random.random(num_oscillators) * 2 * np.pi\n        self.natural_frequencies = 2 * np.pi * np.ones(num_oscillators)  # 1 Hz\n        self.coupling_strengths = np.zeros((num_oscillators, num_oscillators))\n        self.phase_couplings = np.zeros((num_oscillators, num_oscillators))\n\n    def set_coupling_topology(self, topology=\'chain\'):\n        """Set coupling topology for the network"""\n        if topology == \'chain\':\n            # Chain topology: each oscillator connects to neighbors\n            coupling_strength = 1.0\n            for i in range(self.num_oscillators):\n                if i > 0:\n                    self.coupling_strengths[i, i-1] = coupling_strength\n                    self.phase_couplings[i, i-1] = 0.0  # In-phase coupling\n                if i < self.num_oscillators - 1:\n                    self.coupling_strengths[i, i+1] = coupling_strength\n                    self.phase_couplings[i, i+1] = 0.0  # In-phase coupling\n\n        elif topology == \'ring\':\n            # Ring topology: each connects to neighbors, with wraparound\n            coupling_strength = 1.0\n            for i in range(self.num_oscillators):\n                left_idx = (i - 1) % self.num_oscillators\n                right_idx = (i + 1) % self.num_oscillators\n                self.coupling_strengths[i, left_idx] = coupling_strength\n                self.coupling_strengths[i, right_idx] = coupling_strength\n                self.phase_couplings[i, left_idx] = 0.0\n                self.phase_couplings[i, right_idx] = 0.0\n\n        elif topology == \'bilateral\':\n            # Bilateral symmetry: left/right pairs with contralateral coupling\n            for i in range(self.num_oscillators // 2):\n                left_idx = i\n                right_idx = i + self.num_oscillators // 2\n\n                # Ipsilateral coupling\n                if i > 0:\n                    self.coupling_strengths[left_idx, left_idx-1] = 0.8\n                    self.coupling_strengths[right_idx, right_idx-1] = 0.8\n                    self.coupling_strengths[left_idx-1, left_idx] = 0.8\n                    self.coupling_strengths[right_idx-1, right_idx] = 0.8\n\n                # Contralateral coupling (180\xb0 phase difference)\n                self.coupling_strengths[left_idx, right_idx] = 0.6\n                self.coupling_strengths[right_idx, left_idx] = 0.6\n                self.phase_couplings[left_idx, right_idx] = np.pi  # 180\xb0\n                self.phase_couplings[right_idx, left_idx] = np.pi  # 180\xb0\n\n    def update(self, external_inputs=None):\n        """Update all oscillators using Kuramoto model with phase shifts"""\n        if external_inputs is None:\n            external_inputs = np.zeros(self.num_oscillators)\n\n        dphases = self.natural_frequencies.copy()\n\n        # Add coupling effects\n        for i in range(self.num_oscillators):\n            for j in range(self.num_oscillators):\n                if i != j and self.coupling_strengths[i, j] > 0:\n                    phase_diff = self.phases[j] - self.phases[i] + self.phase_couplings[i, j]\n                    dphases[i] += self.coupling_strengths[i, j] * np.sin(phase_diff)\n\n        # Add external inputs\n        dphases += external_inputs\n\n        # Update phases\n        self.phases += dphases * self.dt\n\n        # Keep phases in [-\u03c0, \u03c0]\n        self.phases = np.arctan2(np.sin(self.phases), np.cos(self.phases))\n\n    def get_rhythmic_outputs(self, amplitudes=None, offsets=None):\n        """Get rhythmic outputs from oscillators"""\n        if amplitudes is None:\n            amplitudes = np.ones(self.num_oscillators)\n        if offsets is None:\n            offsets = np.zeros(self.num_oscillators)\n\n        return amplitudes * np.sin(self.phases) + offsets\n\n    def entrain_to_rhythm(self, target_frequency, oscillator_idx, coupling_strength=2.0):\n        """Entrain specific oscillator to external rhythm"""\n        # This would modify the natural frequency or add external forcing\n        pass\n\n    def synchronize_oscillators(self, group_indices, target_phase_diff=0.0):\n        """Synchronize a group of oscillators to specific phase relationships"""\n        for i in group_indices:\n            for j in group_indices:\n                if i != j:\n                    self.coupling_strengths[i, j] = 1.5\n                    self.phase_couplings[i, j] = target_phase_diff\n\n    def generate_gait_pattern(self, gait_type=\'walking\'):\n        """Generate specific gait pattern"""\n        if gait_type == \'walking\':\n            # Walking: alternating left/right legs\n            left_indices = list(range(self.num_oscillators // 2))\n            right_indices = list(range(self.num_oscillators // 2, self.num_oscillators))\n\n            # Set contralateral phase difference\n            for left_idx in left_indices:\n                right_idx = left_idx + self.num_oscillators // 2\n                self.phase_couplings[left_idx, right_idx] = np.pi  # 180\xb0\n                self.phase_couplings[right_idx, left_idx] = np.pi  # 180\xb0\n\n        elif gait_type == \'trotting\':\n            # For quadrupedal pattern (if applicable)\n            pass\n\n# Example: Phase oscillator network for gait generation\nphase_net = PhaseOscillatorNetwork(num_oscillators=8, dt=0.005)\n\n# Set up bilateral symmetry topology\nphase_net.set_coupling_topology(\'bilateral\')\n\n# Generate walking pattern\ntime_points = np.arange(0, 2.0, 0.005)\nnetwork_outputs = []\n\nfor t in time_points:\n    phase_net.update()\n    outputs = phase_net.get_rhythmic_outputs()\n    network_outputs.append(outputs.copy())\n\nnetwork_outputs = np.array(network_outputs)\n\nprint(f"Phase oscillator network simulation completed")\nprint(f"Network outputs shape: {network_outputs.shape}")\nprint(f"Left side (first 4 oscillators) mean phase: {np.mean(network_outputs[:, :4]):.3f}")\nprint(f"Right side (last 4 oscillators) mean phase: {np.mean(network_outputs[:, 4:]):.3f}")\n'})}),"\n",(0,o.jsx)(n.h3,{id:"neural-network-based-pattern-generation",children:"Neural Network-Based Pattern Generation"}),"\n",(0,o.jsx)(n.p,{children:"Using neural networks to learn and generate gait patterns:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class NeuralPatternGenerator:\n    def __init__(self, input_size=10, hidden_size=64, output_size=12):\n        self.input_size = input_size\n        self.hidden_size = hidden_size\n        self.output_size = output_size\n        self.weights = {\n            \'input_hidden\': np.random.randn(input_size, hidden_size) * 0.1,\n            \'hidden_output\': np.random.randn(hidden_size, output_size) * 0.1,\n            \'hidden_bias\': np.zeros(hidden_size),\n            \'output_bias\': np.zeros(output_size)\n        }\n        self.activation = lambda x: np.tanh(x)  # Activation function\n        self.activation_derivative = lambda x: 1 - np.tanh(x)**2\n\n    def forward(self, inputs):\n        """Forward pass through the network"""\n        self.last_inputs = inputs\n        self.hidden = self.activation(np.dot(inputs, self.weights[\'input_hidden\']) + self.weights[\'hidden_bias\'])\n        self.outputs = np.dot(self.hidden, self.weights[\'hidden_output\']) + self.weights[\'output_bias\']\n        return self.outputs\n\n    def train(self, input_sequences, target_sequences, learning_rate=0.01, epochs=1000):\n        """Train the network to generate target sequences"""\n        for epoch in range(epochs):\n            total_loss = 0\n            for inputs, targets in zip(input_sequences, target_sequences):\n                # Forward pass\n                outputs = self.forward(inputs)\n\n                # Calculate loss\n                loss = np.mean((outputs - targets)**2)\n                total_loss += loss\n\n                # Backward pass\n                output_error = outputs - targets\n                hidden_error = np.dot(output_error, self.weights[\'hidden_output\'].T) * self.activation_derivative(self.hidden)\n\n                # Update weights\n                self.weights[\'hidden_output\'] -= learning_rate * np.outer(self.hidden, output_error)\n                self.weights[\'output_bias\'] -= learning_rate * output_error\n                self.weights[\'input_hidden\'] -= learning_rate * np.outer(self.last_inputs, hidden_error)\n                self.weights[\'hidden_bias\'] -= learning_rate * hidden_error\n\n            if epoch % 100 == 0:\n                print(f"Epoch {epoch}, Average Loss: {total_loss/len(input_sequences):.6f}")\n\n    def generate_sequence(self, initial_input, sequence_length=100):\n        """Generate a sequence of outputs"""\n        sequence = []\n        current_input = initial_input.copy()\n\n        for _ in range(sequence_length):\n            output = self.forward(current_input)\n            sequence.append(output.copy())\n\n            # Update input for next step (feedback)\n            # This is a simple example - in practice, you might use a recurrent structure\n            current_input = np.concatenate([output[:self.input_size//2], current_input[self.input_size//2:]])\n\n        return np.array(sequence)\n\n    def add_recurrent_connection(self, recurrent_weights=None):\n        """Add recurrent connections for temporal dependencies"""\n        if recurrent_weights is None:\n            self.recurrent_weights = np.random.randn(self.hidden_size, self.hidden_size) * 0.01\n        else:\n            self.recurrent_weights = recurrent_weights\n        self.last_hidden = np.zeros(self.hidden_size)\n\n    def recurrent_forward(self, inputs):\n        """Forward pass with recurrent connections"""\n        self.last_inputs = inputs\n        recurrent_input = np.dot(self.last_hidden, self.recurrent_weights)\n        self.hidden = self.activation(\n            np.dot(inputs, self.weights[\'input_hidden\']) +\n            recurrent_input +\n            self.weights[\'hidden_bias\']\n        )\n        self.last_hidden = self.hidden.copy()\n        self.outputs = np.dot(self.hidden, self.weights[\'hidden_output\']) + self.weights[\'output_bias\']\n        return self.outputs\n\n    def generate_oscillatory_output(self, frequency=1.0, amplitude=1.0, duration=2.0, dt=0.005):\n        """Generate oscillatory output for rhythmic movement"""\n        time_points = np.arange(0, duration, dt)\n\n        # Create oscillatory input pattern\n        inputs = []\n        for t in time_points:\n            input_vec = np.zeros(self.input_size)\n            for i in range(self.input_size):\n                input_vec[i] = amplitude * np.sin(2 * np.pi * frequency * t + i * 0.5)\n            inputs.append(input_vec)\n\n        outputs = []\n        for input_vec in inputs:\n            output = self.forward(input_vec)\n            outputs.append(output)\n\n        return np.array(outputs), time_points\n\n# Example: Neural network-based pattern generation\nnn_gen = NeuralPatternGenerator(input_size=8, hidden_size=32, output_size=12)\n\n# Create training data (simplified - in practice this would come from demonstrations)\ninput_sequences = []\ntarget_sequences = []\n\nfor _ in range(50):  # 50 training examples\n    # Create a rhythmic input pattern\n    inputs = np.random.randn(50, 8) * 0.1  # 50 time steps, 8 inputs\n    # Create corresponding rhythmic output pattern\n    targets = np.zeros((50, 12))\n    for i in range(50):\n        t = i * 0.02  # 50Hz\n        for j in range(12):\n            targets[i, j] = np.sin(2 * np.pi * 1.0 * t + j * 0.5) + 0.1 * np.random.randn()\n\n    input_sequences.append(inputs)\n    target_sequences.append(targets)\n\n# Train the network\nprint("Training neural pattern generator...")\nnn_gen.train(input_sequences, target_sequences, learning_rate=0.01, epochs=500)\n\n# Generate a sequence\ninitial_input = np.zeros(8)\ngenerated_sequence = nn_gen.generate_sequence(initial_input, sequence_length=100)\n\nprint(f"Neural network generation completed")\nprint(f"Generated sequence shape: {generated_sequence.shape}")\nprint(f"Output range: {np.min(generated_sequence):.3f} to {np.max(generated_sequence):.3f}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"gait-adaptation-and-learning",children:"Gait Adaptation and Learning"}),"\n",(0,o.jsx)(n.h3,{id:"adaptive-gait-control",children:"Adaptive Gait Control"}),"\n",(0,o.jsx)(n.p,{children:"Implementing systems that adapt gait patterns to different conditions:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class AdaptiveGaitController:\n    def __init__(self, base_gait_params=None):\n        if base_gait_params is None:\n            base_gait_params = {\n                'step_length': 0.3,\n                'step_width': 0.2,\n                'step_time': 0.8,\n                'swing_height': 0.05,\n                'com_height': 0.85\n            }\n        self.base_params = base_gait_params\n        self.current_params = base_gait_params.copy()\n        self.adaptation_history = []\n        self.performance_metrics = {}\n\n    def assess_terrain(self, sensor_data):\n        \"\"\"Assess terrain characteristics from sensor data\"\"\"\n        terrain_info = {\n            'slope': 0.0,\n            'roughness': 0.0,\n            'obstacles': [],\n            'surface_type': 'flat'\n        }\n\n        # Analyze sensor data to determine terrain properties\n        # This would process data from cameras, LIDAR, force sensors, etc.\n        if 'height_map' in sensor_data:\n            height_var = np.var(sensor_data['height_map'])\n            terrain_info['roughness'] = min(0.1, height_var)\n\n        if 'slope_estimate' in sensor_data:\n            terrain_info['slope'] = sensor_data['slope_estimate']\n\n        return terrain_info\n\n    def adapt_gait_parameters(self, terrain_info, current_state=None):\n        \"\"\"Adapt gait parameters based on terrain and current state\"\"\"\n        adapted_params = self.base_params.copy()\n\n        # Adjust for slope\n        slope_factor = 1.0 - 0.3 * abs(terrain_info['slope'])\n        adapted_params['step_length'] *= slope_factor\n        adapted_params['step_time'] /= slope_factor if slope_factor > 0.5 else 0.5\n\n        # Adjust for roughness\n        roughness_factor = 1.0 - 0.2 * terrain_info['roughness']\n        adapted_params['step_length'] *= roughness_factor\n        adapted_params['swing_height'] = max(0.08, adapted_params['swing_height'] * (1.0 + terrain_info['roughness']))\n\n        # Adjust for obstacles\n        if terrain_info['obstacles']:\n            # Reduce step length to step over obstacles safely\n            adapted_params['step_length'] *= 0.7\n            adapted_params['swing_height'] = max(0.1, adapted_params['swing_height'] * 2)\n\n        # Store adaptation\n        adaptation_record = {\n            'timestamp': time.time(),\n            'terrain_info': terrain_info,\n            'old_params': self.current_params.copy(),\n            'new_params': adapted_params.copy()\n        }\n        self.adaptation_history.append(adaptation_record)\n\n        self.current_params = adapted_params\n        return adapted_params\n\n    def generate_adaptive_trajectory(self, terrain_info, duration=2.0):\n        \"\"\"Generate trajectory adapted to current terrain\"\"\"\n        # Get adapted parameters\n        params = self.adapt_gait_parameters(terrain_info)\n\n        # Use the trajectory generators with adapted parameters\n        bezier_gen = BezierTrajectoryGenerator()\n\n        # Generate foot trajectory\n        start_pos = np.array([0.0, -params['step_width']/2, 0.0])\n        target_pos = np.array([params['step_length'], -params['step_width']/2, 0.0])\n\n        foot_trajectory, foot_times = bezier_gen.generate_swing_trajectory(\n            start_pos, target_pos, step_height=params['swing_height']\n        )\n\n        # Generate CoM trajectory\n        com_start = np.array([0.0, 0.0, params['com_height']])\n        com_target = np.array([params['step_length']/2, 0.0, params['com_height']])\n\n        com_trajectory, com_times = bezier_gen.generate_com_trajectory(\n            com_start, com_target, step_height=0.02\n        )\n\n        return {\n            'foot_trajectory': foot_trajectory,\n            'com_trajectory': com_trajectory,\n            'gait_params': params,\n            'time_points': foot_times\n        }\n\n    def evaluate_performance(self, actual_trajectory, desired_trajectory):\n        \"\"\"Evaluate gait performance\"\"\"\n        # Calculate tracking error\n        error = np.mean(np.linalg.norm(actual_trajectory - desired_trajectory, axis=1))\n\n        # Calculate energy efficiency (simplified)\n        velocity = np.gradient(actual_trajectory, axis=0)\n        energy = np.mean(np.sum(velocity**2, axis=1))\n\n        # Calculate stability metrics\n        stability = self.calculate_stability(actual_trajectory)\n\n        performance = {\n            'tracking_error': error,\n            'energy_efficiency': 1.0 / (1.0 + energy),  # Higher is better\n            'stability': stability,\n            'overall_score': (error * 0.4 + (1.0 / (1.0 + energy)) * 0.3 + stability * 0.3)\n        }\n\n        self.performance_metrics = performance\n        return performance\n\n    def calculate_stability(self, trajectory):\n        \"\"\"Calculate stability metric from trajectory\"\"\"\n        # Calculate Zero-Moment Point (ZMP) stability\n        # This is a simplified calculation\n        com_positions = trajectory[:, :2]  # X, Y positions\n        com_velocities = np.gradient(com_positions, axis=0)\n        com_accelerations = np.gradient(com_velocities, axis=0)\n\n        # Assume constant CoM height for ZMP calculation\n        com_height = 0.85\n        gravity = 9.81\n\n        zmp_x = com_positions[:, 0] - (com_height / gravity) * com_accelerations[:, 0]\n        zmp_y = com_positions[:, 1] - (com_height / gravity) * com_accelerations[:, 1]\n\n        # Stability is better when ZMP stays within bounds\n        stability = 1.0 / (1.0 + np.mean(np.abs(zmp_x)) + np.mean(np.abs(zmp_y)))\n        return stability\n\n    def learn_from_experience(self, performance_feedback):\n        \"\"\"Update gait parameters based on performance feedback\"\"\"\n        # Simple learning algorithm - adjust parameters to improve performance\n        if performance_feedback['tracking_error'] > 0.05:  # Threshold for poor performance\n            # Reduce step length for better tracking\n            self.base_params['step_length'] *= 0.95\n        elif performance_feedback['overall_score'] > 0.8:  # Good performance\n            # Can try longer steps\n            self.base_params['step_length'] = min(0.4, self.base_params['step_length'] * 1.01)\n\n        # Store performance for learning\n        self.performance_history = getattr(self, 'performance_history', [])\n        self.performance_history.append(performance_feedback)\n\n# Example: Adaptive gait control\nadaptive_controller = AdaptiveGaitController()\n\n# Simulate different terrains\nterrains = [\n    {'slope': 0.0, 'roughness': 0.01, 'obstacles': [], 'surface_type': 'flat'},\n    {'slope': 0.1, 'roughness': 0.02, 'obstacles': [], 'surface_type': 'sloped'},\n    {'slope': 0.0, 'roughness': 0.08, 'obstacles': [], 'surface_type': 'rough'}\n]\n\nfor i, terrain in enumerate(terrains):\n    print(f\"\\nTerrain {i+1}: {terrain['surface_type']}\")\n\n    # Adapt gait parameters\n    adapted_params = adaptive_controller.adapt_gait_parameters(terrain)\n    print(f\"  Step length: {adapted_params['step_length']:.3f} m\")\n    print(f\"  Swing height: {adapted_params['swing_height']:.3f} m\")\n    print(f\"  Step time: {adapted_params['step_time']:.3f} s\")\n\n    # Generate trajectory for this terrain\n    trajectory_data = adaptive_controller.generate_adaptive_trajectory(terrain)\n    print(f\"  Generated {len(trajectory_data['foot_trajectory'])} trajectory points\")\n\nprint(f\"\\nAdaptation history: {len(adaptive_controller.adaptation_history)} changes\")\n"})}),"\n",(0,o.jsx)(n.h2,{id:"rhythmic-movement-primitives",children:"Rhythmic Movement Primitives"}),"\n",(0,o.jsx)(n.h3,{id:"dynamic-movement-primitives-dmps-for-gait",children:"Dynamic Movement Primitives (DMPs) for Gait"}),"\n",(0,o.jsx)(n.p,{children:"Using DMPs to generate and adapt rhythmic movements:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class RhythmicMovementPrimitive:\n    def __init__(self, n_bfs=10, dt=0.005):\n        self.n_bfs = n_bfs  # Number of basis functions\n        self.dt = dt\n        self.weights = np.zeros(n_bfs)\n        self.centers = np.linspace(0, 1, n_bfs)\n        self.widths = np.ones(n_bfs) * (1.0 / n_bfs) * 6.0  # Overlapping basis functions\n        self.phase_step = 0.05  # Phase increment per time step\n        self.current_phase = 0.0\n        self.initial_value = 0.0\n        self.goal = 1.0\n        self.last_time = 0.0\n\n    def basis_functions(self, x):\n        """Calculate basis functions at phase x"""\n        # Gaussian basis functions\n        psi = np.exp(-self.widths * (x - self.centers)**2)\n        # Normalize\n        psi_sum = np.sum(psi)\n        if psi_sum > 0:\n            psi = psi / psi_sum\n        return psi\n\n    def canonical_phase_system(self, t, t0, t1):\n        """Canonical system for phase evolution"""\n        # For rhythmic DMPs, phase evolves periodically\n        period = t1 - t0\n        phase = ((t - t0) % period) / period\n        return phase\n\n    def forcing_term(self, phase):\n        """Calculate forcing term at given phase"""\n        psi = self.basis_functions(phase)\n        f = np.dot(psi, self.weights)\n        return f\n\n    def train(self, trajectory, times):\n        """Train the DMP to reproduce the given trajectory"""\n        # Calculate desired forcing term\n        # y_ddot = f + coupling_term (simplified)\n        trajectory_vel = np.gradient(trajectory, times)\n        trajectory_acc = np.gradient(trajectory_vel, times)\n\n        # For rhythmic DMP, we want to learn the periodic pattern\n        # Discretize the trajectory into phase bins\n        phases = np.linspace(0, 1, len(trajectory))\n        target_forces = trajectory_acc  # Simplified - in practice, this involves the dynamics\n\n        # Solve for weights using linear regression\n        A = np.zeros((len(trajectory), self.n_bfs))\n        for i, phase in enumerate(phases):\n            A[i, :] = self.basis_functions(phase)\n\n        # Add regularization to avoid overfitting\n        reg_matrix = 1e-6 * np.eye(self.n_bfs)\n        self.weights = np.linalg.solve(A.T @ A + reg_matrix, A.T @ target_forces)\n\n    def generate_trajectory(self, duration=2.0, initial_value=0.0, goal=1.0):\n        """Generate trajectory using the trained DMP"""\n        self.initial_value = initial_value\n        self.goal = goal\n\n        time_points = np.arange(0, duration, self.dt)\n        trajectory = []\n        velocities = []\n        accelerations = []\n\n        # Reset phase\n        self.current_phase = 0.0\n\n        for t in time_points:\n            # Update phase (rhythmic)\n            self.current_phase = (self.current_phase + self.phase_step) % (2 * np.pi)\n            normalized_phase = (self.current_phase + np.pi) / (2 * np.pi)  # Normalize to [0,1]\n\n            # Calculate forcing term\n            f = self.forcing_term(normalized_phase)\n\n            # Integrate dynamics (simplified rhythmic oscillator)\n            # In a real implementation, this would follow the DMP dynamics\n            if len(velocities) == 0:\n                vel = 0.0\n                pos = initial_value\n            else:\n                acc = f  # Simplified acceleration\n                vel = velocities[-1] + acc * self.dt\n                pos = trajectory[-1] + vel * self.dt\n\n            trajectory.append(pos)\n            velocities.append(vel)\n            accelerations.append(f)\n\n        return np.array(trajectory), time_points\n\n    def adapt_to_frequency(self, new_frequency):\n        """Adapt the DMP to a new frequency"""\n        # Adjust phase step to match new frequency\n        old_frequency = 1.0 / (2 * np.pi / self.phase_step)  # Original frequency\n        frequency_ratio = new_frequency / old_frequency\n        self.phase_step *= frequency_ratio\n\n    def modulate_amplitude(self, amplitude_factor):\n        """Modulate the amplitude of the generated pattern"""\n        self.weights *= amplitude_factor\n\n    def combine_primitives(self, other_primitive, combination_method=\'additive\'):\n        """Combine with another DMP primitive"""\n        if combination_method == \'additive\':\n            combined_weights = self.weights + other_primitive.weights\n        elif combination_method == \'weighted\':\n            # Weighted combination\n            combined_weights = 0.5 * self.weights + 0.5 * other_primitive.weights\n        else:\n            combined_weights = self.weights.copy()\n\n        combined_dmp = RhythmicMovementPrimitive(self.n_bfs, self.dt)\n        combined_dmp.weights = combined_weights\n        combined_dmp.centers = self.centers.copy()\n        combined_dmp.widths = self.widths.copy()\n        return combined_dmp\n\n# Example: Rhythmic DMP for walking\nrhythmic_dmp = RhythmicMovementPrimitive(n_bfs=15, dt=0.005)\n\n# Create a sample rhythmic trajectory (e.g., hip angle during walking)\ntime_demo = np.linspace(0, 2.0, 400)\nhip_trajectory = 0.2 * np.sin(2 * np.pi * time_demo) + 0.1 * np.sin(4 * np.pi * time_demo)\n\n# Train the DMP to reproduce this pattern\nrhythmic_dmp.train(hip_trajectory, time_demo)\n\n# Generate new trajectory using the trained DMP\ngenerated_trajectory, gen_times = rhythmic_dmp.generate_trajectory(duration=2.0, initial_value=0.0, goal=0.0)\n\nprint(f"Rhythmic DMP training completed")\nprint(f"Original trajectory: {len(hip_trajectory)} points, range {np.min(hip_trajectory):.3f} to {np.max(hip_trajectory):.3f}")\nprint(f"Generated trajectory: {len(generated_trajectory)} points, range {np.min(generated_trajectory):.3f} to {np.max(generated_trajectory):.3f}")\n\n# Adapt to different frequency\nrhythmic_dmp.adapt_to_frequency(1.5)  # 1.5 Hz instead of 1 Hz\nfast_trajectory, fast_times = rhythmic_dmp.generate_trajectory(duration=2.0)\n\nprint(f"Fast trajectory range: {np.min(fast_trajectory):.3f} to {np.max(fast_trajectory):.3f}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"integration-with-control-systems",children:"Integration with Control Systems"}),"\n",(0,o.jsx)(n.h3,{id:"whole-body-gait-controller",children:"Whole-Body Gait Controller"}),"\n",(0,o.jsx)(n.p,{children:"Integrating gait generation with whole-body control:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"class WholeBodyGaitController:\n    def __init__(self, robot_model):\n        self.robot_model = robot_model\n        self.cpg = CentralPatternGenerator(dt=0.005)\n        self.trajectory_generator = FourierTrajectoryGenerator()\n        self.adaptive_controller = AdaptiveGaitController()\n        self.dmp = RhythmicMovementPrimitive(n_bfs=10)\n\n        # Initialize CPG network for walking\n        self.setup_cpg_network()\n\n        # Joint mapping\n        self.joint_mapping = {\n            'left_hip': 0,\n            'left_knee': 1,\n            'left_ankle': 2,\n            'right_hip': 3,\n            'right_knee': 4,\n            'right_ankle': 5,\n            'left_shoulder': 6,\n            'right_shoulder': 7\n        }\n\n        # Current state\n        self.current_joint_positions = np.zeros(len(self.joint_mapping))\n        self.current_joint_velocities = np.zeros(len(self.joint_mapping))\n        self.com_position = np.array([0.0, 0.0, 0.85])\n        self.com_velocity = np.array([0.0, 0.0, 0.0])\n\n    def setup_cpg_network(self):\n        \"\"\"Setup CPG network for coordinated walking\"\"\"\n        # Add oscillators for major joints\n        joints = ['left_hip', 'right_hip', 'left_knee', 'right_knee',\n                 'left_ankle', 'right_ankle', 'left_shoulder', 'right_shoulder']\n\n        frequencies = [1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 0.5, 0.5]  # Arms slower\n        amplitudes = [0.5, 0.5, 0.3, 0.3, 0.2, 0.2, 0.3, 0.3]\n\n        for joint, freq, amp in zip(joints, frequencies, amplitudes):\n            self.cpg.add_oscillator(joint, frequency=freq, amplitude=amp)\n\n        # Set up coupling for walking pattern\n        self.cpg.connect_oscillators('left_hip', 'right_hip', weight=0.6, phase_offset=np.pi)\n        self.cpg.connect_oscillators('left_knee', 'right_knee', weight=0.6, phase_offset=np.pi)\n        self.cpg.connect_oscillators('left_ankle', 'right_ankle', weight=0.5, phase_offset=np.pi)\n\n        # Connect hip to knee and ankle on same side\n        self.cpg.connect_oscillators('left_hip', 'left_knee', weight=0.8, phase_offset=0.0)\n        self.cpg.connect_oscillators('left_hip', 'left_ankle', weight=0.4, phase_offset=0.5)\n        self.cpg.connect_oscillators('right_hip', 'right_knee', weight=0.8, phase_offset=0.0)\n        self.cpg.connect_oscillators('right_hip', 'right_ankle', weight=0.4, phase_offset=0.5)\n\n    def generate_joint_commands(self, desired_speed, terrain_info, dt=0.005):\n        \"\"\"Generate joint commands for walking at desired speed\"\"\"\n        # Update CPG\n        self.cpg.update()\n        cpg_outputs = self.cpg.get_all_outputs()\n\n        # Get adaptive gait parameters\n        gait_params = self.adaptive_controller.adapt_gait_parameters(terrain_info)\n\n        # Generate joint commands based on CPG outputs and gait parameters\n        joint_commands = np.zeros(len(self.joint_mapping))\n\n        for joint_name, output in cpg_outputs.items():\n            if joint_name in self.joint_mapping:\n                joint_idx = self.joint_mapping[joint_name]\n\n                # Scale output based on gait parameters\n                base_command = output * gait_params.get('step_length', 0.3) * 2.0\n\n                # Add speed modulation\n                speed_factor = min(1.5, max(0.5, desired_speed / 1.0))\n                joint_commands[joint_idx] = base_command * speed_factor\n\n        # Add arm swing for balance (opposite to leg swing)\n        joint_commands[self.joint_mapping['left_shoulder']] = -cpg_outputs['right_hip'] * 0.5\n        joint_commands[self.joint_mapping['right_shoulder']] = -cpg_outputs['left_hip'] * 0.5\n\n        return joint_commands\n\n    def compute_ik_for_trajectory(self, trajectory_points, target_joints):\n        \"\"\"Compute inverse kinematics for desired trajectory points\"\"\"\n        # This would implement inverse kinematics\n        # For this example, return a simplified solution\n        ik_solutions = []\n\n        for point in trajectory_points:\n            # Simplified IK - in practice, use full kinematic model\n            solution = np.zeros(len(target_joints))\n            # Example: map x,y,z position to joint angles\n            solution[0] = np.arctan2(point[1], point[0])  # Hip yaw\n            solution[1] = np.arctan2(point[2], np.sqrt(point[0]**2 + point[1]**2))  # Hip pitch\n            solution[2] = 0.5 * solution[1]  # Knee follows hip\n\n            ik_solutions.append(solution)\n\n        return np.array(ik_solutions)\n\n    def integrate_balance_control(self, joint_commands, com_error, zmp_error):\n        \"\"\"Integrate balance control with gait generation\"\"\"\n        # Add balance corrections to joint commands\n        balance_corrections = np.zeros_like(joint_commands)\n\n        # Ankle strategy for small CoM errors\n        if np.linalg.norm(com_error) < 0.05:\n            balance_corrections[self.joint_mapping['left_ankle']] = -com_error[0] * 10\n            balance_corrections[self.joint_mapping['right_ankle']] = -com_error[0] * 10\n            balance_corrections[self.joint_mapping['left_ankle'] + 1] = -com_error[1] * 5  # Roll\n            balance_corrections[self.joint_mapping['right_ankle'] + 1] = -com_error[1] * 5  # Roll\n        else:\n            # Stepping strategy for larger errors\n            print(\"Balance recovery needed - stepping strategy\")\n\n        # Apply corrections\n        corrected_commands = joint_commands + balance_corrections\n\n        return corrected_commands\n\n    def update_state(self, sensor_data):\n        \"\"\"Update internal state from sensor data\"\"\"\n        # This would process actual sensor data\n        # For simulation, we'll update positions based on commands\n        pass\n\n    def get_gait_status(self):\n        \"\"\"Get current gait status\"\"\"\n        return {\n            'walking_speed': np.linalg.norm(self.com_velocity[:2]),\n            'step_frequency': 1.0 / self.adaptive_controller.current_params['step_time'],\n            'energy_consumption': np.sum(np.abs(self.current_joint_velocities)),\n            'stability_margin': self.calculate_stability_margin()\n        }\n\n    def calculate_stability_margin(self):\n        \"\"\"Calculate stability margin based on current state\"\"\"\n        # Simplified stability calculation\n        # In practice, this would use ZMP, capture point, or other stability metrics\n        com_pos = self.com_position\n        foot_positions = self.get_foot_positions()\n\n        # Calculate distance to nearest support foot\n        min_distance = float('inf')\n        for foot_pos in foot_positions:\n            distance = np.linalg.norm(com_pos[:2] - foot_pos[:2])\n            min_distance = min(min_distance, distance)\n\n        # Stability margin is distance to support polygon\n        return min_distance\n\n    def get_foot_positions(self):\n        \"\"\"Get current foot positions (simplified)\"\"\"\n        # This would use forward kinematics in practice\n        # For simulation, return approximate positions\n        left_foot = np.array([self.com_position[0], self.com_position[1] + 0.1, 0.0])\n        right_foot = np.array([self.com_position[0], self.com_position[1] - 0.1, 0.0])\n        return [left_foot, right_foot]\n\n# Example: Whole-body gait controller\n# This would be connected to an actual robot model in practice\nclass SimpleRobotModel:\n    def __init__(self):\n        self.joint_names = ['left_hip', 'left_knee', 'left_ankle', 'right_hip', 'right_knee', 'right_ankle']\n        self.mass = 70.0\n        self.height = 1.7\n\nrobot_model = SimpleRobotModel()\nwhole_body_controller = WholeBodyGaitController(robot_model)\n\n# Simulate walking\nterrain_info = {'slope': 0.0, 'roughness': 0.01, 'obstacles': [], 'surface_type': 'flat'}\ndesired_speed = 0.8  # m/s\n\n# Generate commands for one control cycle\njoint_commands = whole_body_controller.generate_joint_commands(desired_speed, terrain_info)\nprint(f\"Generated {len(joint_commands)} joint commands\")\nprint(f\"Sample commands: {joint_commands[:3]}\")\n\n# Simulate balance integration\ncom_error = np.array([0.02, -0.01, 0.0])  # Small CoM error\nzmp_error = np.array([0.01, 0.005, 0.0])\n\ncorrected_commands = whole_body_controller.integrate_balance_control(\n    joint_commands, com_error, zmp_error\n)\nprint(f\"Balance-corrected commands: {corrected_commands[:3]}\")\n\n# Get gait status\nstatus = whole_body_controller.get_gait_status()\nprint(f\"Gait status - Speed: {status['walking_speed']:.2f} m/s, \"\n      f\"Stability: {status['stability_margin']:.3f} m\")\n"})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"Gait generation and pattern formation represent a sophisticated approach to creating natural, adaptive walking behaviors in humanoid robots. The integration of biological inspiration through Central Pattern Generators, mathematical models like Fourier series and B\xe9zier curves, and learning algorithms enables robots to generate stable, efficient, and adaptable walking patterns."}),"\n",(0,o.jsx)(n.p,{children:"The key to successful gait generation lies in the coordination of multiple systems: rhythmic pattern generation, trajectory planning, adaptation to environmental conditions, and integration with balance control systems. Modern approaches combine these elements in whole-body controllers that can adapt to different terrains, speeds, and perturbations while maintaining stable locomotion."}),"\n",(0,o.jsx)(n.p,{children:"The next section will explore terrain adaptation and footstep planning, building on these gait generation foundations to enable robots to navigate complex environments effectively."})]})}function _(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>a,x:()=>s});var i=t(6540);const o={},r=i.createContext(o);function a(e){const n=i.useContext(r);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:a(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);