"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[753],{7095:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>a,contentTitle:()=>l,default:()=>m,frontMatter:()=>s,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-humanoid-control/motor-control","title":"Motor Control Systems: From High-Level Commands to Actuator Commands","description":"Introduction: The Robotic Muscular System","source":"@site/docs/module-2-humanoid-control/motor-control.md","sourceDirName":"module-2-humanoid-control","slug":"/module-2-humanoid-control/motor-control","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/motor-control","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-humanoid-control/motor-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Balance and Stability: Maintaining Upright Posture","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/balance-stability"},"next":{"title":"Practical Examples and Exercises: Humanoid Control Implementation","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/practical-examples"}}');var r=o(4848),i=o(8453);const s={},l="Motor Control Systems: From High-Level Commands to Actuator Commands",a={},c=[{value:"Introduction: The Robotic Muscular System",id:"introduction-the-robotic-muscular-system",level:2},{value:"The Control Hierarchy in Humanoid Robots",id:"the-control-hierarchy-in-humanoid-robots",level:3},{value:"Actuator Technologies for Humanoid Robots",id:"actuator-technologies-for-humanoid-robots",level:2},{value:"Types of Actuators",id:"types-of-actuators",level:3},{value:"Servo Motors",id:"servo-motors",level:4},{value:"Series Elastic Actuators (SEA)",id:"series-elastic-actuators-sea",level:4},{value:"Variable Stiffness Actuators (VSA)",id:"variable-stiffness-actuators-vsa",level:4},{value:"Actuator Characteristics",id:"actuator-characteristics",level:3},{value:"Joint-Level Control",id:"joint-level-control",level:2},{value:"PID Control for Joint Servos",id:"pid-control-for-joint-servos",level:3},{value:"Advanced Joint Control Techniques",id:"advanced-joint-control-techniques",level:3},{value:"Feedforward Control",id:"feedforward-control",level:4},{value:"Impedance Control",id:"impedance-control",level:4},{value:"Torque Control and Force Control",id:"torque-control-and-force-control",level:2},{value:"Direct Torque Control",id:"direct-torque-control",level:3},{value:"Admittance Control",id:"admittance-control",level:3},{value:"Safety and Limit Management",id:"safety-and-limit-management",level:2},{value:"Joint Limit Handling",id:"joint-limit-handling",level:3},{value:"Collision Detection and Response",id:"collision-detection-and-response",level:3},{value:"Real-Time Control Implementation",id:"real-time-control-implementation",level:2},{value:"Real-Time Operating Systems",id:"real-time-operating-systems",level:3},{value:"Communication Protocols",id:"communication-protocols",level:3},{value:"Integration with Higher-Level Control",id:"integration-with-higher-level-control",level:2},{value:"ROS 2 Integration",id:"ros-2-integration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Model-Based Feedforward",id:"model-based-feedforward",level:3},{value:"Adaptive Control",id:"adaptive-control",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"motor-control-systems-from-high-level-commands-to-actuator-commands",children:"Motor Control Systems: From High-Level Commands to Actuator Commands"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction-the-robotic-muscular-system",children:"Introduction: The Robotic Muscular System"}),"\n",(0,r.jsx)(n.p,{children:'Motor control systems form the "muscular system" of humanoid robots, translating high-level movement commands into precise actuator torques that generate physical motion. This section explores the control architectures, algorithms, and implementation strategies that enable precise and robust actuator control while maintaining the stability and safety required for humanoid operation.'}),"\n",(0,r.jsx)(n.h3,{id:"the-control-hierarchy-in-humanoid-robots",children:"The Control Hierarchy in Humanoid Robots"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid control operates on multiple levels:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"High-Level"}),": Task planning, motion planning, and trajectory generation"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mid-Level"}),": Balance control, whole-body control, and coordination"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Low-Level"}),": Joint-level servo control and actuator management"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"Motor control systems operate at the lowest level, receiving desired joint positions, velocities, and torques from higher-level controllers and generating the appropriate electrical signals to drive actuators."}),"\n",(0,r.jsx)(n.h2,{id:"actuator-technologies-for-humanoid-robots",children:"Actuator Technologies for Humanoid Robots"}),"\n",(0,r.jsx)(n.h3,{id:"types-of-actuators",children:"Types of Actuators"}),"\n",(0,r.jsx)(n.h4,{id:"servo-motors",children:"Servo Motors"}),"\n",(0,r.jsx)(n.p,{children:"Servo motors are the most common actuators in humanoid robots:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Precision"}),": High-resolution position control"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Speed"}),": Fast response times"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Torque"}),": Adequate torque for humanoid applications"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Integration"}),": Built-in position/velocity/torque sensing"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"series-elastic-actuators-sea",children:"Series Elastic Actuators (SEA)"}),"\n",(0,r.jsx)(n.p,{children:"SEAs incorporate a spring in series with the motor:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Compliance"}),": Built-in compliance for safe interaction"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Force Control"}),": Direct force control capability"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Backdrivability"}),": Easy manual manipulation when powered off"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Energy Storage"}),": Spring can store and release energy"]}),"\n"]}),"\n",(0,r.jsx)(n.h4,{id:"variable-stiffness-actuators-vsa",children:"Variable Stiffness Actuators (VSA)"}),"\n",(0,r.jsx)(n.p,{children:"VSAs allow adjustment of joint stiffness:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Adaptability"}),": Stiffness can be adjusted for different tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Energy Efficiency"}),": Lower stiffness for compliant tasks"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety"}),": Reduced impact forces during collisions"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"actuator-characteristics",children:"Actuator Characteristics"}),"\n",(0,r.jsx)(n.p,{children:"Each actuator type has specific characteristics that affect control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ActuatorModel:\n    def __init__(self, actuator_type="servo"):\n        self.type = actuator_type\n        self.max_torque = 0  # Nm\n        self.max_velocity = 0  # rad/s\n        self.gear_ratio = 0\n        self.torque_constant = 0  # Nm/A\n        self.backlash = 0  # rad\n        self.friction_params = [0, 0, 0]  # Static, Coulomb, Viscous\n\n    def compute_torque_limit(self, velocity):\n        """Compute maximum available torque based on speed"""\n        # Torque-velocity curve\n        max_torque = self.max_torque\n        if abs(velocity) > self.max_velocity * 0.8:\n            # Torque decreases at high speeds\n            max_torque *= (1 - abs(velocity) / self.max_velocity)\n        return max_torque\n\n    def model_friction(self, velocity):\n        """Model friction effects"""\n        if abs(velocity) < 0.01:  # Static friction region\n            friction_torque = self.friction_params[0] * np.sign(velocity)\n        else:  # Dynamic friction\n            friction_torque = (self.friction_params[1] * np.sign(velocity) +\n                             self.friction_params[2] * velocity)\n        return friction_torque\n'})}),"\n",(0,r.jsx)(n.h2,{id:"joint-level-control",children:"Joint-Level Control"}),"\n",(0,r.jsx)(n.h3,{id:"pid-control-for-joint-servos",children:"PID Control for Joint Servos"}),"\n",(0,r.jsx)(n.p,{children:"Proportional-Integral-Derivative (PID) controllers form the foundation of joint-level control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class JointController:\n    def __init__(self, kp=100, ki=10, kd=20):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n        self.integral_error = 0\n        self.previous_error = 0\n        self.max_integral = 10  # Anti-windup limit\n        self.max_torque = 100   # Torque limit (Nm)\n\n    def compute_command(self, desired_pos, current_pos, desired_vel=0, current_vel=0, dt=0.001):\n        """Compute joint control command"""\n        # Position error\n        pos_error = desired_pos - current_pos\n\n        # Integral of error (with anti-windup)\n        self.integral_error += pos_error * dt\n        self.integral_error = np.clip(self.integral_error,\n                                    -self.max_integral, self.max_integral)\n\n        # Derivative of error\n        derivative_error = (pos_error - self.previous_error) / dt if dt > 0 else 0\n        self.previous_error = pos_error\n\n        # PID control law\n        torque = (self.kp * pos_error +\n                 self.ki * self.integral_error +\n                 self.kd * (desired_vel - current_vel))\n\n        # Apply torque limits\n        torque = np.clip(torque, -self.max_torque, self.max_torque)\n\n        return torque\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-joint-control-techniques",children:"Advanced Joint Control Techniques"}),"\n",(0,r.jsx)(n.h4,{id:"feedforward-control",children:"Feedforward Control"}),"\n",(0,r.jsx)(n.p,{children:"Feedforward control improves tracking performance by anticipating required torques:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class FeedforwardController:\n    def __init__(self):\n        self.inverse_dynamics = InverseDynamicsModel()\n\n    def compute_feedforward_torque(self, desired_pos, desired_vel, desired_acc, robot_state):\n        """Compute feedforward torque based on desired trajectory"""\n        # Gravity compensation\n        gravity_torque = self.inverse_dynamics.gravity_compensation(robot_state.q)\n\n        # Coriolis and centrifugal compensation\n        coriolis_torque = self.inverse_dynamics.coriolis_compensation(\n            robot_state.q, robot_state.q_dot\n        )\n\n        # Inertia shaping\n        inertia_torque = self.inverse_dynamics.inertia_matrix(robot_state.q) @ desired_acc\n\n        # Total feedforward torque\n        ff_torque = inertia_torque + coriolis_torque + gravity_torque\n\n        return ff_torque\n\n    def combined_control(self, desired_pos, desired_vel, desired_acc, current_pos, current_vel):\n        """Combine feedback and feedforward control"""\n        # Feedback control (from PID controller)\n        feedback_torque = self.feedback_controller.compute_command(\n            desired_pos, current_pos, desired_vel, current_vel\n        )\n\n        # Feedforward control\n        feedforward_torque = self.compute_feedforward_torque(\n            desired_pos, desired_vel, desired_acc,\n            type(\'RobotState\', (), {\'q\': current_pos, \'q_dot\': current_vel})()\n        )\n\n        # Combined command\n        total_torque = feedback_torque + feedforward_torque\n\n        return total_torque\n'})}),"\n",(0,r.jsx)(n.h4,{id:"impedance-control",children:"Impedance Control"}),"\n",(0,r.jsx)(n.p,{children:"Impedance control makes joints behave like springs and dampers:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ImpedanceController:\n    def __init__(self, stiffness=100, damping=20):\n        self.stiffness = stiffness  # N/m or Nm/rad\n        self.damping = damping      # N*s/m or Nm*s/rad\n\n    def compute_impedance_force(self, pos_error, vel_error):\n        """Compute impedance control force"""\n        force = self.stiffness * pos_error + self.damping * vel_error\n        return force\n\n    def set_impedance_parameters(self, stiffness, damping):\n        """Adjust impedance parameters for different tasks"""\n        self.stiffness = stiffness\n        self.damping = damping\n'})}),"\n",(0,r.jsx)(n.h2,{id:"torque-control-and-force-control",children:"Torque Control and Force Control"}),"\n",(0,r.jsx)(n.h3,{id:"direct-torque-control",children:"Direct Torque Control"}),"\n",(0,r.jsx)(n.p,{children:"Direct torque control provides precise force regulation:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class TorqueController:\n    def __init__(self, kp=10, ki=1, kd=2):\n        self.kp = kp\n        self.ki = ki\n        self.kd = kd\n        self.integral_error = 0\n        self.previous_error = 0\n\n    def compute_current_command(self, desired_torque, actual_torque, dt):\n        """Convert torque error to current command"""\n        torque_error = desired_torque - actual_torque\n\n        self.integral_error += torque_error * dt\n        derivative_error = (torque_error - self.previous_error) / dt if dt > 0 else 0\n        self.previous_error = torque_error\n\n        # PID for torque control\n        current_command = (self.kp * torque_error +\n                          self.ki * self.integral_error +\n                          self.kd * derivative_error)\n\n        return current_command\n'})}),"\n",(0,r.jsx)(n.h3,{id:"admittance-control",children:"Admittance Control"}),"\n",(0,r.jsx)(n.p,{children:"Admittance control relates force inputs to motion outputs:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class AdmittanceController:\n    def __init__(self, mass=1.0, damping=10, stiffness=100):\n        self.mass = mass      # Apparent mass\n        self.damping = damping  # Apparent damping\n        self.stiffness = stiffness  # Apparent stiffness\n\n    def update_motion(self, applied_force, current_pos, current_vel, dt):\n        """Update motion based on applied force"""\n        # Admittance: motion = admittance * force\n        # M*x_ddot + B*x_dot + K*x = F\n        acceleration = (applied_force - self.damping * current_vel -\n                       self.stiffness * current_pos) / self.mass\n\n        # Integrate to get new state\n        new_vel = current_vel + acceleration * dt\n        new_pos = current_pos + new_vel * dt\n\n        return new_pos, new_vel\n'})}),"\n",(0,r.jsx)(n.h2,{id:"safety-and-limit-management",children:"Safety and Limit Management"}),"\n",(0,r.jsx)(n.h3,{id:"joint-limit-handling",children:"Joint Limit Handling"}),"\n",(0,r.jsx)(n.p,{children:"Safety systems prevent damage from joint limit violations:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class JointLimitSafety:\n    def __init__(self, joint_limits):\n        self.position_limits = joint_limits[\'position\']\n        self.velocity_limits = joint_limits[\'velocity\']\n        self.torque_limits = joint_limits[\'torque\']\n        self.safety_margin = 0.1  # 10% safety margin\n\n    def check_limits(self, position, velocity, torque):\n        """Check if joint commands are within safe limits"""\n        pos_ok = (self.position_limits[0] + self.safety_margin <= position <=\n                 self.position_limits[1] - self.safety_margin)\n        vel_ok = abs(velocity) <= self.velocity_limits[1]\n        torque_ok = abs(torque) <= self.torque_limits[1]\n\n        return pos_ok and vel_ok and torque_ok\n\n    def enforce_limits(self, command):\n        """Enforce joint limits on commands"""\n        command.position = np.clip(\n            command.position,\n            self.position_limits[0] + self.safety_margin,\n            self.position_limits[1] - self.safety_margin\n        )\n        command.velocity = np.clip(\n            command.velocity,\n            -self.velocity_limits[1],\n            self.velocity_limits[1]\n        )\n        command.torque = np.clip(\n            command.torque,\n            -self.torque_limits[1],\n            self.torque_limits[1]\n        )\n        return command\n'})}),"\n",(0,r.jsx)(n.h3,{id:"collision-detection-and-response",children:"Collision Detection and Response"}),"\n",(0,r.jsx)(n.p,{children:"Detecting and responding to collisions is crucial for safety:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class CollisionDetector:\n    def __init__(self, threshold=50):  # Nm or N\n        self.threshold = threshold\n        self.torque_history = []\n        self.max_history = 100\n\n    def detect_collision(self, current_torque, current_force=None):\n        """Detect collision based on torque/force measurements"""\n        # Add current measurement to history\n        self.torque_history.append(abs(current_torque))\n        if len(self.torque_history) > self.max_history:\n            self.torque_history.pop(0)\n\n        # Check for sudden torque increase\n        if len(self.torque_history) > 10:\n            avg_torque = np.mean(self.torque_history[-10:])\n            current_torque_mag = abs(current_torque)\n\n            if current_torque_mag > self.threshold:\n                return True, "High force detected"\n            elif current_torque_mag > 2 * avg_torque and current_torque_mag > 0.5 * self.threshold:\n                return True, "Sudden force increase detected"\n\n        return False, "No collision"\n\n    def collision_response(self, collision_type):\n        """Execute collision response"""\n        if collision_type == "High force detected":\n            # Reduce motor gains to be more compliant\n            self.reduce_control_gains()\n        elif collision_type == "Sudden force increase detected":\n            # Check if intentional contact or actual collision\n            self.assess_contact_intent()\n'})}),"\n",(0,r.jsx)(n.h2,{id:"real-time-control-implementation",children:"Real-Time Control Implementation"}),"\n",(0,r.jsx)(n.h3,{id:"real-time-operating-systems",children:"Real-Time Operating Systems"}),"\n",(0,r.jsx)(n.p,{children:"Real-time control requires deterministic timing:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import threading\nimport time\n\nclass RealTimeController:\n    def __init__(self, control_frequency=1000):  # 1kHz control\n        self.control_frequency = control_frequency\n        self.control_period = 1.0 / control_frequency\n        self.controllers = {}\n        self.running = False\n        self.thread = None\n\n    def add_joint_controller(self, joint_name, controller):\n        """Add a joint controller to the real-time system"""\n        self.controllers[joint_name] = controller\n\n    def control_loop(self):\n        """Real-time control loop"""\n        while self.running:\n            start_time = time.time()\n\n            # Read sensor data\n            sensor_data = self.read_sensors()\n\n            # Update all controllers\n            for joint_name, controller in self.controllers.items():\n                command = controller.compute_command(\n                    sensor_data[joint_name].desired_pos,\n                    sensor_data[joint_name].current_pos,\n                    sensor_data[joint_name].desired_vel,\n                    sensor_data[joint_name].current_vel,\n                    self.control_period\n                )\n                self.send_command(joint_name, command)\n\n            # Maintain timing\n            elapsed = time.time() - start_time\n            sleep_time = self.control_period - elapsed\n            if sleep_time > 0:\n                time.sleep(sleep_time)\n            else:\n                print(f"Control deadline missed by {abs(sleep_time)*1000:.1f}ms")\n\n    def start(self):\n        """Start the real-time control loop"""\n        self.running = True\n        self.thread = threading.Thread(target=self.control_loop)\n        self.thread.start()\n\n    def stop(self):\n        """Stop the real-time control loop"""\n        self.running = False\n        if self.thread:\n            self.thread.join()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"communication-protocols",children:"Communication Protocols"}),"\n",(0,r.jsx)(n.p,{children:"Efficient communication between controllers and actuators:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class CANBusInterface:\n    """CAN bus interface for motor communication"""\n    def __init__(self, can_channel="can0"):\n        self.can_channel = can_channel\n        self.bus = None\n\n    def send_torque_command(self, motor_id, torque):\n        """Send torque command to specific motor"""\n        # Pack torque into CAN message\n        torque_int = int(torque * 1000)  # Convert to milli-Nm\n        data = torque_int.to_bytes(4, byteorder=\'little\', signed=True)\n\n        # Create CAN message\n        msg = can.Message(\n            arbitration_id=0x140 + motor_id,  # Standard torque command ID\n            data=data,\n            is_extended_id=True\n        )\n\n        # Send message\n        self.bus.send(msg)\n\n    def read_feedback(self, motor_id):\n        """Read position, velocity, torque feedback"""\n        # Request feedback\n        request_msg = can.Message(\n            arbitration_id=0x180 + motor_id,\n            data=[0x01],  # Request position\n            is_extended_id=True\n        )\n        self.bus.send(request_msg)\n\n        # Wait for response\n        response = self.bus.recv(timeout=0.01)  # 10ms timeout\n        if response:\n            pos_raw = int.from_bytes(response.data[0:4], byteorder=\'little\', signed=True)\n            vel_raw = int.from_bytes(response.data[4:8], byteorder=\'little\', signed=True)\n\n            position = pos_raw / 10000.0  # Convert to radians\n            velocity = vel_raw / 1000.0   # Convert to rad/s\n\n            return position, velocity\n        return None, None\n'})}),"\n",(0,r.jsx)(n.h2,{id:"integration-with-higher-level-control",children:"Integration with Higher-Level Control"}),"\n",(0,r.jsx)(n.h3,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,r.jsx)(n.p,{children:"Connecting motor control with the ROS 2 communication framework:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import Float64MultiArray\nfrom sensor_msgs.msg import JointState\n\nclass MotorControllerNode(Node):\n    def __init__(self):\n        super().__init__(\'motor_controller\')\n\n        # Publishers and subscribers\n        self.joint_command_sub = self.create_subscription(\n            Float64MultiArray,\n            \'/joint_commands\',\n            self.joint_command_callback,\n            10\n        )\n\n        self.joint_state_pub = self.create_publisher(\n            JointState,\n            \'/joint_states\',\n            10\n        )\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.001, self.control_loop)  # 1kHz\n\n        # Initialize motor controllers\n        self.motor_controllers = self.initialize_controllers()\n\n    def joint_command_callback(self, msg):\n        """Handle incoming joint commands"""\n        self.desired_positions = msg.data\n\n    def control_loop(self):\n        """Main control loop"""\n        # Read current joint states\n        current_states = self.read_joint_states()\n\n        # Compute control commands\n        commands = []\n        for i, (desired_pos, current_state) in enumerate(zip(self.desired_positions, current_states)):\n            command = self.motor_controllers[i].compute_command(\n                desired_pos, current_state.position, 0, current_state.velocity, 0.001\n            )\n            commands.append(command)\n\n        # Send commands to motors\n        self.send_motor_commands(commands)\n\n        # Publish joint states\n        self.publish_joint_states(current_states)\n\n    def read_joint_states(self):\n        """Read current joint states from hardware"""\n        # Implementation depends on hardware interface\n        pass\n\n    def send_motor_commands(self, commands):\n        """Send computed commands to motor hardware"""\n        # Implementation depends on communication protocol\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(n.h3,{id:"model-based-feedforward",children:"Model-Based Feedforward"}),"\n",(0,r.jsx)(n.p,{children:"Using dynamic models to improve tracking performance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ModelBasedController:\n    def __init__(self, robot_model):\n        self.model = robot_model\n        self.inverse_dynamics = InverseDynamicsCalculator(robot_model)\n\n    def compute_model_based_command(self, desired_trajectory, current_state):\n        """Compute control command using model-based feedforward"""\n        # Inverse dynamics to compute required torques\n        feedforward_torque = self.inverse_dynamics.calculate(\n            desired_trajectory.positions,\n            desired_trajectory.velocities,\n            desired_trajectory.accelerations\n        )\n\n        # Feedback control for error correction\n        feedback_torque = self.feedback_controller.compute_command(\n            desired_trajectory.positions,\n            current_state.positions,\n            desired_trajectory.velocities,\n            current_state.velocities\n        )\n\n        # Combined command\n        total_torque = feedforward_torque + feedback_torque\n\n        return total_torque\n'})}),"\n",(0,r.jsx)(n.h3,{id:"adaptive-control",children:"Adaptive Control"}),"\n",(0,r.jsx)(n.p,{children:"Adjusting control parameters based on system behavior:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class AdaptiveController:\n    def __init__(self, initial_params):\n        self.params = initial_params\n        self.param_adaptation_rate = 0.01\n\n    def update_parameters(self, tracking_error, regressor_vector):\n        """Update controller parameters based on tracking error"""\n        # Parameter update law\n        param_update = (self.param_adaptation_rate *\n                       tracking_error * regressor_vector)\n        self.params += param_update\n\n        # Apply parameter constraints\n        self.params = np.clip(self.params, self.min_params, self.max_params)\n\n        return self.params\n\n    def compute_adaptive_command(self, state_error, state_derivative_error):\n        """Compute command with adaptive parameters"""\n        # Use adapted parameters in control law\n        command = (self.params[\'kp\'] * state_error +\n                  self.params[\'kd\'] * state_derivative_error)\n\n        return command\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Motor control systems form the critical interface between high-level planning and physical execution in humanoid robots. From basic PID control to advanced model-based and adaptive techniques, these systems must operate in real-time while ensuring safety, precision, and robustness. The integration of motor control with the broader ROS 2 communication framework enables coordinated whole-body behavior while maintaining the low-level precision required for stable humanoid operation."}),"\n",(0,r.jsx)(n.p,{children:"The next section will provide practical examples and exercises to reinforce the concepts learned in this module, allowing students to implement and experiment with the control strategies discussed."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>s,x:()=>l});var t=o(6540);const r={},i=t.createContext(r);function s(e){const n=t.useContext(i);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);