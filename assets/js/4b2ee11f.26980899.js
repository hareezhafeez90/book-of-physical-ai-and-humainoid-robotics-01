"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[201],{2977:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>m,frontMatter:()=>a,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-humanoid-control/dynamics-control","title":"Dynamics and Control: Motion Planning for Humanoid Systems","description":"Introduction: From Kinematics to Dynamics","source":"@site/docs/module-2-humanoid-control/dynamics-control.md","sourceDirName":"module-2-humanoid-control","slug":"/module-2-humanoid-control/dynamics-control","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/dynamics-control","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-humanoid-control/dynamics-control.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Humanoid Kinematics: Forward and Inverse Kinematics","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/kinematics"},"next":{"title":"Balance and Stability: Maintaining Upright Posture","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/balance-stability"}}');var i=o(4848),r=o(8453);const a={},s="Dynamics and Control: Motion Planning for Humanoid Systems",l={},c=[{value:"Introduction: From Kinematics to Dynamics",id:"introduction-from-kinematics-to-dynamics",level:2},{value:"Why Dynamics Matter for Humanoid Robots",id:"why-dynamics-matter-for-humanoid-robots",level:3},{value:"Mathematical Models of Robot Dynamics",id:"mathematical-models-of-robot-dynamics",level:2},{value:"The Euler-Lagrange Equation",id:"the-euler-lagrange-equation",level:3},{value:"The Mass Matrix",id:"the-mass-matrix",level:3},{value:"Coriolis and Centrifugal Terms",id:"coriolis-and-centrifugal-terms",level:3},{value:"Gravity Vector",id:"gravity-vector",level:3},{value:"Control Strategies for Humanoid Systems",id:"control-strategies-for-humanoid-systems",level:2},{value:"Computed Torque Control (Inverse Dynamics Control)",id:"computed-torque-control-inverse-dynamics-control",level:3},{value:"Operational Space Control",id:"operational-space-control",level:3},{value:"Python Implementation: Computed Torque Control",id:"python-implementation-computed-torque-control",level:3},{value:"Balance and Stability Control",id:"balance-and-stability-control",level:2},{value:"Zero-Moment Point (ZMP) Control",id:"zero-moment-point-zmp-control",level:3},{value:"Center of Mass (CoM) Control",id:"center-of-mass-com-control",level:3},{value:"Preview Control",id:"preview-control",level:3},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:2},{value:"Inverted Pendulum Model",id:"inverted-pendulum-model",level:3},{value:"Footstep Planning",id:"footstep-planning",level:3},{value:"Advanced Control Techniques",id:"advanced-control-techniques",level:2},{value:"Model Predictive Control (MPC)",id:"model-predictive-control-mpc",level:3},{value:"Adaptive Control",id:"adaptive-control",level:3},{value:"Real-Time Implementation Considerations",id:"real-time-implementation-considerations",level:2},{value:"Computational Complexity",id:"computational-complexity",level:3},{value:"Sensor Integration",id:"sensor-integration",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"dynamics-and-control-motion-planning-for-humanoid-systems",children:"Dynamics and Control: Motion Planning for Humanoid Systems"})}),"\n",(0,i.jsx)(n.h2,{id:"introduction-from-kinematics-to-dynamics",children:"Introduction: From Kinematics to Dynamics"}),"\n",(0,i.jsx)(n.p,{children:"While kinematics describes the geometry of motion, dynamics considers the forces and torques that cause motion. For humanoid robots, dynamics is crucial because these systems must interact with the environment, maintain balance under external forces, and execute movements while respecting physical constraints. This section explores the mathematical models and control strategies that enable robust humanoid motion."}),"\n",(0,i.jsx)(n.h3,{id:"why-dynamics-matter-for-humanoid-robots",children:"Why Dynamics Matter for Humanoid Robots"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid robots operate in dynamic environments where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"External forces affect robot stability"}),"\n",(0,i.jsx)(n.li,{children:"Robot motion generates internal forces and torques"}),"\n",(0,i.jsx)(n.li,{children:"Balance must be maintained during movement"}),"\n",(0,i.jsx)(n.li,{children:"Energy efficiency is critical for sustained operation"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"mathematical-models-of-robot-dynamics",children:"Mathematical Models of Robot Dynamics"}),"\n",(0,i.jsx)(n.h3,{id:"the-euler-lagrange-equation",children:"The Euler-Lagrange Equation"}),"\n",(0,i.jsx)(n.p,{children:"The dynamics of a robotic system can be described by the Euler-Lagrange equation:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"M(q)q_ddot + C(q, q_dot)q_dot + g(q) = \u03c4\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"M(q)"})," is the mass/inertia matrix"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"C(q, q_dot)"})," contains Coriolis and centrifugal terms"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"g(q)"})," represents gravitational forces"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"\u03c4"})," is the vector of joint torques"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"q"}),", ",(0,i.jsx)(n.code,{children:"q_dot"}),", ",(0,i.jsx)(n.code,{children:"q_ddot"})," are joint positions, velocities, and accelerations"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"the-mass-matrix",children:"The Mass Matrix"}),"\n",(0,i.jsxs)(n.p,{children:["The mass matrix ",(0,i.jsx)(n.code,{children:"M(q)"})," represents the inertial properties of the robot as a function of configuration. It is symmetric and positive definite, meaning energy is always positive. For a humanoid robot, the mass matrix accounts for the distribution of mass in all links and how they interact through the kinematic structure."]}),"\n",(0,i.jsx)(n.h3,{id:"coriolis-and-centrifugal-terms",children:"Coriolis and Centrifugal Terms"}),"\n",(0,i.jsxs)(n.p,{children:["The term ",(0,i.jsx)(n.code,{children:"C(q, q_dot)q_dot"})," represents forces due to velocity coupling between joints. These forces arise because the motion of one link affects the motion of other links through the kinematic chain."]}),"\n",(0,i.jsx)(n.h3,{id:"gravity-vector",children:"Gravity Vector"}),"\n",(0,i.jsxs)(n.p,{children:["The term ",(0,i.jsx)(n.code,{children:"g(q)"})," represents the gravitational forces acting on the robot in its current configuration. This includes both the weight of each link and the gravitational coupling between links."]}),"\n",(0,i.jsx)(n.h2,{id:"control-strategies-for-humanoid-systems",children:"Control Strategies for Humanoid Systems"}),"\n",(0,i.jsx)(n.h3,{id:"computed-torque-control-inverse-dynamics-control",children:"Computed Torque Control (Inverse Dynamics Control)"}),"\n",(0,i.jsx)(n.p,{children:"Computed torque control uses the dynamic model to linearize the system:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"\u03c4 = M(q)q_ddot_des + C(q, q_dot)q_dot + g(q) + Kp(q_des - q) + Kd(q_dot_des - q_dot)\n"})}),"\n",(0,i.jsx)(n.p,{children:"This control law:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:"Computes the required torques for desired acceleration"}),"\n",(0,i.jsx)(n.li,{children:"Compensates for gravity and Coriolis effects"}),"\n",(0,i.jsx)(n.li,{children:"Adds PD feedback for error correction"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"operational-space-control",children:"Operational Space Control"}),"\n",(0,i.jsx)(n.p,{children:"Operational space control focuses on task-space variables rather than joint-space variables:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"F = \u039b(x)(x_ddot_des - x_ddot) + Kp(x_des - x) + Kd(x_dot_des - x_dot)\n\u03c4 = J^T F\n"})}),"\n",(0,i.jsx)(n.p,{children:"Where:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"\u039b(x)"})," is the task-space inertia matrix"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"x"})," represents task-space variables (end-effector position, orientation)"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"J"})," is the Jacobian matrix"]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"This approach is particularly useful for humanoid robots performing tasks in Cartesian space while maintaining balance."}),"\n",(0,i.jsx)(n.h3,{id:"python-implementation-computed-torque-control",children:"Python Implementation: Computed Torque Control"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'import numpy as np\n\nclass HumanoidDynamics:\n    def __init__(self, mass_matrix, coriolis_matrix, gravity_vector):\n        self.M = mass_matrix\n        self.C = coriolis_matrix\n        self.g = gravity_vector\n        self.Kp = np.diag([100, 100, 100, 50, 50, 50])  # Position gains\n        self.Kd = np.diag([20, 20, 20, 10, 10, 10])    # Velocity gains\n\n    def mass_matrix(self, q):\n        """Calculate mass matrix M(q) - simplified for example"""\n        # In practice, this would be calculated from robot URDF/URDF\n        n = len(q)\n        M = np.eye(n) * 2.0  # Simplified constant mass matrix\n        # Add coupling terms based on kinematic structure\n        for i in range(n-1):\n            M[i, i+1] = 0.1\n            M[i+1, i] = 0.1\n        return M\n\n    def coriolis_vector(self, q, q_dot):\n        """Calculate Coriolis and centrifugal terms C(q, q_dot)q_dot"""\n        # Simplified model - in practice this involves complex calculations\n        Cq_dot = np.zeros_like(q_dot)\n        for i in range(len(q)):\n            # Simplified Coriolis terms\n            if i < len(q) - 1:\n                Cq_dot[i] = 0.5 * q_dot[i] * q_dot[i+1]\n        return Cq_dot\n\n    def gravity_vector(self, q):\n        """Calculate gravity terms g(q)"""\n        # Simplified gravity vector\n        g = np.zeros_like(q)\n        g[0] = 9.81 * 0.1  # Gravity effect on first joint\n        return g\n\n    def computed_torque_control(self, q, q_dot, q_des, q_dot_des, q_ddot_des):\n        """Computed torque control law"""\n        M = self.mass_matrix(q)\n        Cq_dot = self.coriolis_vector(q, q_dot)\n        g = self.gravity_vector(q)\n\n        # Feedback terms\n        pos_error = q_des - q\n        vel_error = q_dot_des - q_dot\n\n        # Control law\n        tau = (M @ q_ddot_des +\n               Cq_dot +\n               g +\n               self.Kp @ pos_error +\n               self.Kd @ vel_error)\n\n        return tau\n\n    def operational_space_control(self, q, q_dot, x_des, x_dot_des, x_ddot_des, J, J_dot):\n        """Operational space control"""\n        # Calculate Jacobian transpose\n        J_T = J.T\n\n        # Calculate mass matrix in operational space\n        M_inv = np.linalg.inv(self.mass_matrix(q))\n        Lambda_inv = J @ M_inv @ J_T\n        Lambda = np.linalg.inv(Lambda_inv)\n\n        # Calculate bias forces in operational space\n        Cq_dot = self.coriolis_vector(q, q_dot)\n        g = self.gravity_vector(q)\n        h_op = J @ M_inv @ (Cq_dot + g) - Lambda @ (J_dot @ q_dot)\n\n        # Calculate operational space error\n        x = self.forward_kinematics(q)  # Simplified\n        x_error = x_des - x\n        x_dot_error = x_dot_des - J @ q_dot\n\n        # Control law in operational space\n        F = (Lambda @ x_ddot_des +\n             h_op +\n             self.Kp[:len(x_error)] @ x_error +\n             self.Kd[:len(x_dot_error)] @ x_dot_error)\n\n        # Convert to joint torques\n        tau = J_T @ F\n\n        return tau\n'})}),"\n",(0,i.jsx)(n.h2,{id:"balance-and-stability-control",children:"Balance and Stability Control"}),"\n",(0,i.jsx)(n.h3,{id:"zero-moment-point-zmp-control",children:"Zero-Moment Point (ZMP) Control"}),"\n",(0,i.jsx)(n.p,{children:"The Zero-Moment Point is a crucial concept for humanoid balance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"ZMP_x = x_com - (g/(z_com - z_ref)) * (x_com_ddot)\nZMP_y = y_com - (g/(z_com - z_ref)) * (y_com_ddot)\n"})}),"\n",(0,i.jsx)(n.p,{children:"For stable walking, the ZMP must remain within the support polygon (typically the foot area)."}),"\n",(0,i.jsx)(n.h3,{id:"center-of-mass-com-control",children:"Center of Mass (CoM) Control"}),"\n",(0,i.jsx)(n.p,{children:"CoM control strategies maintain balance by regulating the position and acceleration of the robot's center of mass:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def zmp_controller(current_com, current_com_vel, current_com_acc,\n                   desired_zmp, kp=1.0, kd=1.0):\n    """ZMP-based balance controller"""\n    # Calculate desired CoM acceleration to achieve desired ZMP\n    z_ref = 0.8  # Height reference (m)\n    g = 9.81\n\n    # ZMP error\n    zmp_current = current_com - (z_ref / g) * current_com_acc\n    zmp_error = desired_zmp - zmp_current\n\n    # Control law for CoM acceleration\n    com_acc_des = (g / z_ref) * (current_com - desired_zmp) + kp * zmp_error + kd * (0 - current_com_vel)\n\n    return com_acc_des\n'})}),"\n",(0,i.jsx)(n.h3,{id:"preview-control",children:"Preview Control"}),"\n",(0,i.jsx)(n.p,{children:"Preview control uses future reference trajectories to improve balance:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def preview_control(zmp_reference, preview_horizon=20, dt=0.01):\n    """Preview control for ZMP tracking"""\n    # Calculate preview control gains (simplified)\n    A = np.array([[0, 1], [g/1.0, 0]])  # Simplified for 1D\n    B = np.array([0, g/1.0])\n\n    # Solve Riccati equation for LQR\n    # In practice, this would involve more complex calculations\n    K = np.array([1.0, 1.0])  # Feedback gains\n\n    # Calculate preview gains\n    preview_gains = []\n    for i in range(preview_horizon):\n        # Calculate future influence\n        gain = np.exp(-i * dt)  # Simplified preview gain\n        preview_gains.append(gain)\n\n    return preview_gains\n'})}),"\n",(0,i.jsx)(n.h2,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,i.jsx)(n.h3,{id:"inverted-pendulum-model",children:"Inverted Pendulum Model"}),"\n",(0,i.jsx)(n.p,{children:"The linear inverted pendulum model (LIPM) is commonly used for humanoid walking:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{children:"x_ddot = \u03c9\xb2(x - x_zmp)\n"})}),"\n",(0,i.jsxs)(n.p,{children:["Where ",(0,i.jsx)(n.code,{children:"\u03c9\xb2 = g/h"})," and ",(0,i.jsx)(n.code,{children:"h"})," is the CoM height."]}),"\n",(0,i.jsx)(n.h3,{id:"footstep-planning",children:"Footstep Planning"}),"\n",(0,i.jsx)(n.p,{children:"Walking requires careful footstep planning to maintain stability:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:"def generate_walk_pattern(step_length=0.3, step_width=0.2, step_height=0.1,\n                         step_time=0.8, n_steps=10):\n    \"\"\"Generate walking pattern parameters\"\"\"\n    footsteps = []\n\n    for i in range(n_steps):\n        # Alternate between left and right foot\n        side_offset = step_width/2 if i % 2 == 0 else -step_width/2\n\n        # Calculate foot position\n        x_pos = (i + 1) * step_length\n        y_pos = side_offset\n        z_pos = 0  # Ground level\n\n        # Add timing information\n        step_timing = i * step_time\n\n        footsteps.append({\n            'position': [x_pos, y_pos, z_pos],\n            'timing': step_timing,\n            'step_height': step_height,\n            'step_time': step_time\n        })\n\n    return footsteps\n"})}),"\n",(0,i.jsx)(n.h2,{id:"advanced-control-techniques",children:"Advanced Control Techniques"}),"\n",(0,i.jsx)(n.h3,{id:"model-predictive-control-mpc",children:"Model Predictive Control (MPC)"}),"\n",(0,i.jsx)(n.p,{children:"MPC optimizes control inputs over a finite horizon while considering constraints:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'def mpc_controller(state, reference_trajectory, prediction_horizon=10,\n                   control_horizon=5, dt=0.01):\n    """Model Predictive Control for humanoid systems"""\n\n    # Define cost function\n    Q = np.eye(len(state)) * 1.0    # State tracking cost\n    R = np.eye(3) * 0.1            # Control effort cost\n    P = np.eye(len(state)) * 10.0   # Terminal cost\n\n    # Linearize system around current state\n    A, B = linearize_dynamics(state)\n\n    # Set up optimization problem\n    # Minimize: sum(x_k^T Q x_k + u_k^T R u_k) + x_N^T P x_N\n    # Subject to: x_k+1 = A x_k + B u_k\n\n    # In practice, this would use a QP solver\n    # For this example, we\'ll return a simplified control\n    state_error = reference_trajectory[0] - state\n    control_input = -np.linalg.inv(R) @ B.T @ state_error\n\n    return control_input\n'})}),"\n",(0,i.jsx)(n.h3,{id:"adaptive-control",children:"Adaptive Control"}),"\n",(0,i.jsx)(n.p,{children:"Adaptive control adjusts parameters based on system behavior:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-python",children:'class AdaptiveController:\n    def __init__(self, initial_params):\n        self.params = initial_params\n        self.learning_rate = 0.01\n\n    def update_params(self, tracking_error, regressor):\n        """Update adaptive parameters"""\n        # Parameter update law\n        param_update = self.learning_rate * tracking_error * regressor\n        self.params += param_update\n        return self.params\n\n    def control(self, state, desired_state):\n        """Adaptive control law"""\n        error = desired_state - state\n        control_output = self.params @ error\n        return control_output\n'})}),"\n",(0,i.jsx)(n.h2,{id:"real-time-implementation-considerations",children:"Real-Time Implementation Considerations"}),"\n",(0,i.jsx)(n.h3,{id:"computational-complexity",children:"Computational Complexity"}),"\n",(0,i.jsx)(n.p,{children:"Humanoid control systems must operate in real-time (typically 1-10ms control cycles). This requires:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Efficient algorithms"}),"\n",(0,i.jsx)(n.li,{children:"Simplified models where possible"}),"\n",(0,i.jsx)(n.li,{children:"Parallel processing for complex calculations"}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"sensor-integration",children:"Sensor Integration"}),"\n",(0,i.jsx)(n.p,{children:"Real-time control requires integration of multiple sensor sources:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Joint encoders for position feedback"}),"\n",(0,i.jsx)(n.li,{children:"IMU for orientation and acceleration"}),"\n",(0,i.jsx)(n.li,{children:"Force/torque sensors for contact detection"}),"\n",(0,i.jsx)(n.li,{children:"Vision systems for environment perception"}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,i.jsx)(n.p,{children:"Dynamics and control form the foundation of robust humanoid robot operation. The mathematical models of robot dynamics enable precise control of movement while accounting for physical constraints and environmental interactions. Control strategies like computed torque control, operational space control, and balance-aware algorithms allow humanoid robots to perform complex tasks while maintaining stability."}),"\n",(0,i.jsx)(n.p,{children:"The next section will focus specifically on balance and stability control, which is critical for humanoid robots that must maintain upright posture during various activities."})]})}function m(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>a,x:()=>s});var t=o(6540);const i={},r=t.createContext(i);function a(e){const n=t.useContext(r);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);