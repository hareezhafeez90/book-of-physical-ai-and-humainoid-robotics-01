"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[605],{1057:(e,n,o)=>{o.r(n),o.d(n,{assets:()=>i,contentTitle:()=>s,default:()=>p,frontMatter:()=>l,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-2-humanoid-control/balance-stability","title":"Balance and Stability: Maintaining Upright Posture","description":"Introduction: The Challenge of Bipedal Balance","source":"@site/docs/module-2-humanoid-control/balance-stability.md","sourceDirName":"module-2-humanoid-control","slug":"/module-2-humanoid-control/balance-stability","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/balance-stability","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-humanoid-control/balance-stability.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Dynamics and Control: Motion Planning for Humanoid Systems","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/dynamics-control"},"next":{"title":"Motor Control Systems: From High-Level Commands to Actuator Commands","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/motor-control"}}');var r=o(4848),a=o(8453);const l={},s="Balance and Stability: Maintaining Upright Posture",i={},c=[{value:"Introduction: The Challenge of Bipedal Balance",id:"introduction-the-challenge-of-bipedal-balance",level:2},{value:"Why Balance is Critical for Humanoid Robots",id:"why-balance-is-critical-for-humanoid-robots",level:3},{value:"The Physics of Balance",id:"the-physics-of-balance",level:2},{value:"Center of Mass (CoM) and Center of Pressure (CoP)",id:"center-of-mass-com-and-center-of-pressure-cop",level:3},{value:"Support Polygon",id:"support-polygon",level:3},{value:"Zero-Moment Point (ZMP) Theory",id:"zero-moment-point-zmp-theory",level:3},{value:"Balance Control Strategies",id:"balance-control-strategies",level:2},{value:"Feedback Control Approaches",id:"feedback-control-approaches",level:3},{value:"PID-Based Balance Control",id:"pid-based-balance-control",level:4},{value:"Linear Quadratic Regulator (LQR)",id:"linear-quadratic-regulator-lqr",level:4},{value:"Advanced Balance Control Methods",id:"advanced-balance-control-methods",level:3},{value:"Capture Point Theory",id:"capture-point-theory",level:4},{value:"Linear Inverted Pendulum Mode (LIPM)",id:"linear-inverted-pendulum-mode-lipm",level:4},{value:"Sensor-Based Balance Control",id:"sensor-based-balance-control",level:2},{value:"Inertial Measurement Units (IMU)",id:"inertial-measurement-units-imu",level:3},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:3},{value:"Walking Balance Control",id:"walking-balance-control",level:2},{value:"Phase-Based Balance Control",id:"phase-based-balance-control",level:3},{value:"Disturbance Recovery",id:"disturbance-recovery",level:3},{value:"Multi-Contact Balance",id:"multi-contact-balance",level:2},{value:"Using Arms for Balance",id:"using-arms-for-balance",level:3},{value:"Whole-Body Balance Control",id:"whole-body-balance-control",level:3},{value:"Practical Implementation Considerations",id:"practical-implementation-considerations",level:2},{value:"Real-Time Performance",id:"real-time-performance",level:3},{value:"Robustness to Modeling Errors",id:"robustness-to-modeling-errors",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"balance-and-stability-maintaining-upright-posture",children:"Balance and Stability: Maintaining Upright Posture"})}),"\n",(0,r.jsx)(n.h2,{id:"introduction-the-challenge-of-bipedal-balance",children:"Introduction: The Challenge of Bipedal Balance"}),"\n",(0,r.jsx)(n.p,{children:"Maintaining balance is one of the most fundamental challenges in humanoid robotics. Unlike wheeled or tracked robots that have continuous ground contact, bipedal robots must maintain stability with only two points of contact (during single support) or a small support polygon (during double support). This section explores the principles and control strategies that enable humanoid robots to maintain upright posture and recover from disturbances."}),"\n",(0,r.jsx)(n.h3,{id:"why-balance-is-critical-for-humanoid-robots",children:"Why Balance is Critical for Humanoid Robots"}),"\n",(0,r.jsx)(n.p,{children:"Balance is fundamental to humanoid robot operation because:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Safety"}),": Unstable robots can fall and damage themselves or surroundings"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Functionality"}),": Many tasks require stable posture to execute properly"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Efficiency"}),": Maintaining balance reduces energy consumption"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Human-like Operation"}),": Stable balance enables human-like movement patterns"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"the-physics-of-balance",children:"The Physics of Balance"}),"\n",(0,r.jsx)(n.h3,{id:"center-of-mass-com-and-center-of-pressure-cop",children:"Center of Mass (CoM) and Center of Pressure (CoP)"}),"\n",(0,r.jsx)(n.p,{children:"The relationship between CoM and CoP determines stability:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CoM"}),": The weighted average position of all mass in the system"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"CoP"}),": The point where the ground reaction force acts"]}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"For static balance, the CoM projection must remain within the support polygon defined by ground contact points."}),"\n",(0,r.jsx)(n.h3,{id:"support-polygon",children:"Support Polygon"}),"\n",(0,r.jsx)(n.p,{children:"The support polygon is the convex hull of all ground contact points:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Double Support"}),": Polygon defined by both feet"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Single Support"}),": Polygon defined by stance foot"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Multi-Contact"}),": Polygon defined by all contact points (e.g., hands and feet)"]}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"zero-moment-point-zmp-theory",children:"Zero-Moment Point (ZMP) Theory"}),"\n",(0,r.jsx)(n.p,{children:"The ZMP is a crucial concept in dynamic balance:"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Definition"}),": Point on the ground where the moment of the ground reaction force equals the moment of the gravitational and inertial forces"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Stability Condition"}),": ZMP must remain within the support polygon for stable motion"]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.strong,{children:"Mathematical Expression"}),":","\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{children:"px = x_com - (z_com - z_ref) / g * x_com_ddot\npy = y_com - (z_com - z_ref) / g * y_com_ddot\n"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"balance-control-strategies",children:"Balance Control Strategies"}),"\n",(0,r.jsx)(n.h3,{id:"feedback-control-approaches",children:"Feedback Control Approaches"}),"\n",(0,r.jsx)(n.h4,{id:"pid-based-balance-control",children:"PID-Based Balance Control"}),"\n",(0,r.jsx)(n.p,{children:"Proportional-Integral-Derivative controllers form the foundation of many balance systems:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class BalanceController:\n    def __init__(self, kp=100.0, ki=10.0, kd=20.0):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n        self.integral_error = 0\n        self.previous_error = 0\n\n    def compute_balance_torque(self, current_angle, desired_angle, dt):\n        """Compute balance torque using PID control"""\n        error = desired_angle - current_angle\n\n        # Integral of error\n        self.integral_error += error * dt\n\n        # Derivative of error\n        derivative_error = (error - self.previous_error) / dt\n\n        # PID control law\n        torque = (self.kp * error +\n                 self.ki * self.integral_error +\n                 self.kd * derivative_error)\n\n        self.previous_error = error\n        return torque\n'})}),"\n",(0,r.jsx)(n.h4,{id:"linear-quadratic-regulator-lqr",children:"Linear Quadratic Regulator (LQR)"}),"\n",(0,r.jsx)(n.p,{children:"LQR provides optimal control for linearized balance models:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'import numpy as np\nfrom scipy.linalg import solve_continuous_are\n\ndef lqr_balance_control(A, B, Q, R):\n    """Design LQR controller for balance system"""\n    # Solve algebraic Riccati equation\n    P = solve_continuous_are(A, B, Q, R)\n\n    # Optimal feedback gain\n    K = np.linalg.inv(R) @ B.T @ P\n\n    return K\n\n# Example: Simple inverted pendulum model\n# State: [angle, angular_velocity]\nA = np.array([[0, 1], [g/l, 0]])  # Linearized inverted pendulum\nB = np.array([[0], [1/(m*l**2)]])  # Torque input matrix\nQ = np.array([[10, 0], [0, 1]])    # State cost matrix\nR = np.array([[0.1]])              # Control cost matrix\n\nK = lqr_balance_control(A, B, Q, R)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"advanced-balance-control-methods",children:"Advanced Balance Control Methods"}),"\n",(0,r.jsx)(n.h4,{id:"capture-point-theory",children:"Capture Point Theory"}),"\n",(0,r.jsx)(n.p,{children:"The capture point is the location where a robot must step to come to a complete stop:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def compute_capture_point(com_pos, com_vel, com_height):\n    """Compute capture point for balance recovery"""\n    g = 9.81\n    omega = np.sqrt(g / com_height)\n    capture_point = com_pos + com_vel / omega\n    return capture_point\n\ndef balance_recovery_step(capture_point, current_foot_pos, max_step_size=0.3):\n    """Determine step location for balance recovery"""\n    step_vector = capture_point - current_foot_pos\n    step_distance = np.linalg.norm(step_vector)\n\n    if step_distance > max_step_size:\n        # Scale to maximum step size\n        step_vector = step_vector / step_distance * max_step_size\n\n    return current_foot_pos + step_vector\n'})}),"\n",(0,r.jsx)(n.h4,{id:"linear-inverted-pendulum-mode-lipm",children:"Linear Inverted Pendulum Mode (LIPM)"}),"\n",(0,r.jsx)(n.p,{children:"The LIPM simplifies balance control by assuming constant CoM height:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class LIPMController:\n    def __init__(self, com_height=0.8, dt=0.01):\n        self.com_height = com_height\n        self.omega = np.sqrt(9.81 / com_height)\n        self.dt = dt\n        self.zmp_ref = np.array([0.0, 0.0])\n\n    def update_zmp_reference(self, desired_com_pos, current_com_pos):\n        """Update ZMP reference based on desired CoM position"""\n        # ZMP planning using LIPM dynamics\n        com_error = desired_com_pos - current_com_pos\n        self.zmp_ref = desired_com_pos - com_error / (self.omega**2)\n        return self.zmp_ref\n\n    def compute_com_trajectory(self, zmp_trajectory):\n        """Compute CoM trajectory from ZMP trajectory"""\n        # Solve LIPM differential equation\n        # x_ddot = omega^2 * (x - zmp)\n        # This would typically use numerical integration\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"sensor-based-balance-control",children:"Sensor-Based Balance Control"}),"\n",(0,r.jsx)(n.h3,{id:"inertial-measurement-units-imu",children:"Inertial Measurement Units (IMU)"}),"\n",(0,r.jsx)(n.p,{children:"IMUs provide crucial feedback for balance control:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class IMUBasedBalance:\n    def __init__(self):\n        self.orientation = np.array([0, 0, 0, 1])  # Quaternion\n        self.angular_velocity = np.zeros(3)\n        self.linear_acceleration = np.zeros(3)\n        self.com_estimator = ComEstimator()\n\n    def process_imu_data(self, gyro_data, accel_data, dt):\n        """Process IMU data for balance control"""\n        # Integrate gyro data for orientation\n        self.angular_velocity = gyro_data\n        self.update_orientation(dt)\n\n        # Use accelerometer for gravity reference\n        self.linear_acceleration = accel_data\n\n        # Estimate CoM state\n        self.com_state = self.com_estimator.estimate(\n            self.orientation,\n            self.linear_acceleration,\n            dt\n        )\n\n    def update_orientation(self, dt):\n        """Update orientation using gyro integration"""\n        # Convert angular velocity to quaternion derivative\n        omega_quat = np.array([0, *self.angular_velocity])\n        quat_dot = 0.5 * self.quaternion_multiply(\n            self.orientation,\n            omega_quat\n        )\n\n        # Integrate\n        self.orientation += quat_dot * dt\n        # Normalize quaternion\n        self.orientation = self.orientation / np.linalg.norm(self.orientation)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,r.jsx)(n.p,{children:"Force/torque sensors in feet provide ground contact information:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class ForceBasedBalance:\n    def __init__(self):\n        self.left_foot_force = np.zeros(6)  # Fx, Fy, Fz, Mx, My, Mz\n        self.right_foot_force = np.zeros(6)\n        self.support_foot = "left"  # or "right" or "both"\n\n    def compute_zmp_from_forces(self):\n        """Compute ZMP from foot force sensors"""\n        total_force = self.left_foot_force + self.right_foot_force\n        total_moment = self.compute_total_moment()\n\n        if total_force[2] > 1.0:  # Check for sufficient normal force\n            zmp_x = -total_moment[1] / total_force[2]  # My / Fz\n            zmp_y = total_moment[0] / total_force[2]   # Mx / Fz\n            return np.array([zmp_x, zmp_y])\n        else:\n            return np.array([0.0, 0.0])  # No contact\n\n    def detect_support_switch(self):\n        """Detect when robot switches support foot"""\n        left_force_z = self.left_foot_force[2]\n        right_force_z = self.right_foot_force[2]\n\n        # Determine support foot based on force distribution\n        if left_force_z > 200 and right_force_z < 50:\n            self.support_foot = "left"\n        elif right_force_z > 200 and left_force_z < 50:\n            self.support_foot = "right"\n        else:\n            self.support_foot = "both"\n'})}),"\n",(0,r.jsx)(n.h2,{id:"walking-balance-control",children:"Walking Balance Control"}),"\n",(0,r.jsx)(n.h3,{id:"phase-based-balance-control",children:"Phase-Based Balance Control"}),"\n",(0,r.jsx)(n.p,{children:"Walking involves distinct phases that require different balance strategies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class WalkingBalanceController:\n    def __init__(self):\n        self.phase = "double_support"  # double_support, single_support_left, single_support_right\n        self.balance_controller = BalanceController()\n        self.zmp_planner = ZMPPlanner()\n\n    def update_balance_control(self, current_phase, time_in_phase):\n        """Update balance control based on walking phase"""\n        if current_phase != self.phase:\n            self.phase = current_phase\n            self.adapt_balance_strategy()\n\n        # Compute balance torques based on current phase\n        if self.phase == "double_support":\n            # More conservative balance control\n            self.balance_controller.set_gains(80, 8, 15)\n        elif self.phase == "single_support_left":\n            # Focus on left foot stability\n            self.balance_controller.set_gains(100, 10, 20)\n        elif self.phase == "single_support_right":\n            # Focus on right foot stability\n            self.balance_controller.set_gains(100, 10, 20)\n\n    def adapt_balance_strategy(self):\n        """Adapt balance strategy when phase changes"""\n        if self.phase == "double_support":\n            # Plan ZMP trajectory for double support\n            self.zmp_planner.plan_double_support_trajectory()\n        else:\n            # Plan ZMP trajectory for single support\n            self.zmp_planner.plan_single_support_trajectory()\n'})}),"\n",(0,r.jsx)(n.h3,{id:"disturbance-recovery",children:"Disturbance Recovery"}),"\n",(0,r.jsx)(n.p,{children:"Robots must be able to recover from external disturbances:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class DisturbanceRecovery:\n    def __init__(self):\n        self.disturbance_threshold = 0.5  # Threshold for disturbance detection\n        self.recovery_active = False\n\n    def detect_disturbance(self, com_acceleration, imu_data):\n        """Detect external disturbances"""\n        # Check for high acceleration or unexpected IMU readings\n        linear_acc_magnitude = np.linalg.norm(com_acceleration)\n        angular_vel_magnitude = np.linalg.norm(imu_data.angular_velocity)\n\n        if (linear_acc_magnitude > self.disturbance_threshold or\n            angular_vel_magnitude > self.disturbance_threshold):\n            return True\n        return False\n\n    def initiate_recovery(self, current_state):\n        """Initiate balance recovery sequence"""\n        if not self.recovery_active:\n            self.recovery_active = True\n\n            # Compute recovery strategy\n            capture_point = self.compute_capture_point(\n                current_state.com_pos,\n                current_state.com_vel,\n                current_state.com_height\n            )\n\n            # Determine recovery step location\n            recovery_step = self.plan_recovery_step(capture_point)\n\n            # Execute recovery\n            self.execute_recovery_step(recovery_step)\n\n    def execute_recovery_step(self, step_location):\n        """Execute a recovery step"""\n        # Move swing foot to recovery location\n        # Adjust CoM trajectory\n        # Monitor for successful recovery\n        pass\n'})}),"\n",(0,r.jsx)(n.h2,{id:"multi-contact-balance",children:"Multi-Contact Balance"}),"\n",(0,r.jsx)(n.h3,{id:"using-arms-for-balance",children:"Using Arms for Balance"}),"\n",(0,r.jsx)(n.p,{children:"Humanoid robots can use their arms to assist with balance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def arm_balance_assist(com_state, desired_com_state, current_arm_pos):\n    """Use arm movement for balance assistance"""\n    # Calculate required arm position for balance\n    com_error = desired_com_state[:2] - com_state[:2]  # X, Y position error\n\n    # Map CoM error to arm movement\n    arm_correction = -0.3 * com_error  # Proportional correction\n    desired_arm_pos = current_arm_pos + arm_correction\n\n    return desired_arm_pos\n'})}),"\n",(0,r.jsx)(n.h3,{id:"whole-body-balance-control",children:"Whole-Body Balance Control"}),"\n",(0,r.jsx)(n.p,{children:"Coordinating all degrees of freedom for optimal balance:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'class WholeBodyBalanceController:\n    def __init__(self, robot_model):\n        self.robot_model = robot_model\n        self.kinematic_solver = KinematicSolver()\n        self.dynamics_model = DynamicsModel()\n\n    def compute_balance_posture(self, desired_com, desired_zmp, support_polygons):\n        """Compute whole-body posture for balance"""\n        # Formulate optimization problem\n        # Minimize: ||q - q_nominal||^2 + ||com - desired_com||^2\n        # Subject to: zmp within support polygon, joint limits, balance constraints\n\n        # This would typically use a QP solver\n        # For this example, we\'ll outline the approach:\n\n        # 1. Define task hierarchy\n        #    - Primary: ZMP tracking\n        #    - Secondary: CoM tracking\n        #    - Tertiary: Posture optimization\n\n        # 2. Use null-space projection for task prioritization\n        # 3. Apply joint limits and balance constraints\n        # 4. Solve for joint angles\n\n        return self.solve_balance_optimization(\n            desired_com, desired_zmp, support_polygons\n        )\n'})}),"\n",(0,r.jsx)(n.h2,{id:"practical-implementation-considerations",children:"Practical Implementation Considerations"}),"\n",(0,r.jsx)(n.h3,{id:"real-time-performance",children:"Real-Time Performance"}),"\n",(0,r.jsx)(n.p,{children:"Balance controllers must operate in real-time:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def real_time_balance_loop(sensor_data, dt):\n    """Real-time balance control loop"""\n    # 1. Sensor data processing (1-2ms)\n    processed_data = process_sensors(sensor_data)\n\n    # 2. State estimation (1-2ms)\n    robot_state = estimate_state(processed_data)\n\n    # 3. Balance control computation (2-5ms)\n    control_commands = compute_balance_control(robot_state)\n\n    # 4. Command execution (1ms)\n    send_commands(control_commands)\n\n    # Total: < 10ms for real-time performance\n'})}),"\n",(0,r.jsx)(n.h3,{id:"robustness-to-modeling-errors",children:"Robustness to Modeling Errors"}),"\n",(0,r.jsx)(n.p,{children:"Balance controllers must handle model inaccuracies:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-python",children:'def robust_balance_control(measured_state, model_state, control_input):\n    """Robust balance control with model error compensation"""\n    # Estimate model error\n    state_error = measured_state - model_state\n\n    # Adapt control gains based on error magnitude\n    if np.linalg.norm(state_error) > 0.1:  # High error threshold\n        # Increase robustness, decrease performance\n        adaptive_gains = decrease_gains(control_input.gains)\n    else:\n        # Use nominal gains\n        adaptive_gains = control_input.gains\n\n    return adaptive_gains\n'})}),"\n",(0,r.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,r.jsx)(n.p,{children:"Balance and stability control is fundamental to humanoid robot operation. The complex interplay between center of mass dynamics, support polygon constraints, and environmental interactions requires sophisticated control strategies. From basic PID controllers to advanced optimization-based approaches, balance systems must operate in real-time while handling modeling uncertainties and external disturbances."}),"\n",(0,r.jsx)(n.p,{children:"The next section will explore motor control systems that translate high-level balance and movement commands into precise actuator commands, completing the control hierarchy from high-level goals to physical execution."})]})}function p(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(d,{...e})}):d(e)}},8453:(e,n,o)=>{o.d(n,{R:()=>l,x:()=>s});var t=o(6540);const r={},a=t.createContext(r);function l(e){const n=t.useContext(a);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:l(e.components),t.createElement(a.Provider,{value:n},e.children)}}}]);