"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[714],{7e3:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>c,frontMatter:()=>i,metadata:()=>s,toc:()=>p});const s=JSON.parse('{"id":"module-4-locomotion-mobility/terrain-adaptation","title":"Terrain Adaptation and Footstep Planning","description":"Introduction: Navigating Complex Environments","source":"@site/docs/module-4-locomotion-mobility/terrain-adaptation.md","sourceDirName":"module-4-locomotion-mobility","slug":"/module-4-locomotion-mobility/terrain-adaptation","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/terrain-adaptation","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-locomotion-mobility/terrain-adaptation.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Gait Generation and Pattern Formation","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/gait-generation"},"next":{"title":"Stair Climbing and Complex Terrain Navigation","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/complex-terrain"}}');var a=t(4848),r=t(8453);const i={},o="Terrain Adaptation and Footstep Planning",l={},p=[{value:"Introduction: Navigating Complex Environments",id:"introduction-navigating-complex-environments",level:2},{value:"The Challenge of Terrain Adaptation",id:"the-challenge-of-terrain-adaptation",level:3},{value:"Terrain Perception and Classification",id:"terrain-perception-and-classification",level:2},{value:"3D Terrain Mapping",id:"3d-terrain-mapping",level:3},{value:"Obstacle Detection and Classification",id:"obstacle-detection-and-classification",level:3},{value:"Footstep Planning Algorithms",id:"footstep-planning-algorithms",level:2},{value:"A* Footstep Planner",id:"a-footstep-planner",level:3},{value:"Dynamic Footstep Adjustment",id:"dynamic-footstep-adjustment",level:3},{value:"Stair and Step Negotiation",id:"stair-and-step-negotiation",level:2},{value:"Stair Detection and Negotiation Planning",id:"stair-detection-and-negotiation-planning",level:3},{value:"Rough Terrain Navigation",id:"rough-terrain-navigation",level:2},{value:"Compliance and Adaptation Strategies",id:"compliance-and-adaptation-strategies",level:3},{value:"Integration with Control Systems",id:"integration-with-control-systems",level:2},{value:"ROS 2 Integration for Terrain Adaptation",id:"ros-2-integration-for-terrain-adaptation",level:3},{value:"Performance Evaluation and Optimization",id:"performance-evaluation-and-optimization",level:2},{value:"Terrain Adaptation Metrics",id:"terrain-adaptation-metrics",level:3},{value:"Conclusion",id:"conclusion",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"terrain-adaptation-and-footstep-planning",children:"Terrain Adaptation and Footstep Planning"})}),"\n",(0,a.jsx)(n.h2,{id:"introduction-navigating-complex-environments",children:"Introduction: Navigating Complex Environments"}),"\n",(0,a.jsx)(n.p,{children:"Terrain adaptation is crucial for humanoid robots to operate effectively in real-world environments. Unlike structured indoor spaces, outdoor and human environments present diverse challenges including uneven surfaces, obstacles, slopes, stairs, and dynamic conditions. This section explores the algorithms and techniques that enable robots to perceive terrain, plan appropriate footstep sequences, and adapt their locomotion patterns in real-time."}),"\n",(0,a.jsx)(n.h3,{id:"the-challenge-of-terrain-adaptation",children:"The Challenge of Terrain Adaptation"}),"\n",(0,a.jsx)(n.p,{children:"Terrain adaptation involves multiple interconnected challenges:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Perception"}),": Understanding the 3D structure and properties of the terrain"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Planning"}),": Generating stable and efficient footstep sequences"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Control"}),": Adapting gait patterns to match terrain characteristics"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Real-time Response"}),": Reacting to unexpected terrain features"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"terrain-perception-and-classification",children:"Terrain Perception and Classification"}),"\n",(0,a.jsx)(n.h3,{id:"3d-terrain-mapping",children:"3D Terrain Mapping"}),"\n",(0,a.jsx)(n.p,{children:"Creating accurate representations of the terrain environment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.spatial import KDTree\nfrom sklearn.cluster import DBSCAN\n\nclass TerrainMapper:\n    def __init__(self, resolution=0.05, map_size=10.0):\n        self.resolution = resolution\n        self.map_size = map_size\n        self.grid_size = int(map_size / resolution)\n        self.terrain_map = np.full((self.grid_size, self.grid_size), np.nan)\n        self.height_map = np.full((self.grid_size, self.grid_size), np.nan)\n        self.normal_map = np.full((self.grid_size, self.grid_size, 3), np.nan)\n        self.roughness_map = np.full((self.grid_size, self.grid_size), 0.0)\n        self.traversability_map = np.ones((self.grid_size, self.grid_size))  # 1 = traversable, 0 = not\n\n    def world_to_grid(self, x, y):\n        \"\"\"Convert world coordinates to grid coordinates\"\"\"\n        grid_x = int((x + self.map_size/2) / self.resolution)\n        grid_y = int((y + self.map_size/2) / self.resolution)\n        return grid_x, grid_y\n\n    def grid_to_world(self, grid_x, grid_y):\n        \"\"\"Convert grid coordinates to world coordinates\"\"\"\n        x = grid_x * self.resolution - self.map_size/2\n        y = grid_y * self.resolution - self.map_size/2\n        return x, y\n\n    def update_with_point_cloud(self, points, colors=None):\n        \"\"\"Update terrain map with new point cloud data\"\"\"\n        for point in points:\n            x, y, z = point\n            grid_x, grid_y = self.world_to_grid(x, y)\n\n            if 0 <= grid_x < self.grid_size and 0 <= grid_y < self.grid_size:\n                # Update height map\n                if np.isnan(self.height_map[grid_x, grid_y]):\n                    self.height_map[grid_x, grid_y] = z\n                else:\n                    # Average multiple measurements\n                    self.height_map[grid_x, grid_y] = 0.7 * self.height_map[grid_x, grid_y] + 0.3 * z\n\n        # Calculate terrain properties\n        self.calculate_terrain_properties()\n\n    def calculate_terrain_properties(self):\n        \"\"\"Calculate terrain properties like slope, roughness, etc.\"\"\"\n        for i in range(1, self.grid_size - 1):\n            for j in range(1, self.grid_size - 1):\n                if not np.isnan(self.height_map[i, j]):\n                    # Calculate local slope (normal vector)\n                    neighbors = [\n                        self.height_map[i-1, j],\n                        self.height_map[i+1, j],\n                        self.height_map[i, j-1],\n                        self.height_map[i, j+1]\n                    ]\n\n                    valid_neighbors = [h for h in neighbors if not np.isnan(h)]\n                    if len(valid_neighbors) >= 3:\n                        # Calculate gradients\n                        dz_dx = (self.height_map[i+1, j] - self.height_map[i-1, j]) / (2 * self.resolution)\n                        dz_dy = (self.height_map[i, j+1] - self.height_map[i, j-1]) / (2 * self.resolution)\n\n                        # Normal vector (pointing upward)\n                        normal = np.array([-dz_dx, -dz_dy, 1.0])\n                        normal = normal / np.linalg.norm(normal)\n                        self.normal_map[i, j] = normal\n\n                        # Calculate roughness (local height variance)\n                        height_values = [self.height_map[i+di, j+dj]\n                                       for di in [-1,0,1] for dj in [-1,0,1]\n                                       if 0 <= i+di < self.grid_size and 0 <= j+dj < self.grid_size\n                                       and not np.isnan(self.height_map[i+di, j+dj])]\n\n                        if len(height_values) > 1:\n                            self.roughness_map[i, j] = np.std(height_values)\n\n    def classify_terrain_type(self, x, y):\n        \"\"\"Classify terrain type at given location\"\"\"\n        grid_x, grid_y = self.world_to_grid(x, y)\n\n        if not (0 <= grid_x < self.grid_size and 0 <= grid_y < self.grid_size):\n            return 'unknown'\n\n        height = self.height_map[grid_x, grid_y]\n        if np.isnan(height):\n            return 'unknown'\n\n        # Calculate local properties\n        slope = np.arccos(self.normal_map[grid_x, grid_y, 2]) if not np.isnan(self.normal_map[grid_x, grid_y, 2]) else 0\n        roughness = self.roughness_map[grid_x, grid_y]\n\n        # Classify based on properties\n        if slope > np.radians(30):  # Very steep\n            return 'steep_slope'\n        elif slope > np.radians(15):  # Moderate slope\n            return 'slope'\n        elif roughness > 0.05:  # Rough terrain\n            return 'rough'\n        elif roughness > 0.02:  # Slightly rough\n            return 'uneven'\n        else:\n            return 'flat'\n\n    def get_traversability_cost(self, x, y, robot_params=None):\n        \"\"\"Get traversability cost for given location\"\"\"\n        if robot_params is None:\n            robot_params = {'max_step_height': 0.1, 'max_slope': np.radians(20)}\n\n        grid_x, grid_y = self.world_to_grid(x, y)\n\n        if not (0 <= grid_x < self.grid_size and 0 <= grid_y < self.grid_size):\n            return float('inf')  # Outside map\n\n        # Check if point is valid\n        if np.isnan(self.height_map[grid_x, grid_y]):\n            return float('inf')  # No data\n\n        # Calculate local slope\n        slope = np.arccos(self.normal_map[grid_x, grid_y, 2]) if not np.isnan(self.normal_map[grid_x, grid_y, 2]) else 0\n        roughness = self.roughness_map[grid_x, grid_y]\n\n        # Calculate cost based on terrain properties\n        cost = 1.0  # Base cost\n\n        # Slope cost\n        if slope > robot_params['max_slope']:\n            cost += 10.0  # High penalty for steep slopes\n        else:\n            cost += slope / robot_params['max_slope'] * 2.0  # Graduated penalty\n\n        # Roughness cost\n        cost += roughness * 10.0\n\n        return cost\n\n    def visualize_terrain(self):\n        \"\"\"Visualize the terrain map\"\"\"\n        fig, axes = plt.subplots(2, 2, figsize=(15, 12))\n\n        # Height map\n        im1 = axes[0, 0].imshow(self.height_map, cmap='terrain', origin='lower',\n                               extent=[-self.map_size/2, self.map_size/2,\n                                     -self.map_size/2, self.map_size/2])\n        axes[0, 0].set_title('Height Map')\n        axes[0, 0].set_xlabel('X (m)')\n        axes[0, 0].set_ylabel('Y (m)')\n        plt.colorbar(im1, ax=axes[0, 0])\n\n        # Slope map (from normal vectors)\n        slope_map = np.zeros((self.grid_size, self.grid_size))\n        for i in range(self.grid_size):\n            for j in range(self.grid_size):\n                if not np.isnan(self.normal_map[i, j, 2]):\n                    slope_map[i, j] = np.arccos(self.normal_map[i, j, 2])\n\n        im2 = axes[0, 1].imshow(slope_map, cmap='hot', origin='lower',\n                               extent=[-self.map_size/2, self.map_size/2,\n                                     -self.map_size/2, self.map_size/2])\n        axes[0, 1].set_title('Slope Map (radians)')\n        axes[0, 1].set_xlabel('X (m)')\n        axes[0, 1].set_ylabel('Y (m)')\n        plt.colorbar(im2, ax=axes[0, 1])\n\n        # Roughness map\n        im3 = axes[1, 0].imshow(self.roughness_map, cmap='viridis', origin='lower',\n                               extent=[-self.map_size/2, self.map_size/2,\n                                     -self.map_size/2, self.map_size/2])\n        axes[1, 0].set_title('Roughness Map')\n        axes[1, 0].set_xlabel('X (m)')\n        axes[1, 0].set_ylabel('Y (m)')\n        plt.colorbar(im3, ax=axes[1, 0])\n\n        # Traversability map\n        im4 = axes[1, 1].imshow(self.traversability_map, cmap='RdYlGn_r', origin='lower',\n                               extent=[-self.map_size/2, self.map_size/2,\n                                     -self.map_size/2, self.map_size/2])\n        axes[1, 1].set_title('Traversability Map')\n        axes[1, 1].set_xlabel('X (m)')\n        axes[1, 1].set_ylabel('Y (m)')\n        plt.colorbar(im4, ax=axes[1, 1])\n\n        plt.tight_layout()\n        plt.show()\n\n# Example: Create and update terrain map\nterrain_mapper = TerrainMapper(resolution=0.1, map_size=5.0)\n\n# Generate sample terrain with different features\nnp.random.seed(42)\nx = np.linspace(-2, 2, 100)\ny = np.linspace(-2, 2, 100)\nX, Y = np.meshgrid(x, y)\n\n# Create terrain with flat area, slope, and rough patch\nZ = np.zeros_like(X)\nZ[X > 0.5] = 0.1  # Small step\nZ[(X > -0.5) & (X < 0.5) & (Y > 0.5)] = 0.2  # Raised platform\nZ[(X > -1) & (X < 0) & (Y > -1) & (Y < 0)] += 0.1 * np.random.random((50, 50))[:50, :50]  # Rough patch\n\n# Add a slope\nZ += 0.3 * X  # Gentle slope\n\n# Flatten the terrain for point cloud generation\npoints = []\nfor i in range(X.shape[0]):\n    for j in range(X.shape[1]):\n        points.append([X[i, j], Y[i, j], Z[i, j]])\n\nterrain_mapper.update_with_point_cloud(points)\n\n# Classify terrain at specific points\ntest_points = [(0, 0), (1, 0), (-0.5, 0.75), (-0.5, -0.5)]\nfor x, y in test_points:\n    terrain_type = terrain_mapper.classify_terrain_type(x, y)\n    cost = terrain_mapper.get_traversability_cost(x, y)\n    print(f\"Point ({x}, {y}): {terrain_type}, cost = {cost:.2f}\")\n\n# terrain_mapper.visualize_terrain()  # Uncomment to visualize\n"})}),"\n",(0,a.jsx)(n.h3,{id:"obstacle-detection-and-classification",children:"Obstacle Detection and Classification"}),"\n",(0,a.jsx)(n.p,{children:"Identifying and categorizing obstacles in the environment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class ObstacleDetector:\n    def __init__(self, min_obstacle_height=0.1, max_obstacle_height=1.0):\n        self.min_obstacle_height = min_obstacle_height\n        self.max_obstacle_height = max_obstacle_height\n        self.obstacles = []\n        self.ground_level = 0.0\n\n    def detect_obstacles(self, point_cloud, ground_level=0.0):\n        \"\"\"Detect obstacles from point cloud data\"\"\"\n        self.ground_level = ground_level\n        self.obstacles = []\n\n        # Group points that are close together (using DBSCAN clustering)\n        clustering = DBSCAN(eps=0.2, min_samples=10).fit(point_cloud)\n        labels = clustering.labels_\n\n        for label in set(labels):\n            if label == -1:  # Noise points\n                continue\n\n            # Get points in this cluster\n            cluster_points = point_cloud[labels == label]\n\n            # Calculate cluster properties\n            center = np.mean(cluster_points, axis=0)\n            bbox_min = np.min(cluster_points, axis=0)\n            bbox_max = np.max(cluster_points, axis=0)\n            dimensions = bbox_max - bbox_min\n\n            # Check if it's a valid obstacle (above ground and within height limits)\n            if (bbox_min[2] > ground_level + self.min_obstacle_height and\n                bbox_max[2] < ground_level + self.max_obstacle_height and\n                len(cluster_points) > 20):  # Minimum size threshold\n\n                obstacle = {\n                    'center': center,\n                    'bbox_min': bbox_min,\n                    'bbox_max': bbox_max,\n                    'dimensions': dimensions,\n                    'points': cluster_points,\n                    'type': self.classify_obstacle_type(dimensions),\n                    'passable': self.is_obstacle_passable(dimensions)\n                }\n\n                self.obstacles.append(obstacle)\n\n        return self.obstacles\n\n    def classify_obstacle_type(self, dimensions):\n        \"\"\"Classify obstacle type based on dimensions\"\"\"\n        height = dimensions[2]\n        width = dimensions[0]\n        length = dimensions[1]\n\n        if height < 0.1:  # Low obstacle\n            if width < 0.2 and length < 0.2:\n                return 'small_object'\n            else:\n                return 'step'\n        elif height < 0.3:  # Medium obstacle\n            return 'curb'\n        elif height < 0.8:  # High obstacle\n            return 'barrier'\n        else:  # Very high obstacle\n            return 'wall'\n\n    def is_obstacle_passable(self, dimensions):\n        \"\"\"Determine if obstacle is passable by stepping over\"\"\"\n        height = dimensions[2]\n\n        # For humanoid robot, passable obstacles are typically < 15cm high\n        return height < 0.15\n\n    def get_obstacle_traversability(self, robot_params=None):\n        \"\"\"Get traversability information for each obstacle\"\"\"\n        if robot_params is None:\n            robot_params = {\n                'leg_length': 0.9,\n                'max_step_height': 0.15,\n                'robot_width': 0.3\n            }\n\n        traversability_info = []\n        for obstacle in self.obstacles:\n            info = {\n                'obstacle': obstacle,\n                'can_step_over': obstacle['dimensions'][2] <= robot_params['max_step_height'],\n                'can_walk_around': True,  # Assume walk-around is possible\n                'navigation_strategy': self.determine_navigation_strategy(obstacle, robot_params)\n            }\n            traversability_info.append(info)\n\n        return traversability_info\n\n    def determine_navigation_strategy(self, obstacle, robot_params):\n        \"\"\"Determine best navigation strategy for obstacle\"\"\"\n        height = obstacle['dimensions'][2]\n\n        if height <= robot_params['max_step_height']:\n            return 'step_over'\n        elif height <= 0.4:  # Crawlable height\n            return 'step_approach'  # Approach and step up\n        else:\n            return 'go_around'  # Navigate around obstacle\n\n    def get_clear_path_around_obstacles(self, start, goal, robot_radius=0.2):\n        \"\"\"Get path that avoids obstacles\"\"\"\n        # This would implement path planning around obstacles\n        # For this example, return a simple path\n        return [start, goal]  # Placeholder\n\n# Example: Obstacle detection\nobstacle_detector = ObstacleDetector()\n\n# Create sample point cloud with obstacles\nsample_points = []\n# Ground plane\nfor i in range(20):\n    for j in range(20):\n        sample_points.append([i*0.2 - 2, j*0.2 - 2, 0.0])\n\n# Add some obstacles\n# Small box\nfor i in range(3):\n    for j in range(3):\n        for k in range(5):\n            sample_points.append([-0.5 + i*0.1, 0.5 + j*0.1, k*0.02])\n\n# Step\nfor i in range(10):\n    for j in range(3):\n        sample_points.append([0.5 + i*0.1, -0.5 + j*0.1, 0.1 if i > 5 else 0.0])\n\npoint_cloud = np.array(sample_points)\n\n# Detect obstacles\nobstacles = obstacle_detector.detect_obstacles(point_cloud, ground_level=0.0)\nprint(f\"Detected {len(obstacles)} obstacles\")\n\nfor i, obstacle in enumerate(obstacles):\n    print(f\"Obstacle {i+1}: {obstacle['type']}, dimensions = {obstacle['dimensions']}, \"\n          f\"passable = {obstacle['passable']}\")\n"})}),"\n",(0,a.jsx)(n.h2,{id:"footstep-planning-algorithms",children:"Footstep Planning Algorithms"}),"\n",(0,a.jsx)(n.h3,{id:"a-footstep-planner",children:"A* Footstep Planner"}),"\n",(0,a.jsx)(n.p,{children:"Planning optimal footstep sequences using A* algorithm:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import heapq\n\nclass FootstepPlanner:\n    def __init__(self, terrain_mapper, step_limits=None):\n        self.terrain_mapper = terrain_mapper\n        if step_limits is None:\n            step_limits = {\n                'max_forward': 0.3,    # Maximum forward step\n                'max_lateral': 0.2,    # Maximum lateral step\n                'max_rotation': np.pi/4,  # Maximum rotation\n                'min_forward': 0.05    # Minimum forward step\n            }\n        self.step_limits = step_limits\n        self.robot_foot_size = 0.15  # Foot size for collision checking\n\n    def heuristic(self, pos1, pos2):\n        \"\"\"Heuristic function for A* (Euclidean distance)\"\"\"\n        return np.sqrt((pos1[0] - pos2[0])**2 + (pos1[1] - pos2[1])**2)\n\n    def get_neighbors(self, current_pos, current_yaw):\n        \"\"\"Get possible next footstep positions\"\"\"\n        neighbors = []\n\n        # Generate possible step locations\n        step_configs = [\n            # Forward steps\n            (self.step_limits['max_forward'], 0, 0),  # Forward\n            (self.step_limits['max_forward']*0.7, 0, 0),  # Shorter forward\n            (self.step_limits['max_forward']*0.5, 0, 0),  # Even shorter\n\n            # Lateral steps\n            (0, self.step_limits['max_lateral'], 0),  # Left\n            (0, -self.step_limits['max_lateral'], 0),  # Right\n            (0, self.step_limits['max_lateral']*0.5, 0),  # Small left\n            (0, -self.step_limits['max_lateral']*0.5, 0),  # Small right\n\n            # Diagonal steps\n            (self.step_limits['max_forward']*0.7, self.step_limits['max_lateral']*0.5, 0),  # Forward-left\n            (self.step_limits['max_forward']*0.7, -self.step_limits['max_lateral']*0.5, 0),  # Forward-right\n\n            # Rotational steps\n            (0, 0, self.step_limits['max_rotation']),  # Rotate left\n            (0, 0, -self.step_limits['max_rotation']),  # Rotate right\n        ]\n\n        for dx, dy, dtheta in step_configs:\n            # Transform step to world coordinates based on current orientation\n            world_dx = dx * np.cos(current_yaw) - dy * np.sin(current_yaw)\n            world_dy = dx * np.sin(current_yaw) + dy * np.cos(current_yaw)\n\n            new_x = current_pos[0] + world_dx\n            new_y = current_pos[1] + world_dy\n            new_yaw = current_yaw + dtheta\n\n            # Keep yaw in [-\u03c0, \u03c0]\n            new_yaw = np.arctan2(np.sin(new_yaw), np.cos(new_yaw))\n\n            neighbors.append(((new_x, new_y), new_yaw))\n\n        return neighbors\n\n    def is_valid_footstep(self, pos, yaw):\n        \"\"\"Check if footstep is valid (not in collision, stable, etc.)\"\"\"\n        x, y = pos\n\n        # Check terrain traversability\n        cost = self.terrain_mapper.get_traversability_cost(x, y)\n        if cost == float('inf'):\n            return False\n\n        # Check slope stability (too steep)\n        grid_x, grid_y = self.terrain_mapper.world_to_grid(x, y)\n        if (0 <= grid_x < self.terrain_mapper.grid_size and\n            0 <= grid_y < self.terrain_mapper.grid_size):\n            if not np.isnan(self.terrain_mapper.normal_map[grid_x, grid_y, 2]):\n                slope = np.arccos(self.terrain_mapper.normal_map[grid_x, grid_y, 2])\n                if slope > np.radians(30):  # Too steep\n                    return False\n\n        return True\n\n    def plan_footsteps(self, start_pos, start_yaw, goal_pos, max_steps=50):\n        \"\"\"Plan sequence of footsteps from start to goal\"\"\"\n        # A* algorithm for footstep planning\n        open_set = [(0, (start_pos, start_yaw, []))]  # (f_score, (pos, yaw, path))\n        closed_set = set()\n\n        step_count = 0\n        while open_set and step_count < max_steps:\n            current_f, (current_pos, current_yaw, current_path) = heapq.heappop(open_set)\n\n            # Check if we're close to goal\n            if np.sqrt((current_pos[0] - goal_pos[0])**2 + (current_pos[1] - goal_pos[1])**2) < 0.2:\n                return current_path + [(current_pos, current_yaw)]\n\n            # Add current state to closed set\n            state_key = (int(current_pos[0]/0.1), int(current_pos[1]/0.1), int(current_yaw/0.1))\n            if state_key in closed_set:\n                continue\n            closed_set.add(state_key)\n\n            # Get possible next steps\n            neighbors = self.get_neighbors(current_pos, current_yaw)\n            for next_pos, next_yaw in neighbors:\n                if not self.is_valid_footstep(next_pos, next_yaw):\n                    continue\n\n                # Calculate cost\n                g_score = len(current_path) + 1  # Step count cost\n                h_score = self.heuristic(next_pos, goal_pos)  # Distance to goal\n                f_score = g_score + h_score\n\n                # Add to open set\n                new_path = current_path + [(current_pos, current_yaw)]\n                heapq.heappush(open_set, (f_score, (next_pos, next_yaw, new_path)))\n\n            step_count += 1\n\n        return None  # No path found\n\n    def plan_alternating_feet(self, start_left, start_right, goal_pos, num_steps=10):\n        \"\"\"Plan footsteps alternating between left and right feet\"\"\"\n        footsteps = []\n\n        # Start with left foot\n        current_left = start_left[:2]\n        current_left_yaw = start_left[2] if len(start_left) > 2 else 0\n        current_right = start_right[:2]\n        current_right_yaw = start_right[2] if len(start_right) > 2 else 0\n\n        # Plan steps alternating feet\n        for i in range(num_steps):\n            if i % 2 == 0:  # Left foot step\n                # Plan to move left foot toward goal\n                goal_for_left = (\n                    goal_pos[0] - 0.1 + 0.2 * (i / num_steps),  # Adjust for alternating pattern\n                    goal_pos[1] + (0.1 if i % 4 < 2 else -0.1)  # Slight lateral adjustment\n                )\n\n                path = self.plan_footsteps(current_left, current_left_yaw, goal_for_left, max_steps=5)\n                if path and len(path) > 1:\n                    current_left, current_left_yaw = path[1]  # Next step\n                    footsteps.append(('left', current_left[0], current_left[1], current_left_yaw))\n                else:\n                    # Fallback: simple forward step\n                    new_x = current_left[0] + 0.2 * np.cos(current_left_yaw)\n                    new_y = current_left[1] + 0.2 * np.sin(current_left_yaw)\n                    current_left = (new_x, new_y)\n                    footsteps.append(('left', new_x, new_y, current_left_yaw))\n            else:  # Right foot step\n                # Plan to move right foot toward goal\n                goal_for_right = (\n                    goal_pos[0] - 0.1 + 0.2 * (i / num_steps),\n                    goal_pos[1] + (0.1 if (i+1) % 4 < 2 else -0.1)\n                )\n\n                path = self.plan_footsteps(current_right, current_right_yaw, goal_for_right, max_steps=5)\n                if path and len(path) > 1:\n                    current_right, current_right_yaw = path[1]\n                    footsteps.append(('right', current_right[0], current_right[1], current_right_yaw))\n                else:\n                    # Fallback: simple forward step\n                    new_x = current_right[0] + 0.2 * np.cos(current_right_yaw)\n                    new_y = current_right[1] + 0.2 * np.sin(current_right_yaw)\n                    current_right = (new_x, new_y)\n                    footsteps.append(('right', new_x, new_y, current_right_yaw))\n\n        return footsteps\n\n# Example: Footstep planning\nfootstep_planner = FootstepPlanner(terrain_mapper)\n\n# Plan footsteps from start to goal\nstart_pos = (0.0, 0.0)\nstart_yaw = 0.0\ngoal_pos = (2.0, 0.0)\n\nfootsteps = footstep_planner.plan_alternating_feet(\n    (0.0, 0.1, 0.0),  # Start left foot\n    (0.0, -0.1, 0.0),  # Start right foot\n    goal_pos,\n    num_steps=8\n)\n\nprint(f\"Planned {len(footsteps)} footsteps:\")\nfor i, (foot, x, y, yaw) in enumerate(footsteps):\n    print(f\"  Step {i+1}: {foot} foot at ({x:.2f}, {y:.2f}), yaw={yaw:.2f}\")\n"})}),"\n",(0,a.jsx)(n.h3,{id:"dynamic-footstep-adjustment",children:"Dynamic Footstep Adjustment"}),"\n",(0,a.jsx)(n.p,{children:"Adapting footstep plans based on real-time perception:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class AdaptiveFootstepAdjuster:\n    def __init__(self, base_planner):\n        self.base_planner = base_planner\n        self.current_footsteps = []\n        self.executed_steps = []\n        self.adjustment_threshold = 0.05  # 5cm threshold for adjustment\n        self.lookahead_distance = 1.0  # Look ahead 1m\n\n    def update_terrain_map(self, new_point_cloud, robot_pos):\n        """Update terrain map with new sensor data"""\n        self.base_planner.terrain_mapper.update_with_point_cloud(new_point_cloud)\n\n    def detect_terrain_changes(self, current_pos, current_yaw):\n        """Detect changes in terrain that require footstep adjustment"""\n        changes_detected = []\n\n        # Check upcoming footsteps against new terrain data\n        for i, (foot, x, y, yaw) in enumerate(self.current_footsteps):\n            if i < len(self.executed_steps):  # Already executed\n                continue\n\n            # Calculate expected terrain properties at foot position\n            expected_cost = self.base_planner.terrain_mapper.get_traversability_cost(x, y)\n\n            # Check if terrain has changed significantly\n            # This would involve comparing with updated map\n            if expected_cost > 5.0:  # High cost terrain detected\n                changes_detected.append({\n                    \'step_index\': i,\n                    \'position\': (x, y),\n                    \'current_cost\': expected_cost,\n                    \'adjustment_needed\': True\n                })\n\n        return changes_detected\n\n    def adjust_footsteps(self, detected_changes, robot_pos, robot_yaw):\n        """Adjust footstep plan based on detected changes"""\n        adjusted_footsteps = self.current_footsteps.copy()\n\n        for change in detected_changes:\n            step_idx = change[\'step_index\']\n            if step_idx >= len(adjusted_footsteps):\n                continue\n\n            original_foot, orig_x, orig_y, orig_yaw = adjusted_footsteps[step_idx]\n\n            # Find alternative footstep location\n            alternative_pos = self.find_alternative_footstep(\n                (orig_x, orig_y), robot_pos, robot_yaw\n            )\n\n            if alternative_pos:\n                adjusted_footsteps[step_idx] = (\n                    original_foot, alternative_pos[0], alternative_pos[1], orig_yaw\n                )\n\n        return adjusted_footsteps\n\n    def find_alternative_footstep(self, original_pos, robot_pos, robot_yaw):\n        """Find alternative footstep location near original"""\n        x, y = original_pos\n\n        # Search in a local area around the original position\n        search_radius = 0.3  # 30cm search radius\n        search_resolution = 0.05  # 5cm resolution\n\n        best_pos = None\n        best_cost = float(\'inf\')\n\n        for dx in np.arange(-search_radius, search_radius, search_resolution):\n            for dy in np.arange(-search_radius, search_radius, search_resolution):\n                test_x = x + dx\n                test_y = y + dy\n\n                # Check if this position is valid\n                if self.base_planner.is_valid_footstep((test_x, test_y), robot_yaw):\n                    cost = self.base_planner.terrain_mapper.get_traversability_cost(test_x, test_y)\n                    # Add distance penalty to stay close to original\n                    distance_penalty = np.sqrt(dx**2 + dy**2) * 2.0\n                    total_cost = cost + distance_penalty\n\n                    if total_cost < best_cost:\n                        best_cost = total_cost\n                        best_pos = (test_x, test_y)\n\n        return best_pos\n\n    def replan_around_obstacle(self, obstacle_pos, robot_pos, goal_pos):\n        """Replan footsteps to go around an obstacle"""\n        # This would implement local replanning around detected obstacles\n        # For this example, we\'ll return a simple detour\n        detour_offset = 0.3  # 30cm detour\n\n        # Calculate detour direction (perpendicular to obstacle-robot vector)\n        to_obstacle = np.array(obstacle_pos[:2]) - np.array(robot_pos[:2])\n        detour_direction = np.array([-to_obstacle[1], to_obstacle[0]])  # Perpendicular\n        detour_direction = detour_direction / np.linalg.norm(detour_direction)\n\n        # New path goes around obstacle\n        detour_point = np.array(obstacle_pos[:2]) + detour_direction * detour_offset\n        return [(robot_pos[0], robot_pos[1]), detour_point, goal_pos]\n\n    def execute_step_and_update(self, step_index, robot_pos, robot_yaw, sensor_data=None):\n        """Execute a step and update plan based on new information"""\n        if sensor_data:\n            # Update terrain map with new sensor data\n            self.update_terrain_map(sensor_data[\'point_cloud\'], robot_pos)\n\n        # Add executed step to history\n        if step_index < len(self.current_footsteps):\n            self.executed_steps.append(self.current_footsteps[step_index])\n\n        # Check for terrain changes that require adjustment\n        changes = self.detect_terrain_changes(robot_pos, robot_yaw)\n\n        if changes:\n            print(f"Detected {len(changes)} terrain changes, adjusting plan...")\n            self.current_footsteps = self.adjust_footsteps(changes, robot_pos, robot_yaw)\n\n        return self.current_footsteps\n\n# Example: Adaptive footstep adjustment\nadaptive_adjuster = AdaptiveFootstepAdjuster(footstep_planner)\n\n# Set initial plan\nadaptive_adjuster.current_footsteps = footsteps\n\n# Simulate execution with some terrain changes\nrobot_pos = (0.0, 0.0, 0.85)  # x, y, z\nrobot_yaw = 0.0\n\nfor step_idx in range(min(3, len(footsteps))):  # Execute first 3 steps\n    print(f"Executing step {step_idx + 1}")\n\n    # Simulate sensor data (in real system, this would come from sensors)\n    sensor_data = {\n        \'point_cloud\': np.array([[robot_pos[0] + 0.1, robot_pos[1], robot_pos[2] - 0.85],\n                                [robot_pos[0] + 0.2, robot_pos[1], robot_pos[2] - 0.85]])\n    }\n\n    # Execute step and update\n    updated_plan = adaptive_adjuster.execute_step_and_update(\n        step_idx, robot_pos, robot_yaw, sensor_data\n    )\n\n    # Update robot position (simplified)\n    if step_idx < len(updated_plan):\n        foot, x, y, yaw = updated_plan[step_idx]\n        robot_pos = (x, y, robot_pos[2])\n        robot_yaw = yaw\n\n    print(f"Remaining footsteps: {len(updated_plan) - step_idx - 1}")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"stair-and-step-negotiation",children:"Stair and Step Negotiation"}),"\n",(0,a.jsx)(n.h3,{id:"stair-detection-and-negotiation-planning",children:"Stair Detection and Negotiation Planning"}),"\n",(0,a.jsx)(n.p,{children:"Handling stairs and discrete height changes:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class StairNegotiationPlanner:\n    def __init__(self):\n        self.stair_parameters = {\n            'typical_rise': 0.17,    # 17cm typical stair rise\n            'typical_run': 0.28,    # 28cm typical stair run\n            'max_rise': 0.25,       # Maximum safe rise\n            'min_run': 0.15,        # Minimum safe run\n            'nose_depth': 0.03      # Tread nose depth\n        }\n        self.stairs_detected = []\n        self.current_step = 0\n\n    def detect_stairs_from_point_cloud(self, point_cloud, ground_level=0.0):\n        \"\"\"Detect stairs from point cloud data\"\"\"\n        self.stairs_detected = []\n\n        # Group points by height to identify discrete levels\n        z_values = point_cloud[:, 2]\n        unique_heights = np.unique(np.round(z_values, decimals=2))\n\n        # Look for regular height intervals (stair pattern)\n        possible_rise_values = []\n        for i in range(len(unique_heights)):\n            for j in range(i + 1, len(unique_heights)):\n                rise = unique_heights[j] - unique_heights[i]\n                if self.stair_parameters['min_run'] < rise < self.stair_parameters['max_rise']:\n                    possible_rise_values.append(rise)\n\n        # Find the most common rise value (likely stair height)\n        if possible_rise_values:\n            unique_rises, counts = np.unique(possible_rise_values, return_counts=True)\n            most_common_rise = unique_rises[np.argmax(counts)]\n\n            # Identify stair locations based on this rise\n            stair_heights = []\n            for height in unique_heights:\n                if any(abs(height - h - most_common_rise) < 0.02 for h in stair_heights) or len(stair_heights) == 0:\n                    stair_heights.append(height)\n\n            # Create stair structure\n            if len(stair_heights) > 1:\n                stair_heights = sorted(stair_heights)\n                for i in range(len(stair_heights)):\n                    self.stairs_detected.append({\n                        'step_number': i,\n                        'height': stair_heights[i],\n                        'rise': most_common_rise if i > 0 else 0,\n                        'tread_points': point_cloud[abs(point_cloud[:, 2] - stair_heights[i]) < 0.02]\n                    })\n\n        return self.stairs_detected\n\n    def plan_stair_ascent(self, start_pos, num_steps):\n        \"\"\"Plan footstep sequence for stair ascent\"\"\"\n        footsteps = []\n        current_x, current_y = start_pos\n\n        for i in range(num_steps):\n            # Left foot on step i\n            left_x = current_x + i * self.stair_parameters['typical_run']\n            left_y = current_y + (0.1 if i % 2 == 0 else -0.1)  # Alternate lateral position\n            left_z = self.stair_parameters['typical_rise'] * (i + 1)\n            footsteps.append(('left', left_x, left_y, left_z, 0.0))\n\n            # Right foot on step i (if not the last step)\n            if i < num_steps - 1:\n                right_x = current_x + i * self.stair_parameters['typical_run']\n                right_y = current_y + (-0.1 if i % 2 == 0 else 0.1)\n                right_z = self.stair_parameters['typical_rise'] * (i + 1)\n                footsteps.append(('right', right_x, right_y, right_z, 0.0))\n\n        return footsteps\n\n    def plan_stair_descent(self, start_pos, num_steps):\n        \"\"\"Plan footstep sequence for stair descent\"\"\"\n        footsteps = []\n        current_x, current_y = start_pos\n\n        # Start from top of stairs\n        start_z = self.stair_parameters['typical_rise'] * num_steps\n\n        for i in range(num_steps):\n            step_level = num_steps - i - 1  # Descending\n            step_z = self.stair_parameters['typical_rise'] * step_level\n\n            # Left foot on step\n            left_x = current_x + i * self.stair_parameters['typical_run']\n            left_y = current_y + (0.1 if i % 2 == 0 else -0.1)\n            footsteps.append(('left', left_x, left_y, step_z, 0.0))\n\n            # Right foot on same step\n            right_x = current_x + i * self.stair_parameters['typical_run']\n            right_y = current_y + (-0.1 if i % 2 == 0 else 0.1)\n            footsteps.append(('right', right_x, right_y, step_z, 0.0))\n\n        return footsteps\n\n    def validate_stair_footstep(self, foot_pos, stair_info):\n        \"\"\"Validate if footstep is safe on stairs\"\"\"\n        x, y, z = foot_pos\n        step_height = stair_info['height']\n\n        # Check if foot is properly positioned on step\n        height_error = abs(z - step_height)\n        if height_error > 0.05:  # 5cm tolerance\n            return False, f\"Height error: {height_error:.3f}m\"\n\n        # Check if foot is within step boundaries\n        # This would require more detailed step geometry\n        return True, \"Valid\"\n\n    def generate_stair_negotiation_pattern(self, stair_sequence, direction='up'):\n        \"\"\"Generate complete stair negotiation pattern\"\"\"\n        pattern = {\n            'approach': self.plan_approach_to_stairs(stair_sequence[0] if stair_sequence else None),\n            'ascent': self.plan_stair_ascent_pattern(stair_sequence, direction),\n            'departure': self.plan_departure_from_stairs(stair_sequence[-1] if stair_sequence else None)\n        }\n        return pattern\n\n    def plan_approach_to_stairs(self, first_step_info):\n        \"\"\"Plan approach steps before reaching stairs\"\"\"\n        if not first_step_info:\n            return []\n\n        approach_steps = []\n        # Plan 2-3 approach steps leading to first stair\n        for i in range(3):\n            x = -0.3 * (3 - i)  # Approach from -0.9m\n            y = 0.0\n            z = 0.0  # Ground level\n            approach_steps.append(('left' if i % 2 == 0 else 'right', x, y, z, 0.0))\n\n        return approach_steps\n\n    def plan_departure_from_stairs(self, last_step_info):\n        \"\"\"Plan departure steps after leaving stairs\"\"\"\n        if not last_step_info:\n            return []\n\n        departure_steps = []\n        # Plan 2-3 departure steps after last stair\n        last_x = last_step_info.get('tread_points', np.array([[0, 0, 0]]))[-1, 0] if 'tread_points' in last_step_info else 0\n\n        for i in range(3):\n            x = last_x + 0.3 * (i + 1)\n            y = 0.0\n            z = last_step_info['height'] if 'height' in last_step_info else 0.0\n            departure_steps.append(('left' if i % 2 == 0 else 'right', x, y, z, 0.0))\n\n        return departure_steps\n\n    def plan_stair_ascent_pattern(self, stair_sequence, direction):\n        \"\"\"Plan the actual stair negotiation pattern\"\"\"\n        if direction == 'up':\n            return self.plan_stair_ascent((0, 0), len(stair_sequence))\n        else:\n            return self.plan_stair_descent((0, 0), len(stair_sequence))\n\n# Example: Stair negotiation\nstair_planner = StairNegotiationPlanner()\n\n# Create sample stair point cloud\nstair_points = []\nfor step in range(5):  # 5 steps\n    z_height = step * 0.17  # 17cm rise per step\n    for x in np.arange(0, 0.3, 0.02):  # 30cm run\n        for y in np.arange(-0.1, 0.1, 0.02):  # 20cm width\n            stair_points.append([x + step * 0.3, y, z_height])\n\nstair_point_cloud = np.array(stair_points)\n\n# Detect stairs\ndetected_stairs = stair_planner.detect_stairs_from_point_cloud(stair_point_cloud, ground_level=0.0)\nprint(f\"Detected {len(detected_stairs)} stairs\")\n\n# Plan stair ascent\nascent_plan = stair_planner.plan_stair_ascent((0, 0), len(detected_stairs))\nprint(f\"Stair ascent plan: {len(ascent_plan)} footsteps\")\n\nfor i, (foot, x, y, z, yaw) in enumerate(ascent_plan[:6]):  # Show first 6 steps\n    print(f\"  Step {i+1}: {foot} foot at ({x:.2f}, {y:.2f}, {z:.2f})\")\n"})}),"\n",(0,a.jsx)(n.h2,{id:"rough-terrain-navigation",children:"Rough Terrain Navigation"}),"\n",(0,a.jsx)(n.h3,{id:"compliance-and-adaptation-strategies",children:"Compliance and Adaptation Strategies"}),"\n",(0,a.jsx)(n.p,{children:"Handling uneven and compliant surfaces:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class RoughTerrainNavigator:\n    def __init__(self):\n        self.foot_compliance = 0.02  # 2cm foot compliance for uneven surfaces\n        self.adaptation_speed = 1.0  # Adaptation rate\n        self.step_height_modulation = True\n        self.ankle_adaptation = True\n\n    def analyze_terrain_roughness(self, terrain_map, position, radius=0.2):\n        """Analyze local terrain roughness around position"""\n        x, y = position\n        grid_x, grid_y = terrain_map.world_to_grid(x, y)\n\n        # Get local neighborhood\n        neighborhood_size = int(radius / terrain_map.resolution)\n        roughness_values = []\n\n        for i in range(-neighborhood_size, neighborhood_size + 1):\n            for j in range(-neighborhood_size, neighborhood_size + 1):\n                nx, ny = grid_x + i, grid_y + j\n                if (0 <= nx < terrain_map.grid_size and\n                    0 <= ny < terrain_map.grid_size and\n                    not np.isnan(terrain_map.height_map[nx, ny])):\n                    roughness_values.append(terrain_map.roughness_map[nx, ny])\n\n        if roughness_values:\n            avg_roughness = np.mean(roughness_values)\n            max_roughness = np.max(roughness_values)\n            return avg_roughness, max_roughness\n        else:\n            return 0.0, 0.0\n\n    def adjust_step_parameters_for_roughness(self, base_params, avg_roughness, max_roughness):\n        """Adjust step parameters based on terrain roughness"""\n        adjusted_params = base_params.copy()\n\n        # Reduce step length on rough terrain\n        roughness_factor = 1.0 - 0.3 * min(1.0, avg_roughness / 0.05)  # Reduce up to 30%\n        adjusted_params[\'step_length\'] *= roughness_factor\n\n        # Increase step height for rough terrain\n        adjusted_params[\'swing_height\'] += max(0, min(0.05, avg_roughness))\n\n        # Reduce step frequency on very rough terrain\n        if max_roughness > 0.08:\n            adjusted_params[\'step_time\'] *= 1.2  # Slower steps\n\n        return adjusted_params\n\n    def generate_ankle_adaptation_trajectory(self, foot_position, terrain_normal, step_phase):\n        """Generate ankle trajectory to adapt to terrain slope"""\n        # Calculate required ankle angles to match terrain slope\n        # terrain_normal is the surface normal vector at foot contact point\n        if np.linalg.norm(terrain_normal) > 0:\n            # Normalize the normal vector\n            normal = terrain_normal / np.linalg.norm(terrain_normal)\n\n            # Calculate required roll and pitch angles\n            # This is a simplified calculation\n            roll_angle = np.arctan2(normal[1], normal[2])\n            pitch_angle = np.arctan2(-normal[0], normal[2])\n\n            # Add phase-dependent modulation for natural ankle motion\n            phase_modulation = np.sin(step_phase * 2 * np.pi)\n            roll_angle *= (1 + 0.3 * phase_modulation)\n            pitch_angle *= (1 + 0.3 * phase_modulation)\n\n            return roll_angle, pitch_angle\n        else:\n            return 0.0, 0.0\n\n    def calculate_com_adaptation(self, terrain_roughness, base_com_trajectory):\n        """Calculate CoM trajectory adaptation for rough terrain"""\n        adapted_trajectory = base_com_trajectory.copy()\n\n        # Add small lateral sway to help with balance on uneven terrain\n        if terrain_roughness > 0.02:\n            lateral_amplitude = min(0.03, terrain_roughness * 2)  # Max 3cm sway\n            for i, (x, y, z) in enumerate(adapted_trajectory):\n                phase = i * 0.2  # Walking phase\n                adapted_trajectory[i][1] += lateral_amplitude * np.sin(phase)\n\n        # Adjust CoM height slightly for better stability\n        height_adjustment = max(-0.02, -terrain_roughness)  # Lower CoM on rough terrain\n        for pos in adapted_trajectory:\n            pos[2] += height_adjustment\n\n        return adapted_trajectory\n\n    def generate_compliant_foot_trajectory(self, nominal_trajectory, terrain_roughness):\n        """Generate foot trajectory with compliance for uneven surfaces"""\n        compliant_trajectory = []\n\n        for point in nominal_trajectory:\n            x, y, z = point\n\n            # Add compliance-based height adjustment\n            height_adjustment = np.random.normal(0, terrain_roughness * 0.5)\n            z_adjusted = z + height_adjustment\n\n            # Ensure foot doesn\'t go below ground\n            grid_x, grid_y = self.terrain_mapper.world_to_grid(x, y) if hasattr(self, \'terrain_mapper\') else (0, 0)\n            if (0 <= grid_x < 50 and 0 <= grid_y < 50):  # Assuming 50x50 grid\n                ground_height = 0  # Placeholder - would use actual terrain map\n                z_adjusted = max(z_adjusted, ground_height + 0.01)  # Minimum 1cm above ground\n\n            compliant_trajectory.append([x, y, z_adjusted])\n\n        return np.array(compliant_trajectory)\n\n    def plan_rough_terrain_footsteps(self, start_pos, goal_pos, terrain_map, max_roughness=0.05):\n        """Plan footsteps specifically for rough terrain"""\n        # Use base planner but with modified parameters\n        base_footsteps = self.plan_rough_terrain_sequence(start_pos, goal_pos, max_roughness)\n\n        # Add extra steps if terrain is very rough\n        if max_roughness > 0.03:\n            # Insert intermediate steps for better stability\n            refined_footsteps = []\n            for i in range(len(base_footsteps) - 1):\n                refined_footsteps.append(base_footsteps[i])\n\n                # Add intermediate step if distance is large\n                if i % 2 == 0:  # Only for every other step to maintain alternation\n                    pos1 = base_footsteps[i][1:3]  # x, y coordinates\n                    pos2 = base_footsteps[i+1][1:3]\n                    mid_pos = [(p1 + p2) / 2 for p1, p2 in zip(pos1, pos2)]\n\n                    refined_footsteps.append((\n                        base_footsteps[i][0],  # foot type\n                        mid_pos[0], mid_pos[1], 0.0  # intermediate position\n                    ))\n            refined_footsteps.append(base_footsteps[-1])\n\n            return refined_footsteps\n        else:\n            return base_footsteps\n\n    def plan_rough_terrain_sequence(self, start_pos, goal_pos, max_roughness):\n        """Plan a sequence of footsteps for rough terrain"""\n        footsteps = []\n        current_pos = np.array(start_pos)\n\n        # Calculate direction to goal\n        direction = np.array(goal_pos) - current_pos[:2]\n        distance = np.linalg.norm(direction)\n        direction = direction / distance if distance > 0 else np.array([1, 0])\n\n        # Adjust step size based on roughness\n        base_step_size = 0.3\n        step_size = base_step_size * (1 - 0.5 * min(1.0, max_roughness / 0.02))\n\n        num_steps = int(distance / step_size) + 1\n        step_vector = direction * step_size\n\n        for i in range(num_steps):\n            x = current_pos[0] + step_vector[0] * i\n            y = current_pos[1] + step_vector[1] * i\n\n            # Add small random variations to help with uneven terrain\n            x += np.random.normal(0, max_roughness * 2)\n            y += np.random.normal(0, max_roughness * 2)\n\n            foot_type = \'left\' if i % 2 == 0 else \'right\'\n            footsteps.append((foot_type, x, y, 0.0))\n\n        return footsteps\n\n    def evaluate_rough_terrain_traversability(self, path, terrain_map):\n        """Evaluate how well a path traverses rough terrain"""\n        score = 0.0\n        for i, (foot, x, y, z) in enumerate(path):\n            # Get terrain properties at this point\n            avg_rough, max_rough = self.analyze_terrain_roughness(terrain_map, (x, y))\n\n            # Penalty for very rough terrain\n            rough_penalty = max_rough * 100  # Higher roughness = higher penalty\n\n            # Bonus for smoother sections\n            smooth_bonus = max(0, 1 - avg_rough * 50)\n\n            score += smooth_bonus - rough_penalty\n\n        return score / len(path) if path else 0\n\n# Example: Rough terrain navigation\nrough_navigator = RoughTerrainNavigator()\n\n# Using the terrain map from earlier examples\navg_roughness, max_roughness = rough_navigator.analyze_terrain_roughness(\n    terrain_mapper, (0.5, 0.5), radius=0.3\n)\n\nprint(f"Local terrain roughness at (0.5, 0.5): avg={avg_roughness:.4f}, max={max_roughness:.4f}")\n\n# Adjust step parameters\nbase_params = {\'step_length\': 0.3, \'step_time\': 0.8, \'swing_height\': 0.05}\nadjusted_params = rough_navigator.adjust_step_parameters_for_roughness(\n    base_params, avg_roughness, max_roughness\n)\n\nprint(f"Base params: {base_params}")\nprint(f"Adjusted params: {adjusted_params}")\n\n# Plan footsteps for rough terrain\nrough_footsteps = rough_navigator.plan_rough_terrain_footsteps(\n    (0, 0), (2, 0), terrain_mapper, max_roughness=max_roughness\n)\nprint(f"Rough terrain footsteps: {len(rough_footsteps)} steps")\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-control-systems",children:"Integration with Control Systems"}),"\n",(0,a.jsx)(n.h3,{id:"ros-2-integration-for-terrain-adaptation",children:"ROS 2 Integration for Terrain Adaptation"}),"\n",(0,a.jsx)(n.p,{children:"Integrating terrain adaptation with ROS 2 for real-world deployment:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import PointCloud2, LaserScan\nfrom geometry_msgs.msg import Point, PoseStamped\nfrom std_msgs.msg import Float64MultiArray, Bool\nfrom nav_msgs.msg import Path\nfrom visualization_msgs.msg import MarkerArray, Marker\n\nclass TerrainAdaptationNode(Node):\n    def __init__(self):\n        super().__init__(\'terrain_adaptation_node\')\n\n        # Publishers\n        self.footstep_pub = self.create_publisher(Float64MultiArray, \'/planned_footsteps\', 10)\n        self.terrain_map_pub = self.create_publisher(MarkerArray, \'/terrain_map\', 10)\n        self.obstacle_pub = self.create_publisher(MarkerArray, \'/detected_obstacles\', 10)\n        self.status_pub = self.create_publisher(Bool, \'/terrain_adaptation_active\', 10)\n\n        # Subscribers\n        self.pointcloud_sub = self.create_subscription(\n            PointCloud2, \'/points\', self.pointcloud_callback, 10\n        )\n        self.imu_sub = self.create_subscription(\n            Point, \'/imu_com\', self.imu_callback, 10\n        )\n        self.goal_sub = self.create_subscription(\n            PoseStamped, \'/move_base_simple/goal\', self.goal_callback, 10\n        )\n\n        # Initialize components\n        self.terrain_mapper = TerrainMapper(resolution=0.05, map_size=10.0)\n        self.obstacle_detector = ObstacleDetector()\n        self.footstep_planner = FootstepPlanner(self.terrain_mapper)\n        self.adaptive_adjuster = AdaptiveFootstepAdjuster(self.footstep_planner)\n        self.stair_planner = StairNegotiationPlanner()\n        self.rough_navigator = RoughTerrainNavigator()\n\n        # Robot state\n        self.robot_position = np.array([0.0, 0.0, 0.85])\n        self.robot_yaw = 0.0\n        self.goal_position = None\n        self.current_footsteps = []\n        self.terrain_adaptation_active = False\n\n        # Timer for terrain processing\n        self.process_timer = self.create_timer(0.1, self.process_terrain_data)\n\n        self.get_logger().info(\'Terrain adaptation node initialized\')\n\n    def pointcloud_callback(self, msg):\n        """Process incoming point cloud data"""\n        try:\n            import sensor_msgs.point_cloud2 as pc2\n            points = []\n            for point in pc2.read_points(msg, field_names=("x", "y", "z"), skip_nans=True):\n                points.append([point[0], point[1], point[2]])\n\n            if points:\n                # Update terrain mapper\n                self.terrain_mapper.update_with_point_cloud(np.array(points))\n\n                # Detect obstacles\n                obstacles = self.obstacle_detector.detect_obstacles(\n                    np.array(points), ground_level=self.robot_position[2] - 0.85\n                )\n\n                # Update adaptive adjuster with new data\n                sensor_data = {\'point_cloud\': np.array(points)}\n                self.adaptive_adjuster.update_terrain_map(\n                    sensor_data[\'point_cloud\'], self.robot_position[:2]\n                )\n\n                self.get_logger().info(f\'Processed point cloud: {len(points)} points, {len(obstacles)} obstacles\')\n\n        except Exception as e:\n            self.get_logger().error(f\'Error processing point cloud: {e}\')\n\n    def imu_callback(self, msg):\n        """Process IMU data for robot state"""\n        self.robot_position[0] = msg.x\n        self.robot_position[1] = msg.y\n        self.robot_position[2] = msg.z\n\n    def goal_callback(self, msg):\n        """Process navigation goal"""\n        self.goal_position = np.array([msg.pose.position.x, msg.pose.position.y])\n        self.terrain_adaptation_active = True\n\n        # Plan path to goal\n        self.plan_path_to_goal()\n\n    def plan_path_to_goal(self):\n        """Plan path to goal considering terrain"""\n        if self.goal_position is None:\n            return\n\n        # Classify terrain between start and goal\n        start_pos = self.robot_position[:2]\n        goal_pos = self.goal_position\n\n        # Plan footsteps using the footstep planner\n        footsteps = self.footstep_planner.plan_alternating_feet(\n            (start_pos[0], start_pos[1] + 0.1, self.robot_yaw),\n            (start_pos[0], start_pos[1] - 0.1, self.robot_yaw),\n            goal_pos,\n            num_steps=20\n        )\n\n        if footsteps:\n            self.current_footsteps = footsteps\n            self.adaptive_adjuster.current_footsteps = footsteps\n\n            # Publish planned footsteps\n            footstep_msg = Float64MultiArray()\n            footstep_data = []\n            for foot, x, y, yaw in footsteps:\n                footstep_data.extend([x, y, yaw, 1.0 if foot == \'left\' else 0.0])  # Add left/right indicator\n            footstep_msg.data = footstep_data\n            self.footstep_pub.publish(footstep_msg)\n\n            self.get_logger().info(f\'Planned {len(footsteps)} footsteps to goal\')\n\n    def process_terrain_data(self):\n        """Periodic processing of terrain data"""\n        if not self.terrain_adaptation_active:\n            return\n\n        # Update terrain classification\n        if self.goal_position is not None:\n            # Check for terrain changes along the path\n            changes = self.adaptive_adjuster.detect_terrain_changes(\n                self.robot_position[:2], self.robot_yaw\n            )\n\n            if changes:\n                self.get_logger().info(f\'Detected {len(changes)} terrain changes, adjusting plan\')\n                self.current_footsteps = self.adaptive_adjuster.adjust_footsteps(\n                    changes, self.robot_position[:2], self.robot_yaw\n                )\n\n                # Republish updated footsteps\n                footstep_msg = Float64MultiArray()\n                footstep_data = []\n                for foot, x, y, yaw in self.current_footsteps:\n                    footstep_data.extend([x, y, yaw, 1.0 if foot == \'left\' else 0.0])\n                footstep_msg.data = footstep_data\n                self.footstep_pub.publish(footstep_msg)\n\n        # Publish terrain map visualization\n        self.publish_terrain_visualization()\n\n        # Publish status\n        status_msg = Bool()\n        status_msg.data = self.terrain_adaptation_active\n        self.status_pub.publish(status_msg)\n\n    def publish_terrain_visualization(self):\n        """Publish terrain map for visualization"""\n        marker_array = MarkerArray()\n\n        # Create markers for terrain features\n        marker = Marker()\n        marker.header.frame_id = \'map\'\n        marker.header.stamp = self.get_clock().now().to_msg()\n        marker.ns = \'terrain_map\'\n        marker.id = 0\n        marker.type = Marker.CUBE_LIST\n        marker.action = Marker.ADD\n\n        marker.pose.orientation.w = 1.0\n        marker.scale.x = self.terrain_mapper.resolution\n        marker.scale.y = self.terrain_mapper.resolution\n        marker.scale.z = 0.01\n\n        # Add points for traversable areas\n        for i in range(0, self.terrain_mapper.grid_size, 5):  # Downsample for performance\n            for j in range(0, self.terrain_mapper.grid_size, 5):\n                if not np.isnan(self.terrain_mapper.height_map[i, j]):\n                    point = Point()\n                    x, y = self.terrain_mapper.grid_to_world(i, j)\n                    point.x = x\n                    point.y = y\n                    point.z = self.terrain_mapper.height_map[i, j]\n\n                    # Color based on traversability\n                    if self.terrain_mapper.traversability_map[i, j] > 0.7:\n                        marker.color.r = 0.0  # Green for traversable\n                        marker.color.g = 1.0\n                        marker.color.b = 0.0\n                    else:\n                        marker.color.r = 1.0  # Red for non-traversable\n                        marker.color.g = 0.0\n                        marker.color.b = 0.0\n\n                    marker.color.a = 0.5\n                    marker.points.append(point)\n\n        marker_array.markers.append(marker)\n        self.terrain_map_pub.publish(marker_array)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    terrain_node = TerrainAdaptationNode()\n\n    try:\n        rclpy.spin(terrain_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        terrain_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,a.jsx)(n.h2,{id:"performance-evaluation-and-optimization",children:"Performance Evaluation and Optimization"}),"\n",(0,a.jsx)(n.h3,{id:"terrain-adaptation-metrics",children:"Terrain Adaptation Metrics"}),"\n",(0,a.jsx)(n.p,{children:"Evaluating the effectiveness of terrain adaptation systems:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class TerrainAdaptationEvaluator:\n    def __init__(self):\n        self.metrics = {\n            'path_efficiency': [],\n            'energy_consumption': [],\n            'stability_margin': [],\n            'step_success_rate': [],\n            'adaptation_response_time': []\n        }\n\n    def evaluate_path_efficiency(self, planned_path, executed_path, goal_position):\n        \"\"\"Evaluate path efficiency\"\"\"\n        if len(executed_path) == 0:\n            return 0.0\n\n        # Calculate path length efficiency\n        planned_length = sum(np.linalg.norm(np.array(executed_path[i+1]) - np.array(executed_path[i]))\n                          for i in range(len(executed_path)-1))\n\n        direct_distance = np.linalg.norm(np.array(executed_path[-1][:2]) - goal_position)\n\n        efficiency = direct_distance / planned_length if planned_length > 0 else 0.0\n        return efficiency\n\n    def evaluate_energy_consumption(self, joint_trajectories, joint_velocities):\n        \"\"\"Evaluate energy consumption\"\"\"\n        # Simplified energy calculation based on joint velocities\n        energy = 0.0\n        for vel_traj in joint_velocities:\n            # Energy proportional to square of velocity\n            energy += np.sum(vel_traj**2)\n\n        return energy\n\n    def evaluate_stability_margin(self, com_trajectory, foot_positions):\n        \"\"\"Evaluate stability based on ZMP and support polygon\"\"\"\n        stability_scores = []\n\n        for i, com_pos in enumerate(com_trajectory):\n            # Calculate distance from CoM to nearest foot\n            if i < len(foot_positions):\n                foot_pos = foot_positions[i]\n                distance = np.linalg.norm(com_pos[:2] - foot_pos[:2])\n                # Stability is better when CoM is closer to support points\n                stability_score = 1.0 / (1.0 + distance)  # Higher is better\n                stability_scores.append(stability_score)\n\n        return np.mean(stability_scores) if stability_scores else 0.0\n\n    def evaluate_step_success_rate(self, planned_footsteps, actual_footsteps):\n        \"\"\"Evaluate percentage of successful steps\"\"\"\n        if len(planned_footsteps) == 0:\n            return 0.0\n\n        successful_steps = 0\n        for planned, actual in zip(planned_footsteps, actual_footsteps):\n            # Check if step was completed within tolerance\n            if np.linalg.norm(np.array(planned[1:3]) - np.array(actual[1:3])) < 0.05:  # 5cm tolerance\n                successful_steps += 1\n\n        return successful_steps / len(planned_footsteps)\n\n    def evaluate_adaptation_response_time(self, terrain_change_times, adaptation_times):\n        \"\"\"Evaluate how quickly system adapts to terrain changes\"\"\"\n        if len(terrain_change_times) == 0:\n            return float('inf')\n\n        response_times = []\n        for change_time, adaptation_time in zip(terrain_change_times, adaptation_times):\n            response_time = adaptation_time - change_time\n            if response_time > 0:\n                response_times.append(response_time)\n\n        return np.mean(response_times) if response_times else float('inf')\n\n    def calculate_comprehensive_score(self, weights=None):\n        \"\"\"Calculate weighted comprehensive score\"\"\"\n        if weights is None:\n            weights = {\n                'path_efficiency': 0.25,\n                'energy_efficiency': 0.2,\n                'stability': 0.3,\n                'success_rate': 0.15,\n                'response_time': 0.1\n            }\n\n        # Normalize metrics to [0, 1] range\n        path_eff = np.mean(self.metrics['path_efficiency']) if self.metrics['path_efficiency'] else 0.0\n        energy_eff = 1.0 / (1.0 + np.mean(self.metrics['energy_consumption'])) if self.metrics['energy_consumption'] else 1.0\n        stability = np.mean(self.metrics['stability_margin']) if self.metrics['stability_margin'] else 0.0\n        success_rate = np.mean(self.metrics['step_success_rate']) if self.metrics['step_success_rate'] else 0.0\n        response_time_score = 1.0 / (1.0 + np.mean(self.metrics['adaptation_response_time'])) if self.metrics['adaptation_response_time'] else 1.0\n\n        comprehensive_score = (\n            weights['path_efficiency'] * path_eff +\n            weights['energy_efficiency'] * energy_eff +\n            weights['stability'] * stability +\n            weights['success_rate'] * success_rate +\n            weights['response_time'] * response_time_score\n        )\n\n        return comprehensive_score\n\n    def log_metric(self, metric_name, value):\n        \"\"\"Log a metric value\"\"\"\n        if metric_name in self.metrics:\n            self.metrics[metric_name].append(value)\n\n    def get_performance_report(self):\n        \"\"\"Generate performance report\"\"\"\n        report = {\n            'path_efficiency': {\n                'mean': np.mean(self.metrics['path_efficiency']) if self.metrics['path_efficiency'] else 0.0,\n                'std': np.std(self.metrics['path_efficiency']) if self.metrics['path_efficiency'] else 0.0,\n                'count': len(self.metrics['path_efficiency'])\n            },\n            'energy_consumption': {\n                'mean': np.mean(self.metrics['energy_consumption']) if self.metrics['energy_consumption'] else 0.0,\n                'std': np.std(self.metrics['energy_consumption']) if self.metrics['energy_consumption'] else 0.0,\n                'count': len(self.metrics['energy_consumption'])\n            },\n            'stability_margin': {\n                'mean': np.mean(self.metrics['stability_margin']) if self.metrics['stability_margin'] else 0.0,\n                'std': np.std(self.metrics['stability_margin']) if self.metrics['stability_margin'] else 0.0,\n                'count': len(self.metrics['stability_margin'])\n            },\n            'step_success_rate': {\n                'mean': np.mean(self.metrics['step_success_rate']) if self.metrics['step_success_rate'] else 0.0,\n                'std': np.std(self.metrics['step_success_rate']) if self.metrics['step_success_rate'] else 0.0,\n                'count': len(self.metrics['step_success_rate'])\n            },\n            'adaptation_response_time': {\n                'mean': np.mean(self.metrics['adaptation_response_time']) if self.metrics['adaptation_response_time'] else 0.0,\n                'std': np.std(self.metrics['adaptation_response_time']) if self.metrics['adaptation_response_time'] else 0.0,\n                'count': len(self.metrics['adaptation_response_time'])\n            },\n            'comprehensive_score': self.calculate_comprehensive_score()\n        }\n\n        return report\n\n# Example: Performance evaluation\nevaluator = TerrainAdaptationEvaluator()\n\n# Simulate evaluation metrics\nfor i in range(10):\n    # Simulate different terrain scenarios\n    path_eff = np.random.uniform(0.6, 0.95)\n    energy_cons = np.random.uniform(10, 50)\n    stability = np.random.uniform(0.5, 0.9)\n    success_rate = np.random.uniform(0.8, 1.0)\n    response_time = np.random.uniform(0.1, 0.5)\n\n    evaluator.log_metric('path_efficiency', path_eff)\n    evaluator.log_metric('energy_consumption', energy_cons)\n    evaluator.log_metric('stability_margin', stability)\n    evaluator.log_metric('step_success_rate', success_rate)\n    evaluator.log_metric('adaptation_response_time', response_time)\n\n# Generate report\nreport = evaluator.get_performance_report()\nprint(\"Terrain Adaptation Performance Report:\")\nprint(f\"Path Efficiency: {report['path_efficiency']['mean']:.3f} \xb1 {report['path_efficiency']['std']:.3f}\")\nprint(f\"Energy Consumption: {report['energy_consumption']['mean']:.1f} \xb1 {report['energy_consumption']['std']:.1f}\")\nprint(f\"Stability Margin: {report['stability_margin']['mean']:.3f} \xb1 {report['stability_margin']['std']:.3f}\")\nprint(f\"Step Success Rate: {report['step_success_rate']['mean']:.3f} \xb1 {report['step_success_rate']['std']:.3f}\")\nprint(f\"Response Time: {report['adaptation_response_time']['mean']:.3f} \xb1 {report['adaptation_response_time']['std']:.3f}\")\nprint(f\"Comprehensive Score: {report['comprehensive_score']:.3f}\")\n"})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Terrain adaptation and footstep planning are critical capabilities that enable humanoid robots to navigate complex, real-world environments. The integration of perception, planning, and control systems allows robots to respond to diverse terrain conditions including flat surfaces, slopes, stairs, obstacles, and rough terrain."}),"\n",(0,a.jsx)(n.p,{children:"The key to successful terrain adaptation lies in the combination of:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Accurate terrain perception and classification"}),"\n",(0,a.jsx)(n.li,{children:"Robust footstep planning algorithms"}),"\n",(0,a.jsx)(n.li,{children:"Real-time adaptation mechanisms"}),"\n",(0,a.jsx)(n.li,{children:"Integration with balance and locomotion control systems"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Modern approaches use a hierarchical strategy where global planning provides a general path, local planning handles immediate obstacles, and reactive control adapts to unexpected terrain features. The evaluation of these systems requires comprehensive metrics that consider efficiency, stability, energy consumption, and adaptability."}),"\n",(0,a.jsx)(n.p,{children:"The next section will explore complex terrain navigation, including specialized techniques for challenging environments like stairs, narrow passages, and dynamic obstacles."})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var s=t(6540);const a={},r=s.createContext(a);function i(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(r.Provider,{value:n},e.children)}}}]);