"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[14],{5861:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>l,contentTitle:()=>r,default:()=>m,frontMatter:()=>s,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"module-4-locomotion-mobility/biomechanics","title":"Biomechanics of Humanoid Locomotion","description":"Introduction: Understanding Human Movement","source":"@site/docs/module-4-locomotion-mobility/biomechanics.md","sourceDirName":"module-4-locomotion-mobility","slug":"/module-4-locomotion-mobility/biomechanics","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/biomechanics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-locomotion-mobility/biomechanics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Module 4: Locomotion and Mobility","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/"},"next":{"title":"Dynamic Walking and Balance Control","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/dynamic-walking"}}');var o=t(4848),a=t(8453);const s={},r="Biomechanics of Humanoid Locomotion",l={},c=[{value:"Introduction: Understanding Human Movement",id:"introduction-understanding-human-movement",level:2},{value:"The Human Locomotor System",id:"the-human-locomotor-system",level:3},{value:"Key Biomechanical Concepts",id:"key-biomechanical-concepts",level:2},{value:"Center of Mass (CoM) and Stability",id:"center-of-mass-com-and-stability",level:3},{value:"Zero-Moment Point (ZMP) Theory",id:"zero-moment-point-zmp-theory",level:3},{value:"Inverted Pendulum Models",id:"inverted-pendulum-models",level:3},{value:"Human Walking Biomechanics",id:"human-walking-biomechanics",level:2},{value:"Gait Cycle Analysis",id:"gait-cycle-analysis",level:3},{value:"Joint Kinematics During Walking",id:"joint-kinematics-during-walking",level:3},{value:"Anthropomorphic Design Principles",id:"anthropomorphic-design-principles",level:2},{value:"Proportional Relationships",id:"proportional-relationships",level:3},{value:"Locomotion Energetics",id:"locomotion-energetics",level:2},{value:"Mechanical Work and Energy",id:"mechanical-work-and-energy",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"biomechanics-of-humanoid-locomotion",children:"Biomechanics of Humanoid Locomotion"})}),"\n",(0,o.jsx)(e.h2,{id:"introduction-understanding-human-movement",children:"Introduction: Understanding Human Movement"}),"\n",(0,o.jsx)(e.p,{children:"The biomechanics of locomotion form the foundation for understanding how humanoid robots can move efficiently and stably. By studying human locomotion patterns, researchers can develop control strategies that mimic the natural efficiency and adaptability of human movement. This section explores the fundamental principles of bipedal locomotion, including the mechanics of walking, running, and balance maintenance."}),"\n",(0,o.jsx)(e.h3,{id:"the-human-locomotor-system",children:"The Human Locomotor System"}),"\n",(0,o.jsx)(e.p,{children:"Human locomotion is a complex interplay of:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Skeletal System"}),": Provides structural support and levers for movement"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Muscular System"}),": Generates forces for movement and stability"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Nervous System"}),": Controls movement patterns and maintains balance"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Sensory Systems"}),": Provides feedback for control and adaptation"]}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"key-biomechanical-concepts",children:"Key Biomechanical Concepts"}),"\n",(0,o.jsx)(e.h3,{id:"center-of-mass-com-and-stability",children:"Center of Mass (CoM) and Stability"}),"\n",(0,o.jsx)(e.p,{children:"The Center of Mass (CoM) is crucial for understanding balance and locomotion:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\nclass CenterOfMassAnalyzer:\n    def __init__(self, robot_mass=70.0, com_height=0.85):\n        self.mass = robot_mass  # kg\n        self.height = com_height  # m\n        self.position = np.array([0.0, 0.0, com_height])  # x, y, z\n        self.velocity = np.array([0.0, 0.0, 0.0])\n        self.acceleration = np.array([0.0, 0.0, 0.0])\n\n    def update_com_position(self, joint_positions, joint_masses):\n        """Calculate CoM position from joint positions and masses"""\n        total_mass = sum(joint_masses)\n        weighted_sum = np.zeros(3)\n\n        for pos, mass in zip(joint_positions, joint_masses):\n            weighted_sum += np.array(pos) * mass\n\n        self.position = weighted_sum / total_mass if total_mass > 0 else np.array([0, 0, self.height])\n        return self.position\n\n    def calculate_com_velocity(self, new_position, dt):\n        """Calculate CoM velocity from position changes"""\n        if dt > 0:\n            self.velocity = (new_position - self.position) / dt\n        return self.velocity\n\n    def calculate_com_acceleration(self, new_velocity, dt):\n        """Calculate CoM acceleration from velocity changes"""\n        if dt > 0:\n            self.acceleration = (new_velocity - self.velocity) / dt\n        return self.acceleration\n\n    def is_stable(self, support_polygon):\n        """Check if CoM is within support polygon for static stability"""\n        if len(support_polygon) < 3:\n            return False\n\n        # Simple check for 2D projection (x, y)\n        com_2d = self.position[:2]\n        return self.point_in_polygon(com_2d, support_polygon)\n\n    def point_in_polygon(self, point, polygon):\n        """Check if point is inside polygon using ray casting"""\n        x, y = point\n        n = len(polygon)\n        inside = False\n\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n\n        return inside\n\n    def calculate_angular_momentum(self, joint_positions, joint_velocities, joint_masses):\n        """Calculate angular momentum about CoM"""\n        angular_momentum = np.zeros(3)\n\n        for pos, vel, mass in zip(joint_positions, joint_velocities, joint_masses):\n            r = np.array(pos) - self.position  # Position relative to CoM\n            v = np.array(vel)\n            angular_momentum += mass * np.cross(r, v)\n\n        return angular_momentum\n\n# Example: Analyze CoM during walking\nanalyzer = CenterOfMassAnalyzer()\n\n# Simulate CoM positions during walking cycle\nt = np.linspace(0, 2, 100)  # 2 seconds of walking\ncom_x = 0.5 * t  # Forward progression\ncom_y = 0.05 * np.sin(2 * np.pi * t)  # Lateral sway\ncom_z = 0.85 + 0.02 * np.sin(4 * np.pi * t)  # Vertical oscillation\n\ncom_positions = np.column_stack([com_x, com_y, com_z])\ncom_velocities = np.gradient(com_positions, axis=0) / (2/100)  # dt = 2/100 seconds\ncom_accelerations = np.gradient(com_velocities, axis=0) / (2/100)\n\nprint(f"CoM oscillation range: Z = {np.min(com_z):.3f} to {np.max(com_z):.3f} m")\nprint(f"Average CoM velocity: {np.mean(np.linalg.norm(com_velocities, axis=1)):.3f} m/s")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"zero-moment-point-zmp-theory",children:"Zero-Moment Point (ZMP) Theory"}),"\n",(0,o.jsx)(e.p,{children:"The Zero-Moment Point is fundamental to dynamic balance in bipedal locomotion:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class ZMPCalculator:\n    def __init__(self, com_height=0.85, gravity=9.81):\n        self.com_height = com_height  # CoM height above ground\n        self.gravity = gravity\n\n    def calculate_zmp_simple(self, com_position, com_acceleration):\n        """Calculate ZMP using simple inverted pendulum model"""\n        # ZMP = CoM - (CoM_height / gravity) * CoM_acceleration\n        zmp_x = com_position[0] - (self.com_height / self.gravity) * com_acceleration[0]\n        zmp_y = com_position[1] - (self.com_height / self.gravity) * com_acceleration[1]\n\n        return np.array([zmp_x, zmp_y, 0.0])  # ZMP is on ground plane (z=0)\n\n    def calculate_zmp_from_forces(self, contact_forces, contact_positions):\n        """Calculate ZMP from ground reaction forces and positions"""\n        # ZMP = sum(Fi * pi) / sum(Fi) where Fi are vertical forces\n        total_force = 0\n        moment_x = 0\n        moment_y = 0\n\n        for force, position in zip(contact_forces, contact_positions):\n            fz = force[2]  # Vertical force component\n            total_force += fz\n            moment_x += fz * position[0]  # Moment about y-axis\n            moment_y += fz * position[1]  # Moment about x-axis\n\n        if total_force != 0:\n            zmp_x = moment_x / total_force\n            zmp_y = moment_y / total_force\n            return np.array([zmp_x, zmp_y, 0.0])\n        else:\n            return np.array([0.0, 0.0, 0.0])\n\n    def is_stable_zmp(self, zmp, support_polygon, margin=0.05):\n        """Check if ZMP is within support polygon with safety margin"""\n        # Expand support polygon by margin\n        expanded_polygon = self.expand_polygon(support_polygon, margin)\n        return self.point_in_polygon_2d(zmp[:2], expanded_polygon)\n\n    def expand_polygon(self, polygon, margin):\n        """Expand polygon by margin distance"""\n        # Simple expansion by moving each vertex outward\n        expanded = []\n        for i, vertex in enumerate(polygon):\n            # Calculate average direction from centroid\n            centroid = np.mean(polygon, axis=0)\n            direction = np.array(vertex) - centroid\n            direction = direction / np.linalg.norm(direction) if np.linalg.norm(direction) > 0 else np.array([1, 0])\n            expanded_vertex = np.array(vertex) + direction * margin\n            expanded.append(expanded_vertex)\n        return expanded\n\n    def point_in_polygon_2d(self, point, polygon):\n        """Check if 2D point is in polygon"""\n        x, y = point\n        n = len(polygon)\n        inside = False\n\n        p1x, p1y = polygon[0]\n        for i in range(1, n + 1):\n            p2x, p2y = polygon[i % n]\n            if y > min(p1y, p2y):\n                if y <= max(p1y, p2y):\n                    if x <= max(p1x, p2x):\n                        if p1y != p2y:\n                            xinters = (y - p1y) * (p2x - p1x) / (p2y - p1y) + p1x\n                        if p1x == p2x or x <= xinters:\n                            inside = not inside\n            p1x, p1y = p2x, p2y\n\n        return inside\n\n# Example: Calculate ZMP during walking\nzmp_calc = ZMPCalculator(com_height=0.85)\n\n# Simulate walking with CoM data\nwalking_time = np.linspace(0, 2, 100)\ncom_pos_x = 0.5 * walking_time  # Forward motion\ncom_pos_y = 0.05 * np.sin(2 * np.pi * walking_time)  # Lateral sway\ncom_pos_z = 0.85 + 0.02 * np.sin(4 * np.pi * walking_time)  # Vertical oscillation\n\ncom_positions = np.column_stack([com_pos_x, com_pos_y, com_pos_z])\ncom_accelerations = np.gradient(np.gradient(com_positions, axis=0), axis=0) / (2/100)**2\n\n# Calculate ZMP for each time step\nzmp_positions = []\nfor pos, acc in zip(com_positions, com_accelerations):\n    zmp = zmp_calc.calculate_zmp_simple(pos, acc)\n    zmp_positions.append(zmp)\n\nzmp_positions = np.array(zmp_positions)\n\nprint(f"ZMP range: X = {np.min(zmp_positions[:, 0]):.3f} to {np.max(zmp_positions[:, 0]):.3f} m")\nprint(f"ZMP range: Y = {np.min(zmp_positions[:, 1]):.3f} to {np.max(zmp_positions[:, 1]):.3f} m")\n'})}),"\n",(0,o.jsx)(e.h3,{id:"inverted-pendulum-models",children:"Inverted Pendulum Models"}),"\n",(0,o.jsx)(e.p,{children:"Inverted pendulum models are fundamental to understanding balance:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'class InvertedPendulum:\n    def __init__(self, length=0.85, mass=70.0, gravity=9.81):\n        self.length = length  # Length from pivot to CoM (m)\n        self.mass = mass      # Mass (kg)\n        self.gravity = gravity\n        self.angle = 0.0      # Angle from vertical (rad)\n        self.angular_velocity = 0.0\n\n    def dynamics(self, angle, angular_velocity, control_torque=0):\n        """Equations of motion for inverted pendulum"""\n        # Nonlinear dynamics: theta_ddot = (g/l)*sin(theta) + torque/(m*l^2)\n        angular_acceleration = (self.gravity / self.length) * np.sin(angle) + \\\n                              control_torque / (self.mass * self.length**2)\n        return angular_acceleration\n\n    def linearized_dynamics(self, angle, angular_velocity, control_torque=0):\n        """Linearized equations of motion (valid for small angles)"""\n        # For small angles: sin(theta) \u2248 theta\n        # theta_ddot = (g/l)*theta + torque/(m*l^2)\n        angular_acceleration = (self.gravity / self.length) * angle + \\\n                              control_torque / (self.mass * self.length**2)\n        return angular_acceleration\n\n    def integrate(self, dt, control_torque=0):\n        """Integrate the dynamics forward by dt"""\n        angular_acceleration = self.dynamics(self.angle, self.angular_velocity, control_torque)\n\n        # Update state using Euler integration\n        self.angular_velocity += angular_acceleration * dt\n        self.angle += self.angular_velocity * dt\n\n        return self.angle, self.angular_velocity\n\n    def energy(self):\n        """Calculate total energy of the pendulum"""\n        # Kinetic energy: KE = 0.5 * I * omega^2\n        # Potential energy: PE = m * g * h\n        # For pendulum: I = m * l^2, h = l * (1 - cos(theta))\n        kinetic_energy = 0.5 * self.mass * self.length**2 * self.angular_velocity**2\n        potential_energy = self.mass * self.gravity * self.length * (1 - np.cos(self.angle))\n        return kinetic_energy + potential_energy\n\nclass LinearInvertedPendulum:\n    def __init__(self, com_height=0.85, gravity=9.81):\n        self.com_height = com_height\n        self.gravity = gravity\n        self.omega = np.sqrt(gravity / com_height)  # Natural frequency\n\n    def zmp_dynamics(self, zmp, com_pos, com_vel):\n        """Dynamics: CoM acceleration based on ZMP position"""\n        # LIPM: CoM_ddot = omega^2 * (CoM - ZMP)\n        com_acc_x = self.omega**2 * (com_pos[0] - zmp[0])\n        com_acc_y = self.omega**2 * (com_pos[1] - zmp[1])\n        return np.array([com_acc_x, com_acc_y])\n\n    def com_trajectory_from_zmp(self, zmp_trajectory, initial_com, initial_vel, dt):\n        """Compute CoM trajectory from ZMP trajectory"""\n        com_positions = [initial_com]\n        com_velocities = [initial_vel]\n\n        for zmp in zmp_trajectory:\n            # Get current state\n            current_com = com_positions[-1]\n            current_vel = com_velocities[-1]\n\n            # Calculate acceleration\n            acc = self.zmp_dynamics(zmp, current_com, current_vel)\n\n            # Integrate velocity\n            new_vel = current_vel + acc * dt\n\n            # Integrate position\n            new_pos = current_com + new_vel * dt\n\n            com_positions.append(new_pos)\n            com_velocities.append(new_vel)\n\n        return np.array(com_positions), np.array(com_velocities)\n\n# Example: Simulate inverted pendulum for balance\npendulum = InvertedPendulum(length=0.85, mass=70.0)\n\n# Simulate with small disturbance\ntime_points = np.linspace(0, 5, 500)\ndt = time_points[1] - time_points[0]\n\n# Initial conditions: small angle\npendulum.angle = 0.1  # 0.1 rad = ~5.7 degrees\npendulum.angular_velocity = 0.0\n\nangles = []\nangular_velocities = []\nenergies = []\n\nfor t in time_points:\n    angle, ang_vel = pendulum.integrate(dt)\n    energy = pendulum.energy()\n\n    angles.append(angle)\n    angular_velocities.append(ang_vel)\n    energies.append(energy)\n\nprint(f"Initial energy: {energies[0]:.3f} J")\nprint(f"Final energy: {energies[-1]:.3f} J")\nprint(f"Max angle: {np.max(np.abs(angles)):.3f} rad ({np.max(np.abs(angles))*180/np.pi:.1f}\xb0)")\n'})}),"\n",(0,o.jsx)(e.h2,{id:"human-walking-biomechanics",children:"Human Walking Biomechanics"}),"\n",(0,o.jsx)(e.h3,{id:"gait-cycle-analysis",children:"Gait Cycle Analysis"}),"\n",(0,o.jsx)(e.p,{children:"The human gait cycle has distinct phases that inform robotic walking:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class GaitCycleAnalyzer:\n    def __init__(self):\n        self.stance_phase = 0.6  # 60% of gait cycle is stance\n        self.swing_phase = 0.4   # 40% of gait cycle is swing\n        self.step_length = 0.7   # Average step length (m)\n        self.step_width = 0.1    # Distance between feet (m)\n        self.stride_time = 1.0   # Time for one complete step cycle (s)\n\n    def gait_phase(self, time, leg='right'):\n        \"\"\"Determine gait phase based on time\"\"\"\n        # Normalize time to gait cycle\n        cycle_time = time % (2 * self.stride_time)  # Two steps per cycle (right-left)\n\n        if leg == 'right':\n            if cycle_time < self.stride_time:\n                # Right leg stance phase\n                if cycle_time / self.stride_time < self.stance_phase:\n                    return 'stance'\n                else:\n                    return 'swing'\n            else:\n                # Right leg swing phase (left leg is in stance)\n                return 'swing'\n        else:  # left leg\n            if cycle_time < self.stride_time:\n                # Left leg swing phase (right leg is in stance)\n                return 'swing'\n            else:\n                # Left leg stance phase\n                if (cycle_time - self.stride_time) / self.stride_time < self.stance_phase:\n                    return 'stance'\n                else:\n                    return 'swing'\n\n    def foot_position(self, time, leg='right'):\n        \"\"\"Calculate foot position during gait cycle\"\"\"\n        # This is a simplified model\n        cycle_time = time % (2 * self.stride_time)\n\n        if leg == 'right':\n            if cycle_time < self.stride_time:\n                # Right foot in stance, left foot in swing\n                # Right foot position (relative to body center)\n                x = -self.step_length / 2\n                y = -self.step_width / 2 if cycle_time < self.stride_time / 2 else self.step_width / 2\n            else:\n                # Left foot in stance, right foot in swing\n                # Right foot position (moving forward)\n                swing_progress = (cycle_time - self.stride_time) / (self.stride_time * self.swing_phase)\n                x = -self.step_length / 2 + self.step_length * swing_progress\n                y = self.step_width / 2\n        else:  # left leg\n            if cycle_time < self.stride_time:\n                # Left foot in swing, right foot in stance\n                # Left foot position (moving forward)\n                swing_progress = cycle_time / (self.stride_time * self.swing_phase)\n                x = -self.step_length / 2 + self.step_length * swing_progress\n                y = -self.step_width / 2\n            else:\n                # Left foot in stance\n                x = -self.step_length / 2\n                y = self.step_width / 2 if cycle_time < 1.5 * self.stride_time else -self.step_width / 2\n\n        return np.array([x, y, 0.0])\n\n    def calculate_gait_parameters(self, walking_speed):\n        \"\"\"Calculate gait parameters based on walking speed\"\"\"\n        # Empirical relationships for human gait\n        stride_length = 0.45 + 0.4 * walking_speed  # Approximate relationship\n        stride_time = stride_length / walking_speed if walking_speed > 0 else 1.0\n        step_frequency = 1 / stride_time\n\n        # Duty factor (stance time / stride time)\n        duty_factor = 0.6 if walking_speed < 1.0 else 0.4  # Humans change duty factor with speed\n\n        return {\n            'stride_length': stride_length,\n            'stride_time': stride_time,\n            'step_frequency': step_frequency,\n            'duty_factor': duty_factor,\n            'step_length': stride_length / 2\n        }\n\n    def generate_footprint_pattern(self, duration, walking_speed=1.0):\n        \"\"\"Generate footprint pattern over time\"\"\"\n        gait_params = self.calculate_gait_parameters(walking_speed)\n        time_steps = np.arange(0, duration, 0.01)\n\n        right_footprints = []\n        left_footprints = []\n\n        for t in time_steps:\n            # Determine if foot should be placed\n            right_phase = self.gait_phase(t, 'right')\n            left_phase = self.gait_phase(t, 'left')\n\n            # Simplified footprint placement logic\n            if t > 0 and int(t / gait_params['stride_time']) != int((t-0.01) / gait_params['stride_time']):\n                # New stride cycle started\n                cycle_num = int(t / gait_params['stride_time'])\n                forward_offset = cycle_num * gait_params['stride_length'] / 2\n\n                if cycle_num % 2 == 0:  # Right foot contact\n                    right_footprints.append([forward_offset, -self.step_width/2, t])\n                else:  # Left foot contact\n                    left_footprints.append([forward_offset, self.step_width/2, t])\n\n        return np.array(right_footprints), np.array(left_footprints)\n\n# Example: Analyze gait patterns\ngait_analyzer = GaitCycleAnalyzer()\n\n# Calculate gait parameters for different speeds\nspeeds = [0.5, 1.0, 1.5]\nfor speed in speeds:\n    params = gait_analyzer.calculate_gait_parameters(speed)\n    print(f\"Speed {speed} m/s: Stride length = {params['stride_length']:.2f} m, \"\n          f\"Frequency = {params['step_frequency']:.2f} Hz\")\n\n# Generate footprint pattern\nright_fp, left_fp = gait_analyzer.generate_footprint_pattern(4.0, walking_speed=1.0)\nprint(f\"Generated {len(right_fp)} right footprints and {len(left_fp)} left footprints\")\n"})}),"\n",(0,o.jsx)(e.h3,{id:"joint-kinematics-during-walking",children:"Joint Kinematics During Walking"}),"\n",(0,o.jsx)(e.p,{children:"Understanding joint movements during the gait cycle:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class JointKinematicsAnalyzer:\n    def __init__(self):\n        # Typical ranges of motion during walking (in degrees)\n        self.hip_rom = {'flexion': 30, 'extension': 10, 'abduction': 10, 'adduction': 5}\n        self.knee_rom = {'flexion': 65, 'extension': 5}\n        self.ankle_rom = {'dorsiflexion': 15, 'plantarflexion': 20}\n\n    def hip_angle_trajectory(self, phase, leg='right'):\n        \"\"\"Generate hip angle trajectory during gait cycle\"\"\"\n        # Simplified hip angle patterns during walking\n        if phase == 'stance':\n            # Hip flexion/extension during stance phase\n            # Maximum flexion at initial contact, extension during push-off\n            hip_flexion = 10 * np.sin(2 * np.pi * phase) if hasattr(phase, '__len__') else 10  # Simplified\n        else:  # swing\n            # Hip flexion increases during swing to clear the foot\n            hip_flexion = 20  # Average swing phase flexion\n\n        return np.radians(hip_flexion)\n\n    def knee_angle_trajectory(self, gait_phase, swing_progress=0.0):\n        \"\"\"Generate knee angle trajectory\"\"\"\n        if gait_phase == 'stance':\n            # Knee starts slightly flexed, extends mid-stance, flexes for push-off\n            knee_angle = 10  # Degrees flexion during mid-stance\n        else:  # swing\n            # Knee flexes during early swing for foot clearance, extends for landing\n            if swing_progress < 0.3:  # Early swing\n                knee_angle = 60  # Maximum flexion\n            elif swing_progress < 0.7:  # Mid swing\n                knee_angle = 40\n            else:  # Late swing\n                knee_angle = 10  # Prepare for landing\n\n        return np.radians(knee_angle)\n\n    def ankle_angle_trajectory(self, gait_phase, stance_progress=0.0):\n        \"\"\"Generate ankle angle trajectory\"\"\"\n        if gait_phase == 'stance':\n            # Ankle motion during stance: dorsiflexion after heel strike, plantarflexion at push-off\n            if stance_progress < 0.2:  # After heel strike\n                ankle_angle = -10  # Dorsiflexion\n            elif stance_progress < 0.6:  # Mid-stance\n                ankle_angle = 0   # Neutral\n            else:  # Push-off\n                ankle_angle = 15  # Plantarflexion\n        else:  # swing\n            # Ankle remains slightly dorsiflexed during swing for foot clearance\n            ankle_angle = -5\n\n        return np.radians(ankle_angle)\n\n    def generate_full_leg_trajectory(self, time_points):\n        \"\"\"Generate complete leg kinematics for walking\"\"\"\n        trajectories = {\n            'right_hip_flexion': [],\n            'right_knee_flexion': [],\n            'right_ankle_angle': [],\n            'left_hip_flexion': [],\n            'left_knee_flexion': [],\n            'left_ankle_angle': []\n        }\n\n        gait_analyzer = GaitCycleAnalyzer()\n\n        for t in time_points:\n            # Right leg\n            right_phase = gait_analyzer.gait_phase(t, 'right')\n            right_foot_pos = gait_analyzer.foot_position(t, 'right')\n\n            # Left leg\n            left_phase = gait_analyzer.gait_phase(t, 'left')\n            left_foot_pos = gait_analyzer.foot_position(t, 'left')\n\n            # Calculate joint angles based on phase\n            # This is a simplified representation\n            trajectories['right_hip_flexion'].append(self.hip_angle_trajectory(right_phase))\n            trajectories['right_knee_flexion'].append(self.knee_angle_trajectory(right_phase))\n            trajectories['right_ankle_angle'].append(self.ankle_angle_trajectory(right_phase))\n\n            trajectories['left_hip_flexion'].append(self.hip_angle_trajectory(left_phase))\n            trajectories['left_knee_flexion'].append(self.knee_angle_trajectory(left_phase))\n            trajectories['left_ankle_angle'].append(self.ankle_angle_trajectory(left_phase))\n\n        return trajectories\n\n# Example: Generate joint trajectories\nkin_analyzer = JointKinematicsAnalyzer()\ntime_points = np.linspace(0, 4, 400)  # 4 seconds of walking\njoint_trajectories = kin_analyzer.generate_full_leg_trajectory(time_points)\n\nprint(f\"Generated trajectories for {len(time_points)} time steps\")\nprint(f\"Right hip flexion range: {np.degrees(min(joint_trajectories['right_hip_flexion'])):.1f}\xb0 \"\n      f\"to {np.degrees(max(joint_trajectories['right_hip_flexion'])):.1f}\xb0\")\n"})}),"\n",(0,o.jsx)(e.h2,{id:"anthropomorphic-design-principles",children:"Anthropomorphic Design Principles"}),"\n",(0,o.jsx)(e.h3,{id:"proportional-relationships",children:"Proportional Relationships"}),"\n",(0,o.jsx)(e.p,{children:"Human-like proportions are important for natural movement:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class AnthropomorphicDesign:\n    def __init__(self, height=1.7):\n        self.height = height\n        self.mass = 70.0  # Default mass in kg\n        self.segment_ratios = self.calculate_segment_ratios()\n        self.joint_constraints = self.define_joint_constraints()\n\n    def calculate_segment_ratios(self):\n        \"\"\"Calculate body segment ratios based on anthropometric data\"\"\"\n        # Standard anthropometric ratios (fraction of total height)\n        ratios = {\n            'head': 0.152,  # Head height\n            'trunk': 0.520,  # Trunk height\n            'upper_leg': 0.245,  # Upper leg (thigh)\n            'lower_leg': 0.240,  # Lower leg (shank)\n            'foot': 0.152,  # Foot length\n            'upper_arm': 0.186,  # Upper arm\n            'lower_arm': 0.146   # Lower arm\n        }\n\n        # Convert to actual lengths\n        lengths = {key: value * self.height for key, value in ratios.items()}\n        return lengths\n\n    def define_joint_constraints(self):\n        \"\"\"Define physiologically realistic joint limits\"\"\"\n        constraints = {\n            'hip': {\n                'flexion': np.radians(120),\n                'extension': np.radians(-30),\n                'abduction': np.radians(45),\n                'adduction': np.radians(-30),\n                'internal_rotation': np.radians(45),\n                'external_rotation': np.radians(-45)\n            },\n            'knee': {\n                'flexion': np.radians(150),\n                'extension': np.radians(0),\n                'rotation': np.radians(10)  # Limited in extended position\n            },\n            'ankle': {\n                'dorsiflexion': np.radians(20),\n                'plantarflexion': np.radians(50),\n                'inversion': np.radians(35),\n                'eversion': np.radians(-35)\n            },\n            'shoulder': {\n                'flexion': np.radians(180),\n                'extension': np.radians(-60),\n                'abduction': np.radians(180),\n                'adduction': np.radians(-45),\n                'internal_rotation': np.radians(90),\n                'external_rotation': np.radians(-90)\n            }\n        }\n        return constraints\n\n    def calculate_mass_distribution(self):\n        \"\"\"Calculate mass distribution based on anthropometric data\"\"\"\n        # Standard anthropometric mass distribution percentages\n        mass_percentages = {\n            'head': 0.073,\n            'trunk': 0.507,\n            'thigh': 0.142,  # Each leg\n            'shank': 0.043,  # Each leg\n            'foot': 0.014,   # Each foot\n            'upper_arm': 0.028,  # Each arm\n            'forearm': 0.016,    # Each forearm\n            'hand': 0.007      # Each hand\n        }\n\n        # Calculate actual masses\n        masses = {key: value * self.mass for key, value in mass_percentages.items()}\n        return masses\n\n    def calculate_com_position(self, joint_angles, joint_positions):\n        \"\"\"Calculate whole-body CoM based on joint configuration\"\"\"\n        # This would require full kinematic model and mass distribution\n        # For now, provide a simplified calculation\n        segment_masses = self.calculate_mass_distribution()\n        segment_lengths = self.segment_ratios\n\n        # Simplified CoM calculation (would need full forward kinematics in practice)\n        total_mass = sum(segment_masses.values())\n        com = np.zeros(3)\n\n        # This is a placeholder - full implementation would require\n        # forward kinematics for each body segment\n        return com\n\n    def get_recommended_actuator_specs(self):\n        \"\"\"Get recommended actuator specifications based on anthropomorphic design\"\"\"\n        # Based on human muscle forces and joint torques\n        actuator_specs = {\n            'hip': {\n                'max_torque': 300,  # Nm (approximate human hip torque)\n                'max_speed': 5.0,   # rad/s\n                'power': 1500       # W\n            },\n            'knee': {\n                'max_torque': 150,  # Nm\n                'max_speed': 6.0,   # rad/s\n                'power': 900        # W\n            },\n            'ankle': {\n                'max_torque': 100,  # Nm\n                'max_speed': 8.0,   # rad/s\n                'power': 800        # W\n            },\n            'shoulder': {\n                'max_torque': 80,   # Nm\n                'max_speed': 10.0,  # rad/s\n                'power': 800        # W\n            }\n        }\n        return actuator_specs\n\n# Example: Design anthropomorphic robot\nanthro_design = AnthropomorphicDesign(height=1.7)\n\nprint(f\"Segment lengths for {anthro_design.height}m tall robot:\")\nfor segment, length in anthro_design.segment_ratios.items():\n    print(f\"  {segment}: {length:.3f} m\")\n\nprint(f\"\\nMass distribution:\")\nsegment_masses = anthro_design.calculate_mass_distribution()\nfor segment, mass in segment_masses.items():\n    print(f\"  {segment}: {mass:.2f} kg\")\n\nprint(f\"\\nRecommended actuator specifications:\")\nactuator_specs = anthro_design.get_recommended_actuator_specs()\nfor joint, specs in actuator_specs.items():\n    print(f\"  {joint}: {specs['max_torque']} Nm, {specs['max_speed']} rad/s, {specs['power']} W\")\n"})}),"\n",(0,o.jsx)(e.h2,{id:"locomotion-energetics",children:"Locomotion Energetics"}),"\n",(0,o.jsx)(e.h3,{id:"mechanical-work-and-energy",children:"Mechanical Work and Energy"}),"\n",(0,o.jsx)(e.p,{children:"Understanding the energy requirements of locomotion:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:"class LocomotionEnergetics:\n    def __init__(self, robot_mass=70.0):\n        self.mass = robot_mass\n        self.gravity = 9.81\n\n    def step_to_step_transition_energy(self, step_length, step_height):\n        \"\"\"Calculate energy for step-to-step transition (collisional losses)\"\"\"\n        # Energy lost during step transition due to impulsive forces\n        # This is an approximation based on compass gait model\n        energy_loss = 0.5 * self.mass * self.gravity * step_height\n        return energy_loss\n\n    def center_of_mass_work(self, com_trajectory):\n        \"\"\"Calculate mechanical work done on CoM\"\"\"\n        work = 0.0\n        for i in range(1, len(com_trajectory)):\n            # Calculate velocity change\n            v1 = (com_trajectory[i] - com_trajectory[i-1]) / 0.01  # dt = 0.01s\n            if i > 1:\n                v0 = (com_trajectory[i-1] - com_trajectory[i-2]) / 0.01\n                delta_v = v1 - v0\n                # Work = F * d = m * a * d = m * (dv/dt) * d\n                work += self.mass * np.linalg.norm(delta_v) * np.linalg.norm(com_trajectory[i] - com_trajectory[i-1])\n        return work\n\n    def calculate_metabolic_cost(self, walking_speed, step_frequency):\n        \"\"\"Calculate approximate metabolic cost of transport\"\"\"\n        # Based on human locomotion data\n        # Cost of transport (COT) = metabolic energy / (body_weight * distance)\n        # For humans: COT \u2248 1.0 J/(kg*m) at optimal speed\n\n        # Speed-dependent COT with optimal around 1.3 m/s\n        optimal_speed = 1.3\n        speed_factor = 1.0 + 0.5 * ((walking_speed - optimal_speed) / optimal_speed)**2\n\n        # Calculate COT\n        cot = 1.0 * speed_factor  # J/(kg*m)\n\n        # Total metabolic energy for distance\n        distance = walking_speed * 10  # Energy for 10 seconds of walking\n        metabolic_energy = cot * self.mass * self.gravity * distance\n\n        return metabolic_energy, cot\n\n    def pendular_energy_exchange(self, com_height_trajectory):\n        \"\"\"Calculate pendular energy exchange during walking\"\"\"\n        # During walking, potential and kinetic energy are exchanged\n        # This reduces the mechanical work required\n\n        potential_energy = self.mass * self.gravity * com_height_trajectory\n        # Kinetic energy would require velocity information\n        # This is a simplified analysis\n\n        # Calculate energy fluctuations\n        pe_max = np.max(potential_energy)\n        pe_min = np.min(potential_energy)\n        pe_fluctuation = pe_max - pe_min\n\n        # Energy recovery ratio (how much energy is exchanged vs. replaced)\n        # In human walking: ~60-70% energy recovery\n        energy_recovery_ratio = 0.65  # Typical human value\n\n        return pe_fluctuation, energy_recovery_ratio\n\n    def compare_locomotion_modes(self, distance=100):\n        \"\"\"Compare energy costs of different locomotion modes\"\"\"\n        modes = {\n            'walking': {'speed': 1.3, 'cost_per_meter': 1.0},  # J/kg/m\n            'running': {'speed': 3.0, 'cost_per_meter': 3.0},  # Higher cost\n            'crawling': {'speed': 0.5, 'cost_per_meter': 5.0}, # Much higher cost\n            'wheelchair': {'speed': 1.0, 'cost_per_meter': 0.5} # Lower cost, but not bipedal\n        }\n\n        results = {}\n        for mode, params in modes.items():\n            time = distance / params['speed']\n            energy = params['cost_per_meter'] * self.mass * distance\n            power = energy / time\n\n            results[mode] = {\n                'time': time,\n                'energy': energy,\n                'power': power,\n                'speed': params['speed']\n            }\n\n        return results\n\n# Example: Analyze locomotion energetics\nenergetics = LocomotionEnergetics(robot_mass=70.0)\n\n# Calculate metabolic cost for different speeds\nspeeds = [0.5, 1.0, 1.3, 1.5, 2.0]\nprint(\"Metabolic cost analysis:\")\nfor speed in speeds:\n    energy, cot = energetics.calculate_metabolic_cost(speed, 1.0)\n    print(f\"Speed {speed} m/s: COT = {cot:.2f} J/(kg*m), Energy for 10s = {energy:.1f} J\")\n\n# Compare locomotion modes\nmode_comparison = energetics.compare_locomotion_modes(distance=100)\nprint(f\"\\nEnergy comparison for 100m travel:\")\nfor mode, data in mode_comparison.items():\n    print(f\"{mode:12s}: {data['energy']:6.0f} J, {data['time']:5.1f}s, {data['power']:5.1f}W\")\n"})}),"\n",(0,o.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(e.p,{children:"The biomechanics of humanoid locomotion provide the fundamental understanding needed to design and control bipedal robots. By studying human movement patterns, researchers can develop more natural, efficient, and stable walking algorithms. The key concepts of Center of Mass control, Zero-Moment Point theory, and inverted pendulum dynamics form the foundation for dynamic balance in humanoid robots."}),"\n",(0,o.jsx)(e.p,{children:"The anthropomorphic design principles ensure that robots have proportions and capabilities similar to humans, enabling them to navigate human environments effectively. Understanding the energetics of locomotion helps in designing energy-efficient systems that can operate for extended periods."}),"\n",(0,o.jsx)(e.p,{children:"The next section will explore dynamic walking and balance control strategies that implement these biomechanical principles in real robotic systems."})]})}function m(n={}){const{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var i=t(6540);const o={},a=i.createContext(o);function s(n){const e=i.useContext(a);return i.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:s(n.components),i.createElement(a.Provider,{value:e},n.children)}}}]);