"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[169],{3095:(n,i,e)=>{e.r(i),e.d(i,{assets:()=>l,contentTitle:()=>r,default:()=>h,frontMatter:()=>s,metadata:()=>o,toc:()=>c});const o=JSON.parse('{"id":"module-2-humanoid-control/kinematics","title":"Humanoid Kinematics: Forward and Inverse Kinematics","description":"Introduction: The Geometry of Movement","source":"@site/docs/module-2-humanoid-control/kinematics.md","sourceDirName":"module-2-humanoid-control","slug":"/module-2-humanoid-control/kinematics","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/kinematics","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-humanoid-control/kinematics.md","tags":[],"version":"current","frontMatter":{},"sidebar":"textbookSidebar","previous":{"title":"Physical AI: The Foundation of Embodied Intelligence","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/physical-ai-foundations"},"next":{"title":"Dynamics and Control: Motion Planning for Humanoid Systems","permalink":"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/dynamics-control"}}');var t=e(4848),a=e(8453);const s={},r="Humanoid Kinematics: Forward and Inverse Kinematics",l={},c=[{value:"Introduction: The Geometry of Movement",id:"introduction-the-geometry-of-movement",level:2},{value:"Why Kinematics Matters for Humanoid Robots",id:"why-kinematics-matters-for-humanoid-robots",level:3},{value:"Forward Kinematics: From Joints to Position",id:"forward-kinematics-from-joints-to-position",level:2},{value:"Mathematical Foundation: Denavit-Hartenberg Parameters",id:"mathematical-foundation-denavit-hartenberg-parameters",level:3},{value:"Homogeneous Transformation Matrices",id:"homogeneous-transformation-matrices",level:3},{value:"Python Implementation Example",id:"python-implementation-example",level:3},{value:"Inverse Kinematics: From Position to Joints",id:"inverse-kinematics-from-position-to-joints",level:2},{value:"Analytical vs. Numerical Methods",id:"analytical-vs-numerical-methods",level:3},{value:"Jacobian-Based IK",id:"jacobian-based-ik",level:3},{value:"Python Implementation: Jacobian Transpose Method",id:"python-implementation-jacobian-transpose-method",level:3},{value:"Humanoid-Specific Considerations",id:"humanoid-specific-considerations",level:2},{value:"Multi-Chain Kinematics",id:"multi-chain-kinematics",level:3},{value:"Redundancy Resolution",id:"redundancy-resolution",level:3},{value:"Balance-Aware Kinematics",id:"balance-aware-kinematics",level:3},{value:"Practical Applications in Humanoid Control",id:"practical-applications-in-humanoid-control",level:2},{value:"Walking Pattern Generation",id:"walking-pattern-generation",level:3},{value:"Manipulation Tasks",id:"manipulation-tasks",level:3},{value:"Conclusion",id:"conclusion",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(i.header,{children:(0,t.jsx)(i.h1,{id:"humanoid-kinematics-forward-and-inverse-kinematics",children:"Humanoid Kinematics: Forward and Inverse Kinematics"})}),"\n",(0,t.jsx)(i.h2,{id:"introduction-the-geometry-of-movement",children:"Introduction: The Geometry of Movement"}),"\n",(0,t.jsx)(i.p,{children:"Kinematics is the study of motion without considering the forces that cause it. In humanoid robotics, kinematics provides the mathematical framework for understanding how joint angles relate to end-effector positions and how to plan movements through space. This section covers both forward kinematics (predicting position from joint angles) and inverse kinematics (determining joint angles for desired positions) - fundamental concepts for controlling humanoid robots."}),"\n",(0,t.jsx)(i.h3,{id:"why-kinematics-matters-for-humanoid-robots",children:"Why Kinematics Matters for Humanoid Robots"}),"\n",(0,t.jsx)(i.p,{children:"Humanoid robots are complex kinematic chains with multiple degrees of freedom (DOF) arranged in a human-like structure. Understanding kinematics is crucial because:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Redundancy"}),": Humanoid robots often have more joints than strictly necessary to reach a position, providing flexibility in motion planning"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Balance"}),": Maintaining balance requires coordinated movement of multiple limbs and the torso"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Obstacle Avoidance"}),": Kinematic constraints must be considered when planning paths around obstacles"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Workspace Analysis"}),": Understanding the reachable workspace helps in task planning"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"forward-kinematics-from-joints-to-position",children:"Forward Kinematics: From Joints to Position"}),"\n",(0,t.jsx)(i.p,{children:"Forward kinematics calculates the position and orientation of the end-effector (e.g., hand or foot) given the joint angles. For humanoid robots, this involves multiple kinematic chains."}),"\n",(0,t.jsx)(i.h3,{id:"mathematical-foundation-denavit-hartenberg-parameters",children:"Mathematical Foundation: Denavit-Hartenberg Parameters"}),"\n",(0,t.jsx)(i.p,{children:"The Denavit-Hartenberg (DH) convention provides a systematic way to define coordinate frames for each joint in a kinematic chain:"}),"\n",(0,t.jsxs)(i.ol,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Z-axis"}),": Aligned with the joint axis of rotation or translation"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"X-axis"}),": Perpendicular to both the current and previous z-axes"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Y-axis"}),": Completes the right-handed coordinate system"]}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:["For each joint ",(0,t.jsx)(i.code,{children:"i"}),", four parameters define the transformation:"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"a_i"}),": Link length (distance along x_i from z_(i-1) to z_i)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"\u03b1_i"}),": Link twist (angle from z_(i-1) to z_i about x_i)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"d_i"}),": Link offset (distance along z_(i-1) from x_(i-1) to x_i)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"\u03b8_i"}),": Joint angle (angle from x_(i-1) to x_i about z_(i-1))"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"homogeneous-transformation-matrices",children:"Homogeneous Transformation Matrices"}),"\n",(0,t.jsx)(i.p,{children:"Each joint transformation is represented by a 4x4 homogeneous transformation matrix:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"T_i = [\n    cos(\u03b8_i)   -sin(\u03b8_i)*cos(\u03b1_i)   sin(\u03b8_i)*sin(\u03b1_i)   a_i*cos(\u03b8_i)\n    sin(\u03b8_i)    cos(\u03b8_i)*cos(\u03b1_i)   -cos(\u03b8_i)*sin(\u03b1_i)   a_i*sin(\u03b8_i)\n    0           sin(\u03b1_i)             cos(\u03b1_i)            d_i\n    0           0                    0                   1\n]\n"})}),"\n",(0,t.jsx)(i.p,{children:"The complete transformation from base to end-effector is:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"T_total = T_1 * T_2 * ... * T_n\n"})}),"\n",(0,t.jsx)(i.h3,{id:"python-implementation-example",children:"Python Implementation Example"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import numpy as np\n\ndef dh_transform(theta, d, a, alpha):\n    """Calculate DH transformation matrix"""\n    ct, st = np.cos(theta), np.sin(theta)\n    ca, sa = np.cos(alpha), np.sin(alpha)\n\n    T = np.array([\n        [ct, -st*ca, st*sa, a*ct],\n        [st, ct*ca, -ct*sa, a*st],\n        [0, sa, ca, d],\n        [0, 0, 0, 1]\n    ])\n    return T\n\ndef forward_kinematics(joint_angles, dh_params):\n    """Calculate forward kinematics for a kinematic chain"""\n    T_total = np.eye(4)\n\n    for i, theta in enumerate(joint_angles):\n        d, a, alpha = dh_params[i]\n        T_i = dh_transform(theta, d, a, alpha)\n        T_total = np.dot(T_total, T_i)\n\n    return T_total\n\n# Example: Simple 2-DOF planar arm\njoint_angles = [np.pi/4, np.pi/6]  # 45\xb0 and 30\xb0\ndh_params = [\n    (0, 1.0, 0),    # Joint 1: d=0, a=1.0, alpha=0\n    (0, 1.0, 0)     # Joint 2: d=0, a=1.0, alpha=0\n]\n\nend_effector_pose = forward_kinematics(joint_angles, dh_params)\nprint(f"End-effector pose:\\n{end_effector_pose}")\n'})}),"\n",(0,t.jsx)(i.h2,{id:"inverse-kinematics-from-position-to-joints",children:"Inverse Kinematics: From Position to Joints"}),"\n",(0,t.jsx)(i.p,{children:"Inverse kinematics (IK) determines the joint angles required to achieve a desired end-effector position and orientation. This is typically more challenging than forward kinematics and may have multiple solutions or no solution."}),"\n",(0,t.jsx)(i.h3,{id:"analytical-vs-numerical-methods",children:"Analytical vs. Numerical Methods"}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Analytical Methods"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Provide exact solutions when they exist"}),"\n",(0,t.jsx)(i.li,{children:"Computationally efficient"}),"\n",(0,t.jsx)(i.li,{children:"Limited to specific kinematic structures (e.g., 6-DOF with intersecting wrist)"}),"\n"]}),"\n",(0,t.jsxs)(i.p,{children:[(0,t.jsx)(i.strong,{children:"Numerical Methods"}),":"]}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Applicable to arbitrary kinematic structures"}),"\n",(0,t.jsx)(i.li,{children:"Iterative approaches that converge to solutions"}),"\n",(0,t.jsx)(i.li,{children:"Can handle redundant systems"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"jacobian-based-ik",children:"Jacobian-Based IK"}),"\n",(0,t.jsx)(i.p,{children:"The Jacobian matrix relates joint velocities to end-effector velocities:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"v_ee = J(q) * q_dot\n"})}),"\n",(0,t.jsx)(i.p,{children:"Where:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"v_ee"})," is the end-effector velocity vector"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"J(q)"})," is the Jacobian matrix"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.code,{children:"q_dot"})," is the joint velocity vector"]}),"\n"]}),"\n",(0,t.jsx)(i.p,{children:"To solve for joint angles:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"q_dot = J^(-1) * v_ee\n"})}),"\n",(0,t.jsx)(i.p,{children:"For redundant systems (more joints than necessary), we use the pseudoinverse:"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{children:"q_dot = J^+ * v_ee\n"})}),"\n",(0,t.jsx)(i.h3,{id:"python-implementation-jacobian-transpose-method",children:"Python Implementation: Jacobian Transpose Method"}),"\n",(0,t.jsx)(i.pre,{children:(0,t.jsx)(i.code,{className:"language-python",children:'import numpy as np\n\ndef jacobian_transpose(robot, joint_angles, target_pos, end_effector_link):\n    """Calculate joint angles using Jacobian transpose method"""\n    max_iterations = 100\n    step_size = 0.01\n    tolerance = 0.001\n\n    for i in range(max_iterations):\n        current_pos = forward_kinematics(robot, joint_angles)[0:3, 3]\n        error = target_pos - current_pos\n\n        if np.linalg.norm(error) < tolerance:\n            break\n\n        # Calculate Jacobian (simplified for this example)\n        J = calculate_jacobian(robot, joint_angles, end_effector_link)\n\n        # Jacobian transpose method\n        joint_delta = step_size * np.dot(J.T, error)\n        joint_angles += joint_delta\n\n    return joint_angles\n\ndef calculate_jacobian(robot, joint_angles, end_effector_link):\n    """Calculate the geometric Jacobian matrix"""\n    n_joints = len(joint_angles)\n    J = np.zeros((6, n_joints))  # 6 DOF: 3 translational, 3 rotational\n\n    # Get current end-effector position\n    T_end = forward_kinematics(robot, joint_angles)\n    end_pos = T_end[0:3, 3]\n\n    # Calculate for each joint\n    for i in range(n_joints):\n        # Get joint position and axis\n        T_joint = forward_kinematics(robot, joint_angles[:i+1])\n        joint_pos = T_joint[0:3, 3]\n        joint_axis = T_joint[0:3, 2]  # z-axis of joint frame\n\n        # Linear velocity component\n        r = end_pos - joint_pos\n        J[0:3, i] = np.cross(joint_axis, r)\n\n        # Angular velocity component\n        J[3:6, i] = joint_axis\n\n    return J\n'})}),"\n",(0,t.jsx)(i.h2,{id:"humanoid-specific-considerations",children:"Humanoid-Specific Considerations"}),"\n",(0,t.jsx)(i.h3,{id:"multi-chain-kinematics",children:"Multi-Chain Kinematics"}),"\n",(0,t.jsx)(i.p,{children:"Humanoid robots have multiple kinematic chains (arms, legs) that must be coordinated:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Whole-Body IK"}),": Solving IK for all chains simultaneously to maintain balance and coordination"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Task Prioritization"}),": Handling multiple simultaneous tasks (e.g., reaching while maintaining balance)"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Constraint Handling"}),": Maintaining joint limits and avoiding self-collisions"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"redundancy-resolution",children:"Redundancy Resolution"}),"\n",(0,t.jsx)(i.p,{children:"Humanoid robots are typically redundant (more DOF than task requirements), requiring strategies to resolve redundancy:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Null Space Projection"}),": Maintaining secondary objectives while achieving primary tasks"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Joint Centering"}),": Keeping joints near neutral positions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Obstacle Avoidance"}),": Using redundancy to avoid collisions"]}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"balance-aware-kinematics",children:"Balance-Aware Kinematics"}),"\n",(0,t.jsx)(i.p,{children:"Humanoid kinematics must consider balance constraints:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Zero-Moment Point (ZMP)"}),": Ensuring the robot's center of pressure remains within the support polygon"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Center of Mass (CoM)"}),": Maintaining CoM within stable regions"]}),"\n",(0,t.jsxs)(i.li,{children:[(0,t.jsx)(i.strong,{children:"Support Polygon"}),": Defining stable foot positions for single/double support"]}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"practical-applications-in-humanoid-control",children:"Practical Applications in Humanoid Control"}),"\n",(0,t.jsx)(i.h3,{id:"walking-pattern-generation",children:"Walking Pattern Generation"}),"\n",(0,t.jsx)(i.p,{children:"Walking involves complex kinematic coordination:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Swing leg trajectory planning"}),"\n",(0,t.jsx)(i.li,{children:"Stance leg support"}),"\n",(0,t.jsx)(i.li,{children:"Pelvis and trunk coordination"}),"\n",(0,t.jsx)(i.li,{children:"Arm swing for balance"}),"\n"]}),"\n",(0,t.jsx)(i.h3,{id:"manipulation-tasks",children:"Manipulation Tasks"}),"\n",(0,t.jsx)(i.p,{children:"Humanoid manipulation requires:"}),"\n",(0,t.jsxs)(i.ul,{children:["\n",(0,t.jsx)(i.li,{children:"Reaching motion planning"}),"\n",(0,t.jsx)(i.li,{children:"Grasp pose optimization"}),"\n",(0,t.jsx)(i.li,{children:"Dual-arm coordination"}),"\n",(0,t.jsx)(i.li,{children:"Whole-body motion planning"}),"\n"]}),"\n",(0,t.jsx)(i.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,t.jsx)(i.p,{children:"Kinematics provides the mathematical foundation for understanding and controlling humanoid robot motion. Forward kinematics enables prediction of robot positions from joint angles, while inverse kinematics allows for task-space control by determining required joint angles. For humanoid robots, the complexity of multi-chain systems, redundancy, and balance constraints make kinematic control particularly challenging but essential for achieving human-like movement capabilities."}),"\n",(0,t.jsx)(i.p,{children:"The next section will explore dynamics and control, which considers the forces and torques required to achieve these movements while accounting for the physics of motion."})]})}function h(n={}){const{wrapper:i}={...(0,a.R)(),...n.components};return i?(0,t.jsx)(i,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},8453:(n,i,e)=>{e.d(i,{R:()=>s,x:()=>r});var o=e(6540);const t={},a=o.createContext(t);function s(n){const i=o.useContext(a);return o.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function r(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:s(n.components),o.createElement(a.Provider,{value:i},n.children)}}}]);