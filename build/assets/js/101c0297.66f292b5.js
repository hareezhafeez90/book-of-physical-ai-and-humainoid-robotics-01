"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[534],{7025:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>i,default:()=>p,frontMatter:()=>r,metadata:()=>c,toc:()=>l});var a=t(4848),s=t(8453);const r={},i="Tactile Sensing and Haptic Feedback",c={id:"module-3-perception-sensing/tactile-sensing",title:"Tactile Sensing and Haptic Feedback",description:"Introduction: The Sense of Touch in Humanoid Robotics",source:"@site/docs/module-3-perception-sensing/tactile-sensing.md",sourceDirName:"module-3-perception-sensing",slug:"/module-3-perception-sensing/tactile-sensing",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-3-perception-sensing/tactile-sensing",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3-perception-sensing/tactile-sensing.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Computer Vision for Humanoid Robots",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-3-perception-sensing/computer-vision"},next:{title:"Inertial and Proprioceptive Sensing",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-3-perception-sensing/inertial-sensing"}},o={},l=[{value:"Introduction: The Sense of Touch in Humanoid Robotics",id:"introduction-the-sense-of-touch-in-humanoid-robotics",level:2},{value:"The Importance of Touch in Humanoid Interaction",id:"the-importance-of-touch-in-humanoid-interaction",level:3},{value:"Tactile Sensor Technologies",id:"tactile-sensor-technologies",level:2},{value:"Resistive Tactile Sensors",id:"resistive-tactile-sensors",level:3},{value:"Capacitive Tactile Sensors",id:"capacitive-tactile-sensors",level:3},{value:"Piezoelectric Tactile Sensors",id:"piezoelectric-tactile-sensors",level:3},{value:"Advanced Tactile Processing",id:"advanced-tactile-processing",level:2},{value:"Tactile Feature Extraction",id:"tactile-feature-extraction",level:3},{value:"Tactile-Based Object Recognition",id:"tactile-based-object-recognition",level:3},{value:"Haptic Feedback Systems",id:"haptic-feedback-systems",level:2},{value:"Vibrotactile Feedback",id:"vibrotactile-feedback",level:3},{value:"Force Feedback Systems",id:"force-feedback-systems",level:3},{value:"Tactile-Based Control",id:"tactile-based-control",level:2},{value:"Tactile Feedback in Grasping Control",id:"tactile-feedback-in-grasping-control",level:3},{value:"Integration with ROS 2",id:"integration-with-ros-2",level:2},{value:"ROS 2 Tactile Sensing Node",id:"ros-2-tactile-sensing-node",level:3},{value:"Conclusion",id:"conclusion",level:2}];function _(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"tactile-sensing-and-haptic-feedback",children:"Tactile Sensing and Haptic Feedback"}),"\n",(0,a.jsx)(n.h2,{id:"introduction-the-sense-of-touch-in-humanoid-robotics",children:"Introduction: The Sense of Touch in Humanoid Robotics"}),"\n",(0,a.jsx)(n.p,{children:"Tactile sensing provides humanoid robots with the ability to perceive physical contact, pressure, texture, and temperature, enabling them to interact safely and effectively with objects and humans. Unlike vision systems that provide information from a distance, tactile sensors offer direct physical interaction feedback that is essential for manipulation, balance, and safe human-robot interaction. This section explores tactile sensing technologies, haptic feedback systems, and their integration into humanoid robots."}),"\n",(0,a.jsx)(n.h3,{id:"the-importance-of-touch-in-humanoid-interaction",children:"The Importance of Touch in Humanoid Interaction"}),"\n",(0,a.jsx)(n.p,{children:"Tactile sensing is crucial for humanoid robots because:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Safe Interaction"}),": Detecting contact prevents damage to robot and environment"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fine Manipulation"}),": Tactile feedback enables precise grasping and manipulation"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Balance Recovery"}),": Foot tactile sensors help maintain stability"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Human-Robot Interaction"}),": Touch-based communication and safety"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Texture Recognition"}),": Understanding object properties through touch"]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"tactile-sensor-technologies",children:"Tactile Sensor Technologies"}),"\n",(0,a.jsx)(n.h3,{id:"resistive-tactile-sensors",children:"Resistive Tactile Sensors"}),"\n",(0,a.jsx)(n.p,{children:"Resistive sensors change resistance when pressure is applied:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class ResistiveTactileSensor:\n    def __init__(self, sensor_id, num_taxels=64, max_pressure=100.0):\n        self.sensor_id = sensor_id\n        self.num_taxels = num_taxels\n        self.max_pressure = max_pressure  # Maximum pressure in N/m^2\n        self.base_resistance = 10000  # Base resistance in ohms\n        self.pressure_sensitivity = 0.1  # Change in resistance per unit pressure\n        self.taxel_positions = self._initialize_taxel_positions()\n\n        # Initialize sensor readings\n        self.pressure_map = np.zeros(num_taxels)\n        self.resistance_map = np.full(num_taxels, self.base_resistance)\n        self.temperature = 25.0  # Default temperature in Celsius\n\n    def _initialize_taxel_positions(self):\n        """Initialize positions of taxels in 2D grid"""\n        # For a 8x8 grid (64 taxels)\n        positions = []\n        for i in range(8):\n            for j in range(8):\n                positions.append((i * 0.01, j * 0.01))  # 1cm spacing\n        return np.array(positions)\n\n    def update_from_physical_model(self, applied_pressures):\n        """Update sensor readings based on applied pressures"""\n        if len(applied_pressures) != self.num_taxels:\n            raise ValueError("Applied pressures must match number of taxels")\n\n        self.pressure_map = np.clip(applied_pressures, 0, self.max_pressure)\n\n        # Calculate resistance based on pressure (simplified model)\n        # Resistance decreases with increasing pressure\n        self.resistance_map = self.base_resistance / (1 + self.pressure_sensitivity * self.pressure_map)\n\n        # Convert to sensor readings (e.g., ADC values)\n        adc_values = self._resistance_to_adc(self.resistance_map)\n        return adc_values\n\n    def _resistance_to_adc(self, resistances):\n        """Convert resistance values to ADC readings"""\n        # Simple voltage divider model\n        v_ref = 3.3  # Reference voltage\n        r_pullup = 10000  # Pull-up resistor in ohms\n        adc_resolution = 4096  # 12-bit ADC\n\n        # Voltage divider: V_out = V_ref * R_sensor / (R_pullup + R_sensor)\n        voltages = v_ref * resistances / (r_pullup + resistances)\n        adc_values = (voltages / v_ref) * adc_resolution\n\n        return adc_values.astype(int)\n\n    def get_contact_info(self, threshold=0.5):\n        """Get information about contact points above threshold"""\n        contact_indices = np.where(self.pressure_map > threshold)[0]\n        contact_pressures = self.pressure_map[contact_indices]\n        contact_positions = self.taxel_positions[contact_indices]\n\n        if len(contact_indices) == 0:\n            return None\n\n        # Calculate center of pressure\n        total_force = np.sum(contact_pressures)\n        if total_force > 0:\n            cop_x = np.sum(contact_positions[:, 0] * contact_pressures) / total_force\n            cop_y = np.sum(contact_positions[:, 1] * contact_pressures) / total_force\n            center_of_pressure = (cop_x, cop_y)\n        else:\n            center_of_pressure = None\n\n        return {\n            \'contact_indices\': contact_indices,\n            \'contact_pressures\': contact_pressures,\n            \'contact_positions\': contact_positions,\n            \'center_of_pressure\': center_of_pressure,\n            \'total_force\': total_force\n        }\n\n    def detect_slip(self, time_window=0.1):\n        """Detect slip based on pressure pattern changes"""\n        # This would require temporal analysis\n        # For now, return a simplified slip detection\n        pressure_changes = np.diff(self.pressure_map) if len(self.pressure_map) > 1 else np.zeros_like(self.pressure_map)\n        rapid_changes = np.abs(pressure_changes) > 5.0  # Threshold for rapid change\n        return np.any(rapid_changes)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"capacitive-tactile-sensors",children:"Capacitive Tactile Sensors"}),"\n",(0,a.jsx)(n.p,{children:"Capacitive sensors measure changes in capacitance due to contact:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class CapacitiveTactileSensor:\n    def __init__(self, sensor_id, num_taxels=64):\n        self.sensor_id = sensor_id\n        self.num_taxels = num_taxels\n        self.base_capacitance = np.full(num_taxels, 10e-12)  # 10 pF base capacitance\n        self.pressure_coefficient = 1e-12  # Capacitance change per unit pressure\n        self.frequency = 1e6  # 1 MHz measurement frequency\n        self.temperature_coefficient = 1e-15  # Capacitance change per degree Celsius\n\n        # Initialize sensor state\n        self.current_capacitance = self.base_capacitance.copy()\n        self.pressure_map = np.zeros(num_taxels)\n        self.temperature = 25.0\n        self.taxel_positions = self._initialize_taxel_positions()\n\n    def _initialize_taxel_positions(self):\n        """Initialize taxel positions"""\n        positions = []\n        for i in range(8):\n            for j in range(8):\n                positions.append((i * 0.008, j * 0.008))  # 8mm spacing\n        return np.array(positions)\n\n    def update_from_contact(self, applied_pressures, temperature=None):\n        """Update sensor readings based on applied pressures and temperature"""\n        if temperature is not None:\n            self.temperature = temperature\n\n        self.pressure_map = np.clip(applied_pressures, 0, 100.0)  # 0-100 N/m^2\n\n        # Calculate capacitance changes due to pressure\n        pressure_effect = self.pressure_coefficient * self.pressure_map\n\n        # Calculate temperature effect\n        temp_effect = self.temperature_coefficient * (self.temperature - 25.0)\n\n        # Total capacitance\n        self.current_capacitance = self.base_capacitance + pressure_effect + temp_effect\n\n        # Convert to measurement values (e.g., frequency shift)\n        measurement_values = self._capacitance_to_frequency(self.current_capacitance)\n        return measurement_values\n\n    def _capacitance_to_frequency(self, capacitances):\n        """Convert capacitance to frequency for measurement"""\n        # Simple oscillator model: f = 1 / (2 * pi * sqrt(L * C))\n        # For simplicity, assume fixed inductance\n        l = 1e-6  # 1 \u03bcH inductor\n        frequencies = 1 / (2 * np.pi * np.sqrt(l * capacitances))\n        return frequencies\n\n    def get_tactile_image(self):\n        """Generate tactile image from pressure distribution"""\n        # Reshape 1D pressure array to 2D grid\n        tactile_image = self.pressure_map.reshape(8, 8)\n        return tactile_image\n\n    def detect_object_properties(self):\n        """Detect object properties from tactile data"""\n        # Calculate contact area\n        contact_threshold = 0.1  # Minimum pressure for contact\n        contact_map = self.pressure_map > contact_threshold\n        contact_area = np.sum(contact_map)\n\n        # Calculate pressure distribution statistics\n        active_pressures = self.pressure_map[contact_map]\n        if len(active_pressures) > 0:\n            avg_pressure = np.mean(active_pressures)\n            max_pressure = np.max(active_pressures)\n            pressure_variance = np.var(active_pressures)\n\n            # Estimate object compliance (softness)\n            # Higher variance may indicate texture or softness\n            compliance_estimate = pressure_variance / (max_pressure + 1e-6)\n        else:\n            avg_pressure = 0\n            max_pressure = 0\n            pressure_variance = 0\n            compliance_estimate = 0\n\n        return {\n            \'contact_area\': contact_area,\n            \'avg_pressure\': avg_pressure,\n            \'max_pressure\': max_pressure,\n            \'pressure_variance\': pressure_variance,\n            \'compliance_estimate\': compliance_estimate\n        }\n\n    def estimate_surface_roughness(self, window_size=3):\n        """Estimate surface roughness from pressure variations"""\n        if self.pressure_map.size < window_size**2:\n            return 0\n\n        # Reshape to 2D for spatial analysis\n        tactile_2d = self.pressure_map.reshape(8, 8)\n\n        # Calculate local pressure variations\n        roughness_measure = 0\n        for i in range(0, 8 - window_size + 1, window_size):\n            for j in range(0, 8 - window_size + 1, window_size):\n                window = tactile_2d[i:i+window_size, j:j+window_size]\n                if np.any(window > 0.1):  # Only consider areas with contact\n                    local_variance = np.var(window)\n                    roughness_measure += local_variance\n\n        return roughness_measure / ((8 // window_size) ** 2 + 1e-6)\n'})}),"\n",(0,a.jsx)(n.h3,{id:"piezoelectric-tactile-sensors",children:"Piezoelectric Tactile Sensors"}),"\n",(0,a.jsx)(n.p,{children:"Piezoelectric sensors generate voltage when mechanically stressed:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class PiezoelectricTactileSensor:\n    def __init__(self, sensor_id, num_taxels=64):\n        self.sensor_id = sensor_id\n        self.num_taxels = num_taxels\n        self.piezoelectric_coefficient = 2.3e-11  # C/N (for quartz)\n        self.capacitance = 100e-12  # 100 pF\n        self.resistance = 1e9  # 1 G\u03a9 leakage resistance\n\n        # Initialize sensor state\n        self.charge = np.zeros(num_taxels)\n        self.voltage = np.zeros(num_taxels)\n        self.pressure_history = [np.zeros(num_taxels) for _ in range(10)]  # 10 time steps\n        self.time_step = 0.001  # 1ms time step\n\n    def apply_force(self, forces, dt=0.001):\n        \"\"\"Apply forces and update sensor readings\"\"\"\n        # Generate charge based on applied force\n        charge_generated = self.piezoelectric_coefficient * forces\n\n        # Account for charge leakage\n        charge_leakage = self.charge * dt / (self.resistance * self.capacitance)\n        self.charge = self.charge - charge_leakage + charge_generated\n\n        # Calculate voltage\n        self.voltage = self.charge / self.capacitance\n\n        # Update pressure history for dynamic analysis\n        self.pressure_history.pop(0)\n        self.pressure_history.append(forces.copy())\n\n        return self.voltage\n\n    def detect_dynamic_events(self):\n        \"\"\"Detect dynamic events like impacts or vibrations\"\"\"\n        # Analyze pressure history for dynamic events\n        if len(self.pressure_history) < 3:\n            return []\n\n        events = []\n        for i in range(self.num_taxels):\n            # Calculate pressure derivative (rate of change)\n            recent_pressures = [h[i] for h in self.pressure_history[-3:]]\n            pressure_rate = np.diff(recent_pressures)\n\n            # Detect impacts (high rate of change)\n            if len(pressure_rate) > 0 and abs(pressure_rate[-1]) > 10:  # Threshold\n                events.append({\n                    'taxel': i,\n                    'type': 'impact',\n                    'magnitude': abs(pressure_rate[-1]),\n                    'timestamp': time.time()\n                })\n\n            # Detect vibrations (oscillatory behavior)\n            if len(recent_pressures) >= 3:\n                # Simple vibration detection using variance\n                variance = np.var(recent_pressures)\n                if variance > 5:  # Threshold for vibration\n                    events.append({\n                        'taxel': i,\n                        'type': 'vibration',\n                        'magnitude': variance,\n                        'timestamp': time.time()\n                    })\n\n        return events\n\n    def get_force_reconstruction(self):\n        \"\"\"Reconstruct applied forces from sensor readings\"\"\"\n        # Invert the piezoelectric relationship\n        # F = Q / d (where d is piezoelectric coefficient)\n        forces = self.charge / self.piezoelectric_coefficient\n        return forces\n"})}),"\n",(0,a.jsx)(n.h2,{id:"advanced-tactile-processing",children:"Advanced Tactile Processing"}),"\n",(0,a.jsx)(n.h3,{id:"tactile-feature-extraction",children:"Tactile Feature Extraction"}),"\n",(0,a.jsx)(n.p,{children:"Extracting meaningful features from tactile data:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"class TactileFeatureExtractor:\n    def __init__(self):\n        self.feature_history = deque(maxlen=50)\n\n    def extract_basic_features(self, tactile_data):\n        \"\"\"Extract basic tactile features\"\"\"\n        features = {}\n\n        # Statistical features\n        features['mean_pressure'] = np.mean(tactile_data)\n        features['std_pressure'] = np.std(tactile_data)\n        features['max_pressure'] = np.max(tactile_data)\n        features['min_pressure'] = np.min(tactile_data)\n        features['pressure_range'] = features['max_pressure'] - features['min_pressure']\n\n        # Contact features\n        contact_threshold = 0.1\n        contact_mask = tactile_data > contact_threshold\n        features['contact_area'] = np.sum(contact_mask)\n        features['contact_ratio'] = np.sum(contact_mask) / len(tactile_data)\n\n        # Gradient features (for texture detection)\n        if tactile_data.ndim == 1:\n            # Reshape to 2D if needed\n            size = int(np.sqrt(len(tactile_data)))\n            tactile_2d = tactile_data.reshape(size, size)\n        else:\n            tactile_2d = tactile_data\n\n        # Calculate gradients\n        grad_x = np.gradient(tactile_2d, axis=1)\n        grad_y = np.gradient(tactile_2d, axis=0)\n        grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n\n        features['avg_gradient'] = np.mean(grad_magnitude)\n        features['max_gradient'] = np.max(grad_magnitude)\n\n        return features\n\n    def extract_texture_features(self, tactile_sequence):\n        \"\"\"Extract texture features from tactile sequence\"\"\"\n        if len(tactile_sequence) < 2:\n            return {}\n\n        features = {}\n\n        # Temporal features\n        pressure_changes = np.diff(tactile_sequence, axis=0)\n        features['avg_temporal_change'] = np.mean(np.abs(pressure_changes))\n        features['max_temporal_change'] = np.max(np.abs(pressure_changes))\n\n        # Frequency domain features\n        if len(tactile_sequence) > 10:\n            # Perform FFT on average pressure over time\n            avg_pressure_over_time = np.mean(tactile_sequence, axis=1)\n            fft_result = np.fft.fft(avg_pressure_over_time)\n            fft_magnitude = np.abs(fft_result)\n\n            # Extract dominant frequencies\n            dominant_freq_idx = np.argmax(fft_magnitude[1:len(fft_magnitude)//2]) + 1\n            features['dominant_frequency'] = dominant_freq_idx\n            features['dominant_freq_magnitude'] = fft_magnitude[dominant_freq_idx]\n\n        # Spatial texture features\n        if tactile_sequence[-1].ndim == 2:\n            final_map = tactile_sequence[-1]\n            # Calculate spatial frequency content using 2D FFT\n            fft_2d = np.fft.fft2(final_map)\n            fft_2d_magnitude = np.abs(fft_2d)\n            features['spatial_frequency_content'] = np.mean(fft_2d_magnitude)\n\n        return features\n\n    def classify_material(self, tactile_features):\n        \"\"\"Classify material based on tactile features\"\"\"\n        # Simple classification based on pressure distribution\n        if tactile_features.get('std_pressure', 0) > 5.0:\n            return 'rough', 0.8\n        elif tactile_features.get('avg_gradient', 0) > 2.0:\n            return 'textured', 0.7\n        elif tactile_features.get('contact_ratio', 0) > 0.8:\n            return 'soft', 0.6\n        else:\n            return 'smooth', 0.9\n"})}),"\n",(0,a.jsx)(n.h3,{id:"tactile-based-object-recognition",children:"Tactile-Based Object Recognition"}),"\n",(0,a.jsx)(n.p,{children:"Recognizing objects through touch:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class TactileObjectRecognizer:\n    def __init__(self):\n        self.known_objects = {}\n        self.feature_extractor = TactileFeatureExtractor()\n\n    def register_object(self, object_name, tactile_sequence):\n        """Register a known object with its tactile signature"""\n        # Extract features from the tactile sequence\n        features = self.feature_extractor.extract_basic_features(tactile_sequence[-1])\n        temporal_features = self.feature_extractor.extract_texture_features(tactile_sequence)\n\n        self.known_objects[object_name] = {\n            \'static_features\': features,\n            \'temporal_features\': temporal_features,\n            \'tactile_sequence\': tactile_sequence\n        }\n\n    def recognize_object(self, tactile_sequence, threshold=0.7):\n        """Recognize object based on tactile sequence"""\n        if len(self.known_objects) == 0:\n            return None, 0.0\n\n        query_features = self.feature_extractor.extract_basic_features(tactile_sequence[-1])\n        query_temporal = self.feature_extractor.extract_texture_features(tactile_sequence)\n\n        best_match = None\n        best_score = 0.0\n\n        for obj_name, obj_data in self.known_objects.items():\n            # Compare static features\n            static_score = self._compare_features(\n                query_features, obj_data[\'static_features\']\n            )\n\n            # Compare temporal features\n            temporal_score = self._compare_features(\n                query_temporal, obj_data[\'temporal_features\'], weights={\'dominant_frequency\': 2.0}\n            )\n\n            # Combined score\n            combined_score = 0.6 * static_score + 0.4 * temporal_score\n\n            if combined_score > best_score:\n                best_score = combined_score\n                best_match = obj_name\n\n        if best_score > threshold:\n            return best_match, best_score\n        else:\n            return None, best_score\n\n    def _compare_features(self, features1, features2, weights=None):\n        """Compare two feature dictionaries"""\n        if weights is None:\n            weights = {}\n\n        scores = []\n        for key in features1.keys():\n            if key in features2:\n                # Normalize the difference\n                val1, val2 = features1[key], features2[key]\n                max_val = max(abs(val1), abs(val2), 1e-6)\n                diff = abs(val1 - val2) / max_val\n                similarity = max(0, 1 - diff)\n\n                weight = weights.get(key, 1.0)\n                scores.append(similarity * weight)\n\n        if scores:\n            return np.mean(scores)\n        else:\n            return 0.0\n\n    def learn_object_properties(self, object_name, tactile_data):\n        """Learn object properties through tactile exploration"""\n        properties = {\n            \'compliance\': self._estimate_compliance(tactile_data),\n            \'roughness\': self._estimate_roughness(tactile_data),\n            \'thermal_conductivity\': self._estimate_thermal_props(tactile_data),\n            \'size\': self._estimate_size(tactile_data)\n        }\n\n        if object_name in self.known_objects:\n            self.known_objects[object_name][\'properties\'] = properties\n        else:\n            self.known_objects[object_name] = {\'properties\': properties}\n\n        return properties\n\n    def _estimate_compliance(self, tactile_data):\n        """Estimate object compliance from pressure distribution"""\n        # Higher pressure variance may indicate softer material\n        if tactile_data.ndim > 1:\n            tactile_flat = tactile_data.reshape(-1)\n        else:\n            tactile_flat = tactile_data\n\n        non_zero_pressures = tactile_flat[tactile_flat > 0.1]\n        if len(non_zero_pressures) > 0:\n            return np.var(non_zero_pressures) / (np.mean(non_zero_pressures) + 1e-6)\n        return 0\n\n    def _estimate_roughness(self, tactile_data):\n        """Estimate surface roughness from gradient analysis"""\n        if tactile_data.ndim == 1:\n            size = int(np.sqrt(len(tactile_data)))\n            tactile_2d = tactile_data.reshape(size, size)\n        else:\n            tactile_2d = tactile_data\n\n        grad_x = np.gradient(tactile_2d, axis=1)\n        grad_y = np.gradient(tactile_2d, axis=0)\n        grad_magnitude = np.sqrt(grad_x**2 + grad_y**2)\n        return np.mean(grad_magnitude)\n\n    def _estimate_thermal_props(self, tactile_data):\n        """Estimate thermal properties (requires thermal sensors)"""\n        # Placeholder for thermal property estimation\n        return 0.5  # Default value\n\n    def _estimate_size(self, tactile_data):\n        """Estimate object size from contact area"""\n        contact_threshold = 0.1\n        contact_map = tactile_data > contact_threshold\n        contact_area = np.sum(contact_map)\n        return contact_area\n'})}),"\n",(0,a.jsx)(n.h2,{id:"haptic-feedback-systems",children:"Haptic Feedback Systems"}),"\n",(0,a.jsx)(n.h3,{id:"vibrotactile-feedback",children:"Vibrotactile Feedback"}),"\n",(0,a.jsx)(n.p,{children:"Vibrotactile feedback provides tactile sensations through vibration:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import math\n\nclass VibrotactileFeedback:\n    def __init__(self, num_actuators=8):\n        self.num_actuators = num_actuators\n        self.actuator_positions = self._initialize_actuator_positions()\n        self.current_signals = np.zeros(num_actuators)\n        self.frequency_range = (50, 1000)  # Hz\n        self.amplitude_range = (0, 1)  # Normalized\n\n    def _initialize_actuator_positions(self):\n        \"\"\"Initialize actuator positions in 2D space\"\"\"\n        # For example, arranged in a circle on the palm\n        positions = []\n        for i in range(self.num_actuators):\n            angle = 2 * math.pi * i / self.num_actuators\n            x = 0.02 * math.cos(angle)  # 2cm radius\n            y = 0.02 * math.sin(angle)\n            positions.append((x, y))\n        return np.array(positions)\n\n    def generate_vibration_pattern(self, stimulus_type, intensity=0.5, frequency=200, duration=1.0):\n        \"\"\"Generate vibration pattern for different stimuli\"\"\"\n        time_steps = int(duration * 1000)  # 1ms time steps\n        time_vector = np.linspace(0, duration, time_steps)\n\n        if stimulus_type == 'texture':\n            # Simulate texture through amplitude modulation\n            carrier = np.sin(2 * np.pi * frequency * time_vector)\n            envelope = 1 + 0.5 * np.sin(2 * np.pi * 20 * time_vector)  # 20Hz modulation\n            signal = intensity * carrier * envelope\n\n        elif stimulus_type == 'slip':\n            # Simulate slip detection with increasing frequency\n            freq_sweep = np.linspace(frequency, frequency * 2, time_steps)\n            signal = intensity * np.sin(2 * np.pi * freq_sweep * time_vector)\n            signal = signal * np.linspace(0, 1, time_steps)  # Ramp up\n\n        elif stimulus_type == 'pressure':\n            # Simulate pressure with low frequency, high amplitude\n            signal = intensity * np.sin(2 * np.pi * 50 * time_vector)\n\n        elif stimulus_type == 'warning':\n            # Warning signal - burst pattern\n            burst_period = 0.2  # 200ms burst period\n            burst_active = (time_vector % burst_period) < (burst_period / 4)\n            carrier = np.sin(2 * np.pi * 300 * time_vector)\n            signal = intensity * carrier * burst_active.astype(float)\n\n        else:\n            # Default: simple sinusoid\n            signal = intensity * np.sin(2 * np.pi * frequency * time_vector)\n\n        return signal\n\n    def spatialize_feedback(self, stimulus_signal, contact_position):\n        \"\"\"Spatialize haptic feedback based on contact location\"\"\"\n        # Calculate distances from contact position to each actuator\n        distances = np.sqrt(np.sum((self.actuator_positions - contact_position)**2, axis=1))\n\n        # Calculate attenuation based on distance (inverse square law)\n        min_distance = np.min(distances)\n        distances = np.maximum(distances, min_distance + 0.001)  # Avoid division by zero\n        attenuation = 1 / (1 + distances / 0.01)  # 1cm reference distance\n\n        # Apply spatial attenuation to the signal\n        spatialized_signals = np.outer(stimulus_signal, attenuation)\n        return spatialized_signals\n\n    def render_haptic_feedback(self, tactile_event, contact_position):\n        \"\"\"Render appropriate haptic feedback for tactile event\"\"\"\n        if tactile_event['type'] == 'slip':\n            signal = self.generate_vibration_pattern('slip', intensity=0.8, duration=0.5)\n        elif tactile_event['type'] == 'texture_change':\n            signal = self.generate_vibration_pattern('texture', intensity=0.6, duration=0.3)\n        elif tactile_event['type'] == 'high_pressure':\n            signal = self.generate_vibration_pattern('pressure', intensity=0.9, duration=0.2)\n        elif tactile_event['type'] == 'object_edge':\n            signal = self.generate_vibration_pattern('warning', intensity=0.7, duration=0.4)\n        else:\n            signal = self.generate_vibration_pattern('texture', intensity=0.4, duration=0.1)\n\n        # Spatialize the feedback\n        spatialized_feedback = self.spatialize_feedback(signal, contact_position)\n        return spatialized_feedback\n"})}),"\n",(0,a.jsx)(n.h3,{id:"force-feedback-systems",children:"Force Feedback Systems"}),"\n",(0,a.jsx)(n.p,{children:"Force feedback provides resistance or guidance through actuators:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class ForceFeedbackSystem:\n    def __init__(self, max_force=50.0, max_torque=10.0):\n        self.max_force = max_force  # Maximum force in Newtons\n        self.max_torque = max_torque  # Maximum torque in Nm\n        self.current_force = np.zeros(3)  # 3D force vector\n        self.current_torque = np.zeros(3)  # 3D torque vector\n        self.stiffness = 1000  # N/m for virtual fixtures\n        self.damping = 50  # Ns/m for damping\n\n    def compute_virtual_fixtures_force(self, current_pos, desired_pos, boundary_type=\'plane\'):\n        """Compute force for virtual fixtures"""\n        if boundary_type == \'plane\':\n            # Virtual plane at z = 0.1m\n            distance_to_plane = current_pos[2] - 0.1\n            if distance_to_plane < 0:  # Penetrating the plane\n                force_magnitude = -self.stiffness * distance_to_plane\n                force_direction = np.array([0, 0, 1])  # Normal to plane\n                return np.clip(force_magnitude, 0, self.max_force) * force_direction\n        elif boundary_type == \'sphere\':\n            # Virtual sphere constraint\n            center = np.array([0, 0, 0.2])  # Sphere center\n            radius = 0.1  # Sphere radius\n            vector_to_center = current_pos - center\n            distance = np.linalg.norm(vector_to_center)\n            if distance > radius:  # Outside sphere\n                force_magnitude = self.stiffness * (distance - radius)\n                force_direction = -vector_to_center / distance  # Push back inside\n                force = np.clip(force_magnitude, 0, self.max_force) * force_direction\n                return force\n\n        return np.zeros(3)\n\n    def compute_guidance_force(self, current_pos, desired_trajectory, lookahead_distance=0.05):\n        """Compute guidance force to follow trajectory"""\n        # Find closest point on trajectory\n        closest_point = self._find_closest_point(current_pos, desired_trajectory)\n\n        # Calculate direction to trajectory\n        direction_to_trajectory = closest_point - current_pos\n        distance_to_trajectory = np.linalg.norm(direction_to_trajectory)\n\n        if distance_to_trajectory > 0.001:  # Avoid division by zero\n            direction_to_trajectory = direction_to_trajectory / distance_to_trajectory\n\n        # Generate guidance force\n        guidance_force = self.stiffness * direction_to_trajectory * min(distance_to_trajectory, 0.01)\n\n        return np.clip(guidance_force, -self.max_force, self.max_force)\n\n    def _find_closest_point(self, current_pos, trajectory):\n        """Find closest point on trajectory to current position"""\n        if len(trajectory) == 0:\n            return current_pos\n\n        # Simple approach: find closest point in trajectory\n        distances = np.linalg.norm(trajectory - current_pos, axis=1)\n        closest_idx = np.argmin(distances)\n        return trajectory[closest_idx]\n\n    def compute_damping_force(self, velocity):\n        """Compute damping force to reduce oscillations"""\n        damping_force = -self.damping * velocity\n        return np.clip(damping_force, -self.max_force, self.max_force)\n\n    def compute_contact_stabilization(self, contact_normal, contact_force_magnitude):\n        """Compute forces to stabilize contact"""\n        # Generate force perpendicular to contact surface\n        stabilization_force = self.stiffness * contact_normal * contact_force_magnitude * 0.001\n        return np.clip(stabilization_force, -self.max_force, self.max_force)\n\n    def update_haptic_rendering(self, current_pos, current_vel, contact_info):\n        """Update haptic rendering based on current state"""\n        total_force = np.zeros(3)\n\n        # Add virtual fixtures force\n        virtual_fixtures_force = self.compute_virtual_fixtures_force(current_pos, None)\n        total_force += virtual_fixtures_force\n\n        # Add damping force\n        damping_force = self.compute_damping_force(current_vel)\n        total_force += damping_force\n\n        # Add contact stabilization if in contact\n        if contact_info and contact_info.get(\'in_contact\', False):\n            contact_normal = contact_info.get(\'normal\', np.array([0, 0, 1]))\n            contact_force = contact_info.get(\'force_magnitude\', 0)\n            stabilization_force = self.compute_contact_stabilization(contact_normal, contact_force)\n            total_force += stabilization_force\n\n        # Limit total force\n        force_magnitude = np.linalg.norm(total_force)\n        if force_magnitude > self.max_force:\n            total_force = (total_force / force_magnitude) * self.max_force\n\n        self.current_force = total_force\n        return total_force\n'})}),"\n",(0,a.jsx)(n.h2,{id:"tactile-based-control",children:"Tactile-Based Control"}),"\n",(0,a.jsx)(n.h3,{id:"tactile-feedback-in-grasping-control",children:"Tactile Feedback in Grasping Control"}),"\n",(0,a.jsx)(n.p,{children:"Using tactile feedback for stable grasping:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:'class TactileGraspingController:\n    def __init__(self):\n        self.slip_threshold = 0.5\n        self.pressure_threshold = 5.0\n        self.slip_history = deque(maxlen=10)\n        self.force_history = deque(maxlen=20)\n        self.grasp_state = \'searching\'  # searching, contacting, grasping, stable\n        self.target_force = 10.0  # Target grasp force in Newtons\n\n    def update_grasp_control(self, tactile_data, current_force, dt=0.001):\n        """Update grasping control based on tactile feedback"""\n        # Process tactile data\n        contact_info = self._analyze_contact(tactile_data)\n        slip_detected = self._detect_slip(tactile_data)\n\n        # Update control state based on tactile feedback\n        if self.grasp_state == \'searching\':\n            if contact_info[\'contact_exists\']:\n                self.grasp_state = \'contacting\'\n                return self._initial_contact_control(current_force)\n\n        elif self.grasp_state == \'contacting\':\n            if contact_info[\'adequate_contact\']:\n                self.grasp_state = \'grasping\'\n                return self._grasp_force_control(current_force, contact_info)\n\n        elif self.grasp_state == \'grasping\':\n            if slip_detected:\n                return self._slip_compensation_control(current_force, contact_info)\n            elif contact_info[\'stable_grasp\']:\n                self.grasp_state = \'stable\'\n                return self._maintain_grasp_control(current_force)\n\n        elif self.grasp_state == \'stable\':\n            if slip_detected:\n                self.grasp_state = \'grasping\'  # Return to grasping mode\n                return self._slip_compensation_control(current_force, contact_info)\n            else:\n                return self._maintain_grasp_control(current_force)\n\n        return 0  # Default: no additional force\n\n    def _analyze_contact(self, tactile_data):\n        """Analyze tactile data to determine contact state"""\n        # Calculate contact statistics\n        contact_threshold = 0.1\n        contact_map = tactile_data > contact_threshold\n        contact_area = np.sum(contact_map)\n        avg_pressure = np.mean(tactile_data[tactile_data > contact_threshold]) if np.any(contact_map) else 0\n\n        # Determine contact state\n        contact_exists = contact_area > 5  # At least 5 taxels in contact\n        adequate_contact = contact_area > 10 and avg_pressure > 1.0\n        stable_grasp = contact_area > 15 and 2.0 < avg_pressure < 15.0\n\n        return {\n            \'contact_exists\': contact_exists,\n            \'adequate_contact\': adequate_contact,\n            \'stable_grasp\': stable_grasp,\n            \'contact_area\': contact_area,\n            \'avg_pressure\': avg_pressure\n        }\n\n    def _detect_slip(self, tactile_data):\n        """Detect slip using tactile data analysis"""\n        # Add current data to history\n        self.slip_history.append(tactile_data.copy())\n\n        if len(self.slip_history) < 3:\n            return False\n\n        # Analyze temporal changes in tactile pattern\n        prev_data = self.slip_history[-2]\n        curr_data = self.slip_history[-1]\n\n        # Calculate change in pressure distribution\n        pressure_change = np.abs(curr_data - prev_data)\n        change_magnitude = np.mean(pressure_change)\n\n        # Detect slip based on rapid changes in tactile pattern\n        slip_detected = change_magnitude > self.slip_threshold\n\n        return slip_detected\n\n    def _initial_contact_control(self, current_force):\n        """Control strategy for initial contact"""\n        # Gentle contact: apply small force to establish contact\n        target_force = min(2.0, self.target_force * 0.2)\n        force_error = target_force - current_force\n        control_output = 5.0 * force_error  # Simple P controller\n        return control_output\n\n    def _grasp_force_control(self, current_force, contact_info):\n        """Control strategy for establishing grasp"""\n        # Gradually increase force to target level\n        target_force = self.target_force * 0.7  # 70% of target initially\n        force_error = target_force - current_force\n        control_output = 3.0 * force_error  # P controller\n        return control_output\n\n    def _slip_compensation_control(self, current_force, contact_info):\n        """Control strategy when slip is detected"""\n        # Rapidly increase force to prevent slip\n        target_force = min(self.target_force * 1.5, 50.0)  # 150% of target, max 50N\n        force_error = target_force - current_force\n        control_output = 10.0 * force_error  # Aggressive P controller\n        return max(control_output, 0)  # Only allow positive force increase\n\n    def _maintain_grasp_control(self, current_force):\n        """Control strategy for maintaining stable grasp"""\n        # Maintain target force with small adjustments\n        target_force = self.target_force\n        force_error = target_force - current_force\n        control_output = 2.0 * force_error  # Gentle P controller\n        return control_output\n\n    def get_grasp_quality_metrics(self, tactile_data):\n        """Calculate grasp quality metrics from tactile data"""\n        contact_info = self._analyze_contact(tactile_data)\n\n        # Force distribution quality (how evenly force is distributed)\n        active_taxels = tactile_data[tactile_data > 0.1]\n        if len(active_taxels) > 1:\n            force_uniformity = 1.0 - np.std(active_taxels) / (np.mean(active_taxels) + 1e-6)\n        else:\n            force_uniformity = 0\n\n        # Contact coverage (how much of the tactile array is used)\n        contact_coverage = contact_info[\'contact_area\'] / len(tactile_data)\n\n        # Stability indicator (based on pressure variance)\n        stability = max(0, 1 - contact_info[\'avg_pressure\'] / 20.0)  # Assuming max 20N/cm^2\n\n        return {\n            \'force_uniformity\': max(0, min(1, force_uniformity)),\n            \'contact_coverage\': max(0, min(1, contact_coverage)),\n            \'stability\': max(0, min(1, stability)),\n            \'grasp_quality\': (force_uniformity + contact_coverage + stability) / 3.0\n        }\n'})}),"\n",(0,a.jsx)(n.h2,{id:"integration-with-ros-2",children:"Integration with ROS 2"}),"\n",(0,a.jsx)(n.h3,{id:"ros-2-tactile-sensing-node",children:"ROS 2 Tactile Sensing Node"}),"\n",(0,a.jsx)(n.p,{children:"Integrating tactile sensing with ROS 2 for system-wide haptic feedback:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom std_msgs.msg import Float64MultiArray\nfrom geometry_msgs.msg import WrenchStamped, Vector3\nfrom std_msgs.msg import Header\n\nclass TactileSensorNode(Node):\n    def __init__(self):\n        super().__init__('tactile_sensor_node')\n\n        # Create publishers\n        self.tactile_pub = self.create_publisher(\n            Float64MultiArray,\n            '/tactile_sensors/raw_data',\n            10\n        )\n\n        self.contact_pub = self.create_publisher(\n            WrenchStamped,\n            '/contact_force',\n            10\n        )\n\n        self.haptic_feedback_pub = self.create_publisher(\n            Float64MultiArray,\n            '/haptic_feedback',\n            10\n        )\n\n        # Create subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            '/joint_states',\n            self.joint_state_callback,\n            10\n        )\n\n        # Initialize tactile sensors\n        self.tactile_sensors = {\n            'left_hand': ResistiveTactileSensor('left_hand', num_taxels=64),\n            'right_hand': ResistiveTactileSensor('right_hand', num_taxels=64),\n            'left_foot': ResistiveTactileSensor('left_foot', num_taxels=32),\n            'right_foot': ResistiveTactileSensor('right_foot', num_taxels=32)\n        }\n\n        self.haptic_renderer = VibrotactileFeedback(num_actuators=8)\n        self.grasp_controller = TactileGraspingController()\n\n        # Timer for tactile data publishing\n        self.tactile_timer = self.create_timer(0.01, self.publish_tactile_data)  # 100Hz\n\n        self.get_logger().info('Tactile sensor node initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Process joint state information for tactile interpretation\"\"\"\n        # Update tactile sensor state based on joint positions and forces\n        # This would involve forward kinematics and force mapping\n        pass\n\n    def publish_tactile_data(self):\n        \"\"\"Publish tactile sensor data\"\"\"\n        for sensor_name, sensor in self.tactile_sensors.items():\n            # Simulate tactile data (in real system, this would come from hardware)\n            simulated_pressures = np.random.random(sensor.num_taxels) * 10  # 0-10 N/m^2\n            adc_values = sensor.update_from_physical_model(simulated_pressures)\n\n            # Create and publish message\n            tactile_msg = Float64MultiArray()\n            tactile_msg.data = adc_values.tolist()\n\n            header = Header()\n            header.stamp = self.get_clock().now().to_msg()\n            header.frame_id = sensor_name\n            tactile_msg.layout.data_offset = 0\n\n            self.tactile_pub.publish(tactile_msg)\n\n            # Process contact information\n            contact_info = sensor.get_contact_info()\n            if contact_info and contact_info['total_force'] > 1.0:  # 1N threshold\n                # Publish contact force\n                contact_msg = WrenchStamped()\n                contact_msg.header = header\n                contact_msg.wrench.force.x = 0.0\n                contact_msg.wrench.force.y = 0.0\n                contact_msg.wrench.force.z = float(contact_info['total_force'])\n                contact_msg.wrench.torque = Vector3(x=0.0, y=0.0, z=0.0)\n\n                self.contact_pub.publish(contact_msg)\n\n                # Generate haptic feedback based on contact\n                self.generate_haptic_feedback(sensor_name, contact_info)\n\n    def generate_haptic_feedback(self, sensor_name, contact_info):\n        \"\"\"Generate haptic feedback based on tactile input\"\"\"\n        if contact_info['total_force'] > 5.0:  # Strong contact\n            haptic_signal = self.haptic_renderer.generate_vibration_pattern(\n                'pressure', intensity=0.8, frequency=150, duration=0.1\n            )\n        elif contact_info.get('center_of_pressure') is not None:\n            # Spatialized feedback based on contact location\n            cop = contact_info['center_of_pressure']\n            haptic_signal = self.haptic_renderer.render_haptic_feedback(\n                {'type': 'texture'}, cop\n            )\n        else:\n            return  # No significant contact\n\n        # Publish haptic feedback\n        feedback_msg = Float64MultiArray()\n        feedback_msg.data = haptic_signal[-1].tolist()  # Use last time step\n        self.haptic_feedback_pub.publish(feedback_msg)\n\n    def process_grasp_control(self, hand_sensor_name):\n        \"\"\"Process grasp control for a hand\"\"\"\n        hand_sensor = self.tactile_sensors[hand_sensor_name]\n\n        # Get current tactile data\n        current_pressures = hand_sensor.pressure_map\n\n        # Update grasp controller\n        additional_force = self.grasp_controller.update_grasp_control(\n            current_pressures,\n            current_force=10.0  # Placeholder for actual force measurement\n        )\n\n        # Calculate grasp quality\n        quality_metrics = self.grasp_controller.get_grasp_quality_metrics(current_pressures)\n\n        self.get_logger().info(\n            f'Grasp quality for {hand_sensor_name}: {quality_metrics[\"grasp_quality\"]:.2f}, '\n            f'State: {self.grasp_controller.grasp_state}, '\n            f'Additional force needed: {additional_force:.2f}N'\n        )\n\ndef main(args=None):\n    rclpy.init(args=args)\n    tactile_node = TactileSensorNode()\n\n    try:\n        rclpy.spin(tactile_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        tactile_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(n.p,{children:"Tactile sensing and haptic feedback systems provide humanoid robots with the crucial ability to perceive and interact through touch. These systems enable safe manipulation, balance maintenance, and natural human-robot interaction. The integration of various tactile sensing technologies with advanced processing algorithms and haptic feedback creates rich sensory experiences that enhance robot capabilities."}),"\n",(0,a.jsx)(n.p,{children:"The next section will explore inertial and proprioceptive sensing systems that provide information about the robot's internal state and motion, completing the comprehensive perception system for humanoid robots."})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(_,{...e})}):_(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>c});var a=t(6540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);