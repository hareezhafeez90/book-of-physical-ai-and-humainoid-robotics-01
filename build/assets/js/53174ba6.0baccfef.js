"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[480],{6446:(n,e,t)=>{t.r(e),t.d(e,{assets:()=>c,contentTitle:()=>s,default:()=>p,frontMatter:()=>o,metadata:()=>r,toc:()=>l});var a=t(4848),i=t(8453);const o={},s="Stair Climbing and Complex Terrain Navigation",r={id:"module-4-locomotion-mobility/complex-terrain",title:"Stair Climbing and Complex Terrain Navigation",description:"Introduction: Beyond Flat Ground Locomotion",source:"@site/docs/module-4-locomotion-mobility/complex-terrain.md",sourceDirName:"module-4-locomotion-mobility",slug:"/module-4-locomotion-mobility/complex-terrain",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/complex-terrain",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-4-locomotion-mobility/complex-terrain.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Terrain Adaptation and Footstep Planning",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/terrain-adaptation"},next:{title:"Energy Efficiency in Humanoid Locomotion",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-4-locomotion-mobility/energy-efficiency"}},c={},l=[{value:"Introduction: Beyond Flat Ground Locomotion",id:"introduction-beyond-flat-ground-locomotion",level:2},{value:"Challenges of Complex Terrain Navigation",id:"challenges-of-complex-terrain-navigation",level:3},{value:"Stair Climbing and Negotiation",id:"stair-climbing-and-negotiation",level:2},{value:"Stair Detection and Classification",id:"stair-detection-and-classification",level:3},{value:"Stair Climbing Gait Generation",id:"stair-climbing-gait-generation",level:3},{value:"Stair Negotiation Control Strategies",id:"stair-negotiation-control-strategies",level:3},{value:"Narrow Passage Navigation",id:"narrow-passage-navigation",level:2},{value:"Gap and Obstacle Navigation",id:"gap-and-obstacle-navigation",level:3},{value:"Dynamic Obstacle Avoidance",id:"dynamic-obstacle-avoidance",level:2},{value:"Real-time Obstacle Avoidance",id:"real-time-obstacle-avoidance",level:3},{value:"Slippery Surface Navigation",id:"slippery-surface-navigation",level:2},{value:"Adaptation for Low-Friction Surfaces",id:"adaptation-for-low-friction-surfaces",level:3},{value:"Integration with Whole-Body Control",id:"integration-with-whole-body-control",level:2},{value:"Coordinated Multi-System Navigation",id:"coordinated-multi-system-navigation",level:3},{value:"Performance Evaluation and Benchmarking",id:"performance-evaluation-and-benchmarking",level:2},{value:"Complex Terrain Navigation Metrics",id:"complex-terrain-navigation-metrics",level:3},{value:"Conclusion",id:"conclusion",level:2}];function _(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"stair-climbing-and-complex-terrain-navigation",children:"Stair Climbing and Complex Terrain Navigation"}),"\n",(0,a.jsx)(e.h2,{id:"introduction-beyond-flat-ground-locomotion",children:"Introduction: Beyond Flat Ground Locomotion"}),"\n",(0,a.jsx)(e.p,{children:"Complex terrain navigation represents one of the most challenging aspects of humanoid robotics, requiring robots to handle environments far beyond simple flat surfaces. This includes stairs, narrow passages, dynamic obstacles, slippery surfaces, and other challenging scenarios that require sophisticated perception, planning, and control capabilities. This section explores the specialized techniques and algorithms needed for navigating these complex environments."}),"\n",(0,a.jsx)(e.h3,{id:"challenges-of-complex-terrain-navigation",children:"Challenges of Complex Terrain Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Complex terrain navigation involves multiple interconnected challenges:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Multi-modal locomotion"}),": Switching between different locomotion modes"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Dynamic obstacle avoidance"}),": Handling moving obstacles and people"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Precision positioning"}),": Accurate foot placement on small targets"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stability maintenance"}),": Preserving balance in challenging conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time adaptation"}),": Responding to unexpected terrain features"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"stair-climbing-and-negotiation",children:"Stair Climbing and Negotiation"}),"\n",(0,a.jsx)(e.h3,{id:"stair-detection-and-classification",children:"Stair Detection and Classification"}),"\n",(0,a.jsx)(e.p,{children:"Robust stair detection is fundamental for successful stair climbing:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.signal import find_peaks\nfrom sklearn.linear_model import RANSACRegressor\n\nclass StairDetector:\n    def __init__(self):\n        self.stair_params = {\n            'typical_rise': 0.17,    # 17cm typical stair rise\n            'typical_run': 0.3,     # 30cm typical stair run\n            'max_rise': 0.25,       # Maximum safe rise\n            'min_rise': 0.10,       # Minimum rise to be considered a step\n            'max_run': 0.5,         # Maximum safe run\n            'min_run': 0.2,         # Minimum safe run\n            'tolerance': 0.02       # 2cm tolerance\n        }\n        self.detected_stairs = []\n        self.stair_confidence = 0.0\n\n    def detect_stairs_from_height_profile(self, x_coords, height_values):\n        \"\"\"Detect stairs from 1D height profile along walking direction\"\"\"\n        # Find potential step locations using height changes\n        height_diffs = np.diff(height_values)\n\n        # Look for consistent height changes that indicate stairs\n        potential_steps = []\n        for i in range(len(height_diffs)):\n            if abs(height_diffs[i]) > self.stair_params['min_rise']:\n                potential_steps.append((i, height_diffs[i], height_values[i]))\n\n        if len(potential_steps) < 2:\n            return []\n\n        # Group steps by consistent height (stair rise)\n        step_groups = []\n        current_group = []\n\n        for i in range(len(potential_steps)):\n            if i == 0:\n                current_group.append(potential_steps[i])\n                continue\n\n            prev_height = potential_steps[i-1][2]\n            curr_height = potential_steps[i][2]\n            height_change = curr_height - prev_height\n\n            # Check if this continues the stair pattern\n            if (abs(height_change - self.stair_params['typical_rise']) <\n                self.stair_params['tolerance']):\n                current_group.append(potential_steps[i])\n            else:\n                if len(current_group) >= 2:  # Need at least 2 steps to be stairs\n                    step_groups.append(current_group.copy())\n                current_group = [potential_steps[i]]\n\n        if len(current_group) >= 2:\n            step_groups.append(current_group)\n\n        # Validate and classify stair groups\n        valid_stairs = []\n        for group in step_groups:\n            if self.validate_stair_group(group):\n                stair_info = self.extract_stair_info(group, x_coords)\n                valid_stairs.append(stair_info)\n\n        self.detected_stairs = valid_stairs\n        self.stair_confidence = len(valid_stairs) / max(1, len(step_groups))\n\n        return valid_stairs\n\n    def validate_stair_group(self, step_group):\n        \"\"\"Validate if a group of potential steps forms valid stairs\"\"\"\n        if len(step_group) < 2:\n            return False\n\n        # Check for consistent rise\n        rises = []\n        for i in range(1, len(step_group)):\n            rise = step_group[i][1]  # height_diff from the tuple\n            rises.append(abs(rise))\n\n        if not rises:\n            return False\n\n        avg_rise = np.mean(rises)\n        std_rise = np.std(rises)\n\n        # Stairs should have consistent rise\n        if std_rise > 0.02:  # Too much variation\n            return False\n\n        # Rise should be within reasonable bounds\n        if not (self.stair_params['min_rise'] <= avg_rise <= self.stair_params['max_rise']):\n            return False\n\n        # Check for consistent run (horizontal distance between steps)\n        if len(step_group) > 1:\n            runs = []\n            for i in range(1, len(step_group)):\n                run = step_group[i][0] - step_group[i-1][0]  # x coordinate difference\n                runs.append(run)\n\n            if runs:\n                avg_run = np.mean(runs) * 0.05  # Convert from index to meters (assuming 5cm resolution)\n                if not (self.stair_params['min_run'] <= avg_run <= self.stair_params['max_run']):\n                    return False\n\n        return True\n\n    def extract_stair_info(self, step_group, x_coords):\n        \"\"\"Extract detailed stair information from validated group\"\"\"\n        rises = [abs(step[1]) for step in step_group]\n        avg_rise = np.mean(rises)\n\n        # Calculate stair dimensions\n        start_x = x_coords[step_group[0][0]]\n        end_x = x_coords[step_group[-1][0]]\n        num_steps = len(step_group)\n\n        # Calculate run (horizontal distance per step)\n        total_run = end_x - start_x\n        avg_run = total_run / num_steps if num_steps > 1 else self.stair_params['typical_run']\n\n        # Calculate heights of each step\n        step_heights = []\n        current_height = step_group[0][2]  # starting height\n        for i, step in enumerate(step_group):\n            height = current_height + sum(rises[:i+1])\n            step_heights.append(height)\n\n        stair_info = {\n            'start_x': start_x,\n            'end_x': end_x,\n            'num_steps': num_steps,\n            'avg_rise': avg_rise,\n            'avg_run': avg_run,\n            'step_heights': step_heights,\n            'total_height': step_heights[-1] - step_heights[0],\n            'type': 'ascending' if rises[0] > 0 else 'descending',\n            'confidence': min(1.0, len(step_group) / 10.0)  # More steps = higher confidence\n        }\n\n        return stair_info\n\n    def detect_stairs_from_3d_point_cloud(self, point_cloud):\n        \"\"\"Detect stairs from 3D point cloud data\"\"\"\n        # Project 3D points to 2D profile along walking direction\n        # For simplicity, assume walking along X-axis\n\n        # Sort points by X coordinate\n        sorted_indices = np.argsort(point_cloud[:, 0])\n        sorted_points = point_cloud[sorted_indices]\n\n        # Create height profile by sampling points along X\n        x_bins = np.arange(sorted_points[0, 0], sorted_points[-1, 0], 0.05)  # 5cm bins\n        height_profile = []\n\n        for x_bin in x_bins:\n            # Get points in this bin\n            bin_mask = (sorted_points[:, 0] >= x_bin) & (sorted_points[:, 0] < x_bin + 0.05)\n            bin_points = sorted_points[bin_mask]\n\n            if len(bin_points) > 0:\n                # Use median height to reduce noise\n                avg_height = np.median(bin_points[:, 2])\n                height_profile.append(avg_height)\n            else:\n                height_profile.append(np.nan)\n\n        # Remove NaN values\n        valid_indices = ~np.isnan(height_profile)\n        valid_x = x_bins[valid_indices]\n        valid_heights = np.array(height_profile)[valid_indices]\n\n        if len(valid_heights) > 10:  # Need sufficient points\n            stairs = self.detect_stairs_from_height_profile(valid_x, valid_heights)\n            return stairs\n\n        return []\n\n    def classify_stair_type(self, stair_info):\n        \"\"\"Classify stair type based on dimensions\"\"\"\n        if stair_info['avg_rise'] < 0.15:\n            return 'low_step'\n        elif stair_info['avg_rise'] < 0.20:\n            return 'standard_stair'\n        elif stair_info['avg_rise'] < 0.25:\n            return 'high_step'\n        else:\n            return 'ramp'  # If rise is too high, might be a ramp\n\n# Example: Stair detection\nstair_detector = StairDetector()\n\n# Create sample stair point cloud\nstair_points = []\nfor step in range(6):  # 6 steps\n    z_height = step * 0.17  # 17cm rise per step\n    for x in np.arange(step * 0.3, step * 0.3 + 0.3, 0.02):  # 30cm run\n        for y in np.arange(-0.15, 0.15, 0.02):  # 30cm width\n            stair_points.append([x, y, z_height])\n\n# Add some noise to simulate real sensor data\nstair_points = np.array(stair_points)\nstair_points[:, 2] += np.random.normal(0, 0.01, len(stair_points))  # 1cm height noise\n\ndetected_stairs = stair_detector.detect_stairs_from_3d_point_cloud(stair_points)\nprint(f\"Detected {len(detected_stairs)} stair sequences\")\n\nfor i, stair in enumerate(detected_stairs):\n    print(f\"Stair {i+1}: {stair['num_steps']} steps, \"\n          f\"rise: {stair['avg_rise']:.3f}m, \"\n          f\"run: {stair['avg_run']:.3f}m, \"\n          f\"type: {stair_detector.classify_stair_type(stair)}\")\n"})}),"\n",(0,a.jsx)(e.h3,{id:"stair-climbing-gait-generation",children:"Stair Climbing Gait Generation"}),"\n",(0,a.jsx)(e.p,{children:"Specialized gait patterns for stair climbing:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class StairClimbingGaitGenerator:\n    def __init__(self):\n        self.stair_gait_params = {\n            'approach_distance': 0.5,      # Distance before stairs to prepare\n            'step_up_height': 0.05,        # Additional lift for step up\n            'step_down_height': 0.02,      # Additional clearance for step down\n            'step_time': 1.0,              # Time per step (slower than normal walking)\n            'com_height_offset': 0.02,     # Slightly raise CoM during stair climbing\n            'ankle_compensation': 0.1      # Ankle angle compensation for level feet\n        }\n\n    def generate_stair_ascent_gait(self, stair_info, robot_com_height=0.85):\n        \"\"\"Generate gait pattern for stair ascent\"\"\"\n        gait_pattern = {\n            'left_foot': [],\n            'right_foot': [],\n            'com_trajectory': [],\n            'timestamps': [],\n            'phase_descriptions': []\n        }\n\n        num_steps = stair_info['num_steps']\n        avg_run = stair_info['avg_run']\n        avg_rise = stair_info['avg_rise']\n\n        # Generate trajectory for each step\n        for step_idx in range(num_steps):\n            # Calculate positions for this step\n            step_x = stair_info['start_x'] + step_idx * avg_run\n            step_z = stair_info['step_heights'][step_idx]\n\n            # Left foot placement (for ascending stairs)\n            left_foot_x = step_x\n            left_foot_y = 0.1  # Left foot offset\n            left_foot_z = step_z\n\n            # Right foot placement (on same step, but alternates)\n            right_foot_x = step_x\n            right_foot_y = -0.1  # Right foot offset\n            right_foot_z = step_z\n\n            # Add to trajectories\n            gait_pattern['left_foot'].append([left_foot_x, left_foot_y, left_foot_z])\n            gait_pattern['right_foot'].append([right_foot_x, right_foot_y, right_foot_z])\n\n            # CoM trajectory - follow the rising stairs\n            com_x = step_x + avg_run / 2  # CoM leads feet slightly\n            com_y = 0.0  # Center between feet\n            com_z = robot_com_height + stair_info['avg_rise'] * step_idx * 0.1  # Gradual rise\n            gait_pattern['com_trajectory'].append([com_x, com_y, com_z])\n\n            # Timestamps\n            gait_pattern['timestamps'].append(step_idx * self.stair_gait_params['step_time'])\n\n            # Phase descriptions\n            gait_pattern['phase_descriptions'].append(f\"Step {step_idx + 1} ascent\")\n\n        return gait_pattern\n\n    def generate_stair_descent_gait(self, stair_info, robot_com_height=0.85):\n        \"\"\"Generate gait pattern for stair descent\"\"\"\n        gait_pattern = {\n            'left_foot': [],\n            'right_foot': [],\n            'com_trajectory': [],\n            'timestamps': [],\n            'phase_descriptions': []\n        }\n\n        num_steps = stair_info['num_steps']\n        avg_run = stair_info['avg_run']\n        avg_rise = stair_info['avg_rise']\n\n        # For descent, we approach from the top and go down\n        start_x = stair_info['end_x']\n        start_z = stair_info['step_heights'][-1]\n\n        for step_idx in range(num_steps):\n            # Calculate positions for descending step\n            step_x = start_x - step_idx * avg_run\n            step_z = start_z - step_idx * avg_rise\n\n            # Left foot placement\n            left_foot_x = step_x\n            left_foot_y = 0.1\n            left_foot_z = step_z\n\n            # Right foot placement\n            right_foot_x = step_x\n            right_foot_y = -0.1\n            right_foot_z = step_z\n\n            # Add to trajectories\n            gait_pattern['left_foot'].append([left_foot_x, left_foot_y, left_foot_z])\n            gait_pattern['right_foot'].append([right_foot_x, right_foot_y, right_foot_z])\n\n            # CoM trajectory - follow the descending stairs\n            com_x = step_x - avg_run / 2  # CoM follows feet\n            com_y = 0.0\n            com_z = robot_com_height - avg_rise * step_idx * 0.1  # Gradual descent\n            gait_pattern['com_trajectory'].append([com_x, com_y, com_z])\n\n            # Timestamps\n            gait_pattern['timestamps'].append(step_idx * self.stair_gait_params['step_time'])\n\n            # Phase descriptions\n            gait_pattern['phase_descriptions'].append(f\"Step {step_idx + 1} descent\")\n\n        return gait_pattern\n\n    def generate_approach_pattern(self, stair_start_x, stair_start_z, approach_steps=3):\n        \"\"\"Generate approach pattern before reaching stairs\"\"\"\n        approach_pattern = {\n            'left_foot': [],\n            'right_foot': [],\n            'com_trajectory': [],\n            'timestamps': [],\n            'phase_descriptions': []\n        }\n\n        for i in range(approach_steps):\n            # Normal walking pattern approaching stairs\n            x_pos = stair_start_x - (approach_steps - i) * 0.3  # 30cm steps\n            y_offset = 0.1 if i % 2 == 0 else -0.1  # Alternate feet\n\n            approach_pattern['left_foot'].append([x_pos, 0.1, stair_start_z]) if i % 2 == 0 else None\n            approach_pattern['right_foot'].append([x_pos, -0.1, stair_start_z]) if i % 2 == 1 else None\n\n            # CoM trajectory\n            approach_pattern['com_trajectory'].append([x_pos, 0.0, 0.85])\n\n            # Timestamps and descriptions\n            approach_pattern['timestamps'].append(i * 0.8)\n            approach_pattern['phase_descriptions'].append(f\"Approach step {i + 1}\")\n\n        return approach_pattern\n\n    def generate_departure_pattern(self, stair_end_x, stair_end_z, departure_steps=3):\n        \"\"\"Generate departure pattern after leaving stairs\"\"\"\n        departure_pattern = {\n            'left_foot': [],\n            'right_foot': [],\n            'com_trajectory': [],\n            'timestamps': [],\n            'phase_descriptions': []\n        }\n\n        for i in range(departure_steps):\n            # Normal walking pattern after stairs\n            x_pos = stair_end_x + (i + 1) * 0.3\n            y_offset = 0.1 if i % 2 == 0 else -0.1\n\n            departure_pattern['left_foot'].append([x_pos, 0.1, stair_end_z]) if i % 2 == 0 else None\n            departure_pattern['right_foot'].append([x_pos, -0.1, stair_end_z]) if i % 2 == 1 else None\n\n            # CoM trajectory\n            departure_pattern['com_trajectory'].append([x_pos, 0.0, 0.85])\n\n            # Timestamps and descriptions\n            departure_pattern['timestamps'].append(i * 0.8)\n            departure_pattern['phase_descriptions'].append(f\"Departure step {i + 1}\")\n\n        return departure_pattern\n\n    def generate_complete_stair_trajectory(self, stair_info, robot_com_height=0.85):\n        \"\"\"Generate complete trajectory including approach, climbing, and departure\"\"\"\n        complete_trajectory = {\n            'approach': self.generate_approach_pattern(\n                stair_info['start_x'], stair_info['step_heights'][0]\n            ),\n            'climbing': self.generate_stair_ascent_gait(stair_info, robot_com_height),\n            'departure': self.generate_departure_pattern(\n                stair_info['end_x'], stair_info['step_heights'][-1]\n            )\n        }\n\n        return complete_trajectory\n\n# Example: Stair climbing gait generation\nstair_gait_gen = StairClimbingGaitGenerator()\n\n# Use the stair info from previous detection\nif detected_stairs:\n    stair_info = detected_stairs[0]\n    complete_trajectory = stair_gait_gen.generate_complete_stair_trajectory(stair_info)\n\n    print(f\"Generated complete stair trajectory:\")\n    print(f\"  Approach: {len(complete_trajectory['approach']['timestamps'])} steps\")\n    print(f\"  Climbing: {len(complete_trajectory['climbing']['timestamps'])} steps\")\n    print(f\"  Departure: {len(complete_trajectory['departure']['timestamps'])} steps\")\n\n    # Display some key trajectory points\n    climbing = complete_trajectory['climbing']\n    if climbing['left_foot']:\n        print(f\"  First step left foot: {climbing['left_foot'][0]}\")\n        print(f\"  Last step left foot: {climbing['left_foot'][-1]}\")\n        print(f\"  CoM trajectory range: Z from {climbing['com_trajectory'][0][2]:.3f} to {climbing['com_trajectory'][-1][2]:.3f}\")\n"})}),"\n",(0,a.jsx)(e.h3,{id:"stair-negotiation-control-strategies",children:"Stair Negotiation Control Strategies"}),"\n",(0,a.jsx)(e.p,{children:"Advanced control strategies for stable stair negotiation:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class StairNegotiationController:\n    def __init__(self):\n        self.control_params = {\n            'ankle_stiffness': 200,        # Nm/rad ankle stiffness\n            'hip_compensation_gain': 50,   # Hip position compensation\n            'com_damping': 10,             # CoM velocity damping\n            'foot_lift_height': 0.05,      # Foot lift height for step clearance\n            'contact_threshold': 5.0       # Force threshold for contact detection\n        }\n        self.stance_foot = 'left'  # Current stance foot\n        self.swing_foot = 'right'  # Current swing foot\n\n    def calculate_ankle_compensation(self, terrain_normal, foot_type='left'):\n        \"\"\"Calculate ankle compensation angles based on terrain normal\"\"\"\n        # terrain_normal should be [nx, ny, nz] where nz is upward component\n        if np.linalg.norm(terrain_normal) == 0:\n            return 0.0, 0.0  # No slope\n\n        # Normalize the normal vector\n        normal = terrain_normal / np.linalg.norm(terrain_normal)\n\n        # Calculate required roll and pitch angles\n        # For a surface normal [nx, ny, nz], the required angles are:\n        # roll \u2248 arctan(ny/nz)\n        # pitch \u2248 arctan(-nx/nz)\n        roll_angle = np.arctan2(normal[1], normal[2])\n        pitch_angle = np.arctan2(-normal[0], normal[2])\n\n        # Apply compensation gains\n        max_compensation = 0.2  # Limit to ~11 degrees\n        roll_angle = np.clip(roll_angle, -max_compensation, max_compensation)\n        pitch_angle = np.clip(pitch_angle, -max_compensation, max_compensation)\n\n        return roll_angle, pitch_angle\n\n    def generate_foot_lift_trajectory(self, start_pos, target_pos, step_type='up'):\n        \"\"\"Generate smooth foot lift trajectory for step clearance\"\"\"\n        # Create intermediate points for smooth lifting\n        lift_height = (self.control_params['foot_lift_height'] if step_type == 'up'\n                      else self.control_params['foot_lift_height'] / 2)  # Less lift for step down\n\n        # Define trajectory points\n        mid_x = (start_pos[0] + target_pos[0]) / 2\n        mid_y = (start_pos[1] + target_pos[1]) / 2\n        mid_z = max(start_pos[2], target_pos[2]) + lift_height\n\n        # Simple 3-point trajectory: lift, move, place\n        trajectory_points = [\n            start_pos,  # Start position\n            [mid_x, mid_y, mid_z],  # Lift point\n            target_pos  # Target position\n        ]\n\n        # Interpolate for smoother motion\n        smooth_trajectory = []\n        for i in range(len(trajectory_points) - 1):\n            start_point = trajectory_points[i]\n            end_point = trajectory_points[i + 1]\n\n            # Linear interpolation with smooth transition\n            for t in np.linspace(0, 1, 10):  # 10 points per segment\n                # Use cubic interpolation for smoother motion\n                t_smooth = 3*t**2 - 2*t**3\n                pos = [(1-t_smooth)*s + t_smooth*e for s, e in zip(start_point, end_point)]\n                smooth_trajectory.append(pos)\n\n        return smooth_trajectory\n\n    def calculate_balance_compensation(self, com_error, zmp_error, step_phase):\n        \"\"\"Calculate balance compensation based on errors and step phase\"\"\"\n        compensation = {\n            'hip_offset': np.zeros(3),  # [x, y, z] offset\n            'ankle_torque': np.zeros(2),  # [roll, pitch] torque\n            'com_adjustment': np.zeros(3)  # CoM adjustment\n        }\n\n        # Hip compensation for CoM error\n        compensation['hip_offset'][0] = -com_error[0] * self.control_params['hip_compensation_gain'] * 0.1\n        compensation['hip_offset'][1] = -com_error[1] * self.control_params['hip_compensation_gain'] * 0.05\n\n        # Ankle torque for ZMP error\n        compensation['ankle_torque'][0] = -zmp_error[0] * self.control_params['ankle_stiffness'] * 0.1\n        compensation['ankle_torque'][1] = -zmp_error[1] * self.control_params['ankle_stiffness'] * 0.1\n\n        # CoM adjustment based on step phase (more adjustment during swing phase)\n        phase_factor = 1.0 if 0.3 < step_phase < 0.7 else 0.5  # Peak adjustment during mid-swing\n        compensation['com_adjustment'][0] = -com_error[0] * phase_factor * 0.3\n        compensation['com_adjustment'][1] = -com_error[1] * phase_factor * 0.2\n\n        return compensation\n\n    def execute_stair_step(self, current_state, target_foot_pos, terrain_normal, step_type='up'):\n        \"\"\"Execute a single stair step with appropriate control\"\"\"\n        # Generate foot trajectory\n        foot_trajectory = self.generate_foot_lift_trajectory(\n            current_state['current_foot_pos'],\n            target_foot_pos,\n            step_type\n        )\n\n        # Calculate ankle compensation\n        ankle_roll, ankle_pitch = self.calculate_ankle_compensation(terrain_normal)\n\n        # Calculate balance compensation\n        com_error = current_state['com_error']\n        zmp_error = current_state['zmp_error']\n        step_phase = current_state['step_phase']\n\n        balance_comp = self.calculate_balance_compensation(com_error, zmp_error, step_phase)\n\n        # Combine all control commands\n        control_commands = {\n            'foot_trajectory': foot_trajectory,\n            'ankle_compensation': (ankle_roll, ankle_pitch),\n            'balance_compensation': balance_comp,\n            'step_timing': self.calculate_step_timing(step_type)\n        }\n\n        return control_commands\n\n    def calculate_step_timing(self, step_type):\n        \"\"\"Calculate appropriate step timing based on step type\"\"\"\n        base_time = 1.0  # Base step time for stairs\n\n        if step_type == 'up':\n            # Going up requires more careful placement\n            return base_time * 1.2\n        elif step_type == 'down':\n            # Going down requires careful control to prevent falling\n            return base_time * 1.1\n        else:\n            # Level walking\n            return base_time * 0.8\n\n    def detect_stair_phase(self, robot_state, stair_info):\n        \"\"\"Detect current phase of stair negotiation\"\"\"\n        robot_x = robot_state['position'][0]\n        stair_start = stair_info['start_x']\n        stair_end = stair_info['end_x']\n        step_width = stair_info['avg_run']\n\n        if robot_x < stair_start - 0.5:\n            return 'approach'\n        elif robot_x < stair_start:\n            return 'pre_stance'  # Just before first step\n        elif robot_x <= stair_end:\n            # Determine which step we're on\n            step_number = int((robot_x - stair_start) / step_width)\n            return f'step_{step_number + 1}'\n        elif robot_x <= stair_end + 0.5:\n            return 'post_stance'  # Just after last step\n        else:\n            return 'departure'\n\n    def adapt_control_for_terrain_uncertainty(self, terrain_estimate, confidence_level):\n        \"\"\"Adapt control parameters based on terrain estimation uncertainty\"\"\"\n        # Reduce step size and increase caution with low confidence\n        adaptation_factor = confidence_level\n\n        # Adjust parameters based on confidence\n        new_params = self.control_params.copy()\n        new_params['foot_lift_height'] *= (0.7 + 0.3 * confidence_level)  # Higher lift with low confidence\n        new_params['ankle_stiffness'] *= (0.8 + 0.2 * confidence_level)  # Softer with low confidence\n\n        return new_params\n\n# Example: Stair negotiation control\nstair_controller = StairNegotiationController()\n\n# Simulate a stair negotiation scenario\ncurrent_state = {\n    'position': [0.5, 0.0, 0.85],\n    'current_foot_pos': [0.5, 0.1, 0.0],  # Current foot position\n    'com_error': [0.02, -0.01, 0.0],      # CoM position error\n    'zmp_error': [0.01, 0.005, 0.0],      # ZMP error\n    'step_phase': 0.4                      # Current step phase [0-1]\n}\n\nif detected_stairs:\n    target_pos = [0.8, 0.1, 0.17]  # Next step position\n    terrain_normal = [0.0, 0.0, 1.0]  # Flat surface normal\n    step_type = 'up'\n\n    control_commands = stair_controller.execute_stair_step(\n        current_state, target_pos, terrain_normal, step_type\n    )\n\n    print(f\"Stair negotiation control commands:\")\n    print(f\"  Foot trajectory points: {len(control_commands['foot_trajectory'])}\")\n    print(f\"  Ankle compensation: roll={control_commands['ankle_compensation'][0]:.3f}, \"\n          f\"pitch={control_commands['ankle_compensation'][1]:.3f}\")\n    print(f\"  Step timing: {control_commands['step_timing']:.2f}s\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"narrow-passage-navigation",children:"Narrow Passage Navigation"}),"\n",(0,a.jsx)(e.h3,{id:"gap-and-obstacle-navigation",children:"Gap and Obstacle Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Navigating through narrow passages and around obstacles:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class NarrowPassageNavigator:\n    def __init__(self, robot_width=0.4):\n        self.robot_width = robot_width\n        self.min_passage_width = robot_width * 1.2  # Need 20% clearance\n        self.side_step_distance = 0.15  # 15cm side steps\n        self.forward_step_distance = 0.2  # 20cm forward steps\n\n    def detect_passage_width(self, point_cloud, robot_pos, search_radius=1.0):\n        \"\"\"Detect the width of passages in the environment\"\"\"\n        passages = []\n\n        # Define search directions perpendicular to robot's intended direction\n        # For simplicity, assume robot moves along X-axis\n        y_range = np.linspace(robot_pos[1] - search_radius, robot_pos[1] + search_radius, 20)\n\n        for y in y_range:\n            # Find minimum distance to obstacles on left and right\n            left_clearance = self.find_clearance_to_obstacle(point_cloud, robot_pos[0], y, -1)\n            right_clearance = self.find_clearance_to_obstacle(point_cloud, robot_pos[0], y, 1)\n\n            total_width = left_clearance + right_clearance\n            if total_width > self.min_passage_width:\n                passages.append({\n                    'x': robot_pos[0],\n                    'y': y,\n                    'width': total_width,\n                    'left_clearance': left_clearance,\n                    'right_clearance': right_clearance\n                })\n\n        return passages\n\n    def find_clearance_to_obstacle(self, point_cloud, x, y, direction):\n        \"\"\"Find clearance to obstacle in given direction\"\"\"\n        test_y = y\n        step_size = 0.01  # 1cm steps\n        max_distance = 2.0  # Search up to 2m\n\n        for _ in range(int(max_distance / step_size)):\n            test_y += direction * step_size\n\n            # Check if there's an obstacle at this position\n            distances = np.sqrt((point_cloud[:, 0] - x)**2 + (point_cloud[:, 1] - test_y)**2)\n            min_distance = np.min(distances) if len(distances) > 0 else float('inf')\n\n            if min_distance < 0.1:  # Obstacle detected\n                return abs(test_y - y) - 0.1  # Subtract obstacle thickness\n\n        return max_distance  # No obstacle found\n\n    def plan_side_step_maneuver(self, passage_width, target_y, current_y):\n        \"\"\"Plan side-step maneuver for narrow passages\"\"\"\n        maneuver = {\n            'steps': [],\n            'total_distance': 0.0,\n            'estimated_time': 0.0\n        }\n\n        if passage_width < self.min_passage_width * 1.5:\n            # Very narrow - plan careful side-stepping\n            distance_to_target = abs(target_y - current_y)\n\n            # Calculate number of side steps needed\n            num_side_steps = int(distance_to_target / self.side_step_distance) + 1\n\n            for i in range(num_side_steps):\n                step_direction = 1 if target_y > current_y else -1\n                step_y = current_y + step_direction * self.side_step_distance * (i + 1)\n                step_y = min(max(step_y, target_y - 0.05), target_y + 0.05)  # Clamp to target\n\n                maneuver['steps'].append({\n                    'type': 'side_step',\n                    'x': current_y,  # Will be updated as robot moves forward\n                    'y': step_y,\n                    'direction': step_direction\n                })\n\n        else:\n            # Wide enough - direct path is possible\n            maneuver['steps'].append({\n                'type': 'direct',\n                'x': current_y,\n                'y': target_y,\n                'direction': 0\n            })\n\n        return maneuver\n\n    def generate_lateral_shuffling_pattern(self, target_offset, num_steps=4):\n        \"\"\"Generate lateral shuffling pattern for very narrow passages\"\"\"\n        shuffling_pattern = []\n\n        # Generate alternating lateral movements\n        for i in range(num_steps):\n            # Calculate lateral offset with alternating pattern\n            lateral_offset = target_offset * (i % 2) * 0.5  # Alternate sides\n            forward_progress = i * self.forward_step_distance / 2\n\n            shuffling_pattern.append({\n                'lateral_offset': lateral_offset,\n                'forward_progress': forward_progress,\n                'step_type': 'shuffle' if i % 2 == 0 else 'adjust'\n            })\n\n        return shuffling_pattern\n\n    def plan_passage_navigation(self, start_pos, goal_pos, point_cloud):\n        \"\"\"Plan navigation through passages with obstacles\"\"\"\n        navigation_plan = {\n            'approach': [],\n            'passage_traversal': [],\n            'departure': [],\n            'total_steps': 0\n        }\n\n        # Detect passages along the path\n        passages = self.detect_passage_width(point_cloud, start_pos)\n\n        if not passages:\n            # No narrow passages detected, plan direct path\n            navigation_plan['passage_traversal'] = self.plan_direct_path(start_pos, goal_pos)\n        else:\n            # Plan around narrow passages\n            for passage in passages:\n                if passage['width'] < self.min_passage_width:\n                    # Need to navigate around this narrow section\n                    maneuver = self.plan_side_step_maneuver(\n                        passage['width'],\n                        passage['y'],\n                        start_pos[1]\n                    )\n                    navigation_plan['passage_traversal'].extend(maneuver['steps'])\n\n        return navigation_plan\n\n    def plan_direct_path(self, start_pos, goal_pos):\n        \"\"\"Plan direct path when no obstacles are present\"\"\"\n        path = []\n        direction = np.array(goal_pos) - np.array(start_pos)\n        distance = np.linalg.norm(direction)\n        direction = direction / distance if distance > 0 else np.array([1, 0, 0])\n\n        num_steps = int(distance / self.forward_step_distance)\n        step_vector = direction * self.forward_step_distance\n\n        for i in range(num_steps):\n            pos = start_pos + step_vector * i\n            path.append({\n                'position': pos,\n                'type': 'forward_step'\n            })\n\n        return path\n\n    def evaluate_passage_traversability(self, passage, robot_params=None):\n        \"\"\"Evaluate if passage is traversable by the robot\"\"\"\n        if robot_params is None:\n            robot_params = {'width': self.robot_width, 'height': 1.7, 'ground_clearance': 0.05}\n\n        # Check width constraint\n        width_constraint = passage['width'] >= robot_params['width'] + 0.1  # 10cm clearance\n\n        # Check for overhead obstacles if needed\n        overhead_clearance = True  # Simplified - in practice, check Z-dimension\n\n        traversable = width_constraint and overhead_clearance\n        safety_margin = passage['width'] - robot_params['width']\n\n        return {\n            'traversable': traversable,\n            'safety_margin': safety_margin,\n            'constraint_type': 'width' if not width_constraint else 'none'\n        }\n\n# Example: Narrow passage navigation\nnarrow_navigator = NarrowPassageNavigator(robot_width=0.4)\n\n# Create sample environment with narrow passage\nenv_points = []\n# Walls\nfor x in np.arange(-2, 2, 0.1):\n    for z in [0, 0.1]:  # Ground and low obstacles\n        env_points.append([x, -1.0, z])  # Left wall\n        env_points.append([x, 1.0, z])   # Right wall\n\n# Add some obstacles to create a narrow passage\nfor y in np.arange(-0.8, 0.8, 0.05):\n    env_points.append([-0.5, y, 0.0])  # Obstacle creating narrow passage\n    env_points.append([0.5, y, 0.0])   # Obstacle creating narrow passage\n\nenv_point_cloud = np.array(env_points)\n\n# Detect passages\npassages = narrow_navigator.detect_passage_width(env_point_cloud, [0, 0, 0.85])\nprint(f\"Detected {len(passages)} potential passages\")\n\nfor i, passage in enumerate(passages[:3]):  # Show first 3\n    eval_result = narrow_navigator.evaluate_passage_traversability(passage)\n    print(f\"Passage {i+1}: width={passage['width']:.3f}m, \"\n          f\"traversable={eval_result['traversable']}, \"\n          f\"safety_margin={eval_result['safety_margin']:.3f}m\")\n\n# Plan navigation through narrow passage\nnavigation_plan = narrow_navigator.plan_passage_navigation(\n    [0, 0, 0.85], [1, 0, 0.85], env_point_cloud\n)\nprint(f\"Navigation plan generated with {len(navigation_plan['passage_traversal'])} steps\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"dynamic-obstacle-avoidance",children:"Dynamic Obstacle Avoidance"}),"\n",(0,a.jsx)(e.h3,{id:"real-time-obstacle-avoidance",children:"Real-time Obstacle Avoidance"}),"\n",(0,a.jsx)(e.p,{children:"Handling moving obstacles and people in real-time:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class DynamicObstacleAvoider:\n    def __init__(self):\n        self.prediction_horizon = 2.0  # Predict 2 seconds ahead\n        self.safety_margin = 0.3       # 30cm safety margin\n        self.response_time = 0.5       # 0.5 second response time\n        self.velocity_threshold = 0.1  # Stop if obstacle velocity < 0.1 m/s\n\n    def predict_obstacle_trajectory(self, obstacle_state, time_horizon=None):\n        \"\"\"Predict obstacle trajectory based on current state\"\"\"\n        if time_horizon is None:\n            time_horizon = self.prediction_horizon\n\n        predicted_trajectory = []\n        current_pos = obstacle_state['position']\n        current_vel = obstacle_state['velocity']\n\n        dt = 0.1  # 100ms prediction steps\n        for t in np.arange(0, time_horizon, dt):\n            # Simple constant velocity prediction\n            predicted_pos = current_pos + current_vel * t\n            predicted_trajectory.append({\n                'time': t,\n                'position': predicted_pos,\n                'velocity': current_vel\n            })\n\n        return predicted_trajectory\n\n    def detect_collision_risk(self, robot_trajectory, obstacle_trajectories):\n        \"\"\"Detect potential collisions between robot and obstacles\"\"\"\n        collision_risks = []\n\n        for obs_traj in obstacle_trajectories:\n            for i, robot_pos in enumerate(robot_trajectory):\n                if i < len(obs_traj):\n                    obs_pos = obs_traj[i]['position']\n                    distance = np.linalg.norm(robot_pos[:2] - obs_pos[:2])\n\n                    if distance < self.safety_margin:\n                        collision_risks.append({\n                            'time_to_collision': obs_traj[i]['time'],\n                            'distance': distance,\n                            'robot_position': robot_pos,\n                            'obstacle_position': obs_pos,\n                            'risk_level': self.calculate_risk_level(distance)\n                        })\n\n        return collision_risks\n\n    def calculate_risk_level(self, distance):\n        \"\"\"Calculate risk level based on distance\"\"\"\n        if distance < self.safety_margin * 0.5:\n            return 'critical'\n        elif distance < self.safety_margin:\n            return 'high'\n        elif distance < self.safety_margin * 1.5:\n            return 'medium'\n        else:\n            return 'low'\n\n    def generate_avoidance_trajectory(self, current_robot_pos, current_robot_vel,\n                                    collision_risks, obstacle_trajectories):\n        \"\"\"Generate avoidance trajectory to prevent collisions\"\"\"\n        if not collision_risks:\n            return None  # No risks detected\n\n        # Find the earliest and most critical collision\n        critical_risk = min(collision_risks, key=lambda x: x['time_to_collision'])\n        if critical_risk['risk_level'] == 'low':\n            return None  # Low risk, no avoidance needed\n\n        # Calculate avoidance direction (perpendicular to relative velocity)\n        closest_obstacle_pos = critical_risk['obstacle_position'][:2]\n        robot_to_obstacle = closest_obstacle_pos - current_robot_pos[:2]\n\n        # Calculate perpendicular direction for avoidance\n        avoidance_direction = np.array([-robot_to_obstacle[1], robot_to_obstacle[0]])\n        avoidance_direction = avoidance_direction / np.linalg.norm(avoidance_direction)\n\n        # Generate avoidance maneuver\n        avoidance_trajectory = []\n        avoidance_distance = max(0.5, self.safety_margin * 2)  # Avoid by at least 0.5m\n\n        # Simple lateral avoidance\n        for t in np.arange(0, 1.0, 0.1):  # 1 second avoidance maneuver\n            lateral_offset = avoidance_direction * avoidance_distance * t\n            new_pos = current_robot_pos.copy()\n            new_pos[:2] += lateral_offset\n            avoidance_trajectory.append(new_pos)\n\n        return avoidance_trajectory\n\n    def update_obstacle_state(self, obstacle_id, new_position, new_time, previous_states=None):\n        \"\"\"Update obstacle state with new measurement\"\"\"\n        if previous_states is None:\n            previous_states = []\n\n        # Calculate velocity from position changes\n        if previous_states:\n            last_state = previous_states[-1]\n            time_diff = new_time - last_state['timestamp']\n            if time_diff > 0:\n                velocity = (np.array(new_position) - np.array(last_state['position'])) / time_diff\n            else:\n                velocity = np.array([0, 0, 0])\n        else:\n            velocity = np.array([0, 0, 0])\n\n        return {\n            'id': obstacle_id,\n            'position': np.array(new_position),\n            'velocity': velocity,\n            'timestamp': new_time,\n            'predicted_trajectory': self.predict_obstacle_trajectory({\n                'position': np.array(new_position),\n                'velocity': velocity\n            })\n        }\n\n    def plan_reactive_avoidance(self, robot_state, dynamic_obstacles):\n        \"\"\"Plan reactive avoidance based on current obstacle states\"\"\"\n        avoidance_plan = {\n            'needs_avoidance': False,\n            'avoidance_trajectory': [],\n            'new_goal': None,\n            'wait_time': 0.0\n        }\n\n        # Check immediate collision risk\n        immediate_risk = False\n        for obs in dynamic_obstacles:\n            distance = np.linalg.norm(robot_state['position'][:2] - obs['position'][:2])\n            if distance < self.safety_margin:\n                immediate_risk = True\n\n        if immediate_risk:\n            # Calculate immediate avoidance action\n            avoidance_trajectory = self.calculate_immediate_avoidance(\n                robot_state, dynamic_obstacles\n            )\n            if avoidance_trajectory:\n                avoidance_plan['needs_avoidance'] = True\n                avoidance_plan['avoidance_trajectory'] = avoidance_trajectory\n\n        return avoidance_plan\n\n    def calculate_immediate_avoidance(self, robot_state, obstacles):\n        \"\"\"Calculate immediate avoidance action\"\"\"\n        # Find the closest obstacle\n        closest_obstacle = min(obstacles, key=lambda obs:\n                             np.linalg.norm(robot_state['position'][:2] - obs['position'][:2]))\n\n        # Calculate avoidance direction\n        robot_to_obstacle = closest_obstacle['position'][:2] - robot_state['position'][:2]\n        perpendicular = np.array([-robot_to_obstacle[1], robot_to_obstacle[0]])\n        perpendicular = perpendicular / np.linalg.norm(perpendicular)\n\n        # Generate immediate avoidance step\n        avoidance_step = robot_state['position'].copy()\n        avoidance_step[:2] += perpendicular * 0.2  # 20cm lateral step\n\n        return [avoidance_step]\n\n    def evaluate_avoidance_feasibility(self, avoidance_trajectory, environment_map):\n        \"\"\"Evaluate if avoidance trajectory is feasible\"\"\"\n        if not avoidance_trajectory:\n            return True  # No avoidance needed\n\n        for point in avoidance_trajectory:\n            x, y = point[:2]\n            # Check if this point is in free space\n            # This would interface with the environment map\n            # For now, return True (in a real system, check for obstacles)\n            pass\n\n        return True  # Simplified - assume feasible\n\n# Example: Dynamic obstacle avoidance\navoider = DynamicObstacleAvoider()\n\n# Simulate dynamic obstacles\nobstacle1 = {\n    'id': 'person1',\n    'position': np.array([1.0, 0.5, 0.0]),\n    'velocity': np.array([-0.5, 0.0, 0.0]),  # Moving left\n    'timestamp': time.time()\n}\n\nobstacle2 = {\n    'id': 'person2',\n    'position': np.array([0.5, -1.0, 0.0]),\n    'velocity': np.array([0.0, 0.3, 0.0]),   # Moving up\n    'timestamp': time.time()\n}\n\ndynamic_obstacles = [obstacle1, obstacle2]\n\n# Predict obstacle trajectories\nfor obs in dynamic_obstacles:\n    obs['predicted_trajectory'] = avoider.predict_obstacle_trajectory(obs)\n\nrobot_state = {\n    'position': np.array([0.0, 0.0, 0.85]),\n    'velocity': np.array([0.2, 0.0, 0.0]),\n    'goal': np.array([2.0, 0.0, 0.85])\n}\n\n# Plan avoidance\navoidance_plan = avoider.plan_reactive_avoidance(robot_state, dynamic_obstacles)\nprint(f\"Avoidance plan: needs_avoidance = {avoidance_plan['needs_avoidance']}\")\nprint(f\"Number of obstacles: {len(dynamic_obstacles)}\")\n\n# Update obstacle state with new measurement\nnew_obs_pos = [0.8, 0.5, 0.0]  # Person moved\nupdated_obs = avoider.update_obstacle_state('person1', new_obs_pos, time.time() + 1.0)\nprint(f\"Updated obstacle velocity: {updated_obs['velocity']}\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"slippery-surface-navigation",children:"Slippery Surface Navigation"}),"\n",(0,a.jsx)(e.h3,{id:"adaptation-for-low-friction-surfaces",children:"Adaptation for Low-Friction Surfaces"}),"\n",(0,a.jsx)(e.p,{children:"Handling surfaces with reduced friction:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class SlipperySurfaceNavigator:\n    def __init__(self):\n        self.friction_coefficients = {\n            'dry_concrete': 0.8,\n            'wet_surface': 0.4,\n            'ice': 0.1,\n            'grass': 0.6,\n            'sand': 0.5\n        }\n        self.slip_threshold = 0.1  # Threshold for slip detection\n        self.adaptation_params = {\n            'reduced_step_length': 0.15,    # Shorter steps on slippery surfaces\n            'increased_step_height': 0.02,  # Higher foot clearance\n            'slower_step_frequency': 0.6,   # Reduce step frequency by 40%\n            'increased_com_height': 0.02    # Slightly raise CoM for stability\n        }\n\n    def estimate_surface_friction(self, sensor_data):\n        \"\"\"Estimate surface friction from sensor data\"\"\"\n        # This would use various sensors: cameras for visual cues,\n        # force/torque sensors for slip detection, etc.\n        # For simulation, we'll use a simplified approach\n\n        if 'visual_texture' in sensor_data:\n            texture = sensor_data['visual_texture']\n            if 'wet' in texture or 'ice' in texture:\n                return self.friction_coefficients['wet_surface']\n            elif 'grass' in texture:\n                return self.friction_coefficients['grass']\n            else:\n                return self.friction_coefficients['dry_concrete']\n        else:\n            # Default to dry concrete if no visual data\n            return self.friction_coefficients['dry_concrete']\n\n    def detect_slip_conditions(self, force_data, acceleration_data):\n        \"\"\"Detect slip conditions from force and acceleration sensors\"\"\"\n        slip_detected = False\n        slip_magnitude = 0.0\n\n        if 'tangential_force' in force_data and 'normal_force' in force_data:\n            tangential_force = np.linalg.norm(force_data['tangential_force'])\n            normal_force = force_data['normal_force']\n\n            if normal_force > 0:\n                friction_ratio = tangential_force / normal_force\n                # If friction ratio approaches or exceeds friction coefficient, slip is occurring\n                if friction_ratio > 0.8:  # 80% of maximum friction\n                    slip_detected = True\n                    slip_magnitude = friction_ratio\n\n        # Also check for unexpected accelerations\n        if 'foot_acceleration' in acceleration_data:\n            foot_acc = acceleration_data['foot_acceleration']\n            if np.linalg.norm(foot_acc) > 5.0:  # High acceleration may indicate slip\n                slip_detected = True\n                slip_magnitude = max(slip_magnitude, np.linalg.norm(foot_acc) / 10.0)\n\n        return slip_detected, slip_magnitude\n\n    def adapt_gait_for_low_friction(self, base_gait_params, friction_coeff):\n        \"\"\"Adapt gait parameters for low friction conditions\"\"\"\n        adapted_params = base_gait_params.copy()\n\n        # Calculate adaptation factor based on friction\n        friction_factor = friction_coeff / self.friction_coefficients['dry_concrete']\n\n        # Reduce step length proportionally to friction\n        adapted_params['step_length'] *= max(0.3, friction_factor * 0.7)  # Min 30% of normal\n\n        # Increase step height for better foot clearance\n        adapted_params['swing_height'] *= (1 + (1 - friction_factor) * 0.5)\n\n        # Reduce step frequency\n        adapted_params['step_time'] /= max(0.4, friction_factor)  # Max 2.5x slower\n\n        # Increase stance time for better contact\n        adapted_params['stance_ratio'] = min(0.8, adapted_params.get('stance_ratio', 0.6) + (1 - friction_factor) * 0.2)\n\n        # Adjust foot placement for stability\n        adapted_params['step_width'] = max(0.15, adapted_params.get('step_width', 0.2) * (1 + (1 - friction_factor) * 0.3))\n\n        return adapted_params\n\n    def generate_stabilization_pattern(self, current_state, friction_coeff):\n        \"\"\"Generate stabilization pattern for slippery conditions\"\"\"\n        stabilization_pattern = {\n            'com_modulation': [],\n            'ankle_adjustments': [],\n            'step_timing': []\n        }\n\n        # Generate CoM modulation to maintain balance\n        base_com_x = current_state['com_position'][0]\n        base_com_y = current_state['com_position'][1]\n\n        for i in range(10):  # 10 steps of stabilization pattern\n            t = i * 0.1  # Time parameter\n\n            # Reduce CoM lateral movement to maintain stability\n            lateral_reduction = 1 - (1 - friction_coeff) * 0.5\n            com_y_offset = 0.02 * lateral_reduction * np.sin(2 * np.pi * t)  # Reduced sway\n\n            # Increase CoM height slightly for better stability\n            com_z_offset = current_state['com_position'][2] + self.adaptation_params['increased_com_height'] * (1 - friction_coeff)\n\n            stabilization_pattern['com_modulation'].append([\n                base_com_x + 0.01 * t,  # Slow forward progression\n                base_com_y + com_y_offset,\n                com_z_offset\n            ])\n\n            # Ankle adjustments for better grip\n            ankle_roll = (1 - friction_coeff) * 0.05 * np.sin(4 * np.pi * t)  # Small modulations\n            ankle_pitch = (1 - friction_coeff) * 0.03 * np.cos(4 * np.pi * t)\n            stabilization_pattern['ankle_adjustments'].append([ankle_roll, ankle_pitch])\n\n            # Adjust step timing based on friction\n            step_timing = 0.8 + (1 - friction_coeff) * 0.4  # Slower on slippery surfaces\n            stabilization_pattern['step_timing'].append(step_timing)\n\n        return stabilization_pattern\n\n    def implement_ankle_control_for_slippery_surfaces(self, current_ankle_state, desired_ankle_state, friction_coeff):\n        \"\"\"Implement specialized ankle control for slippery surfaces\"\"\"\n        # On slippery surfaces, reduce ankle stiffness to prevent sudden slips\n        reduced_stiffness_factor = friction_coeff * 0.7  # Reduce stiffness proportionally\n\n        # Calculate control command with reduced gains\n        position_error = desired_ankle_state - current_ankle_state\n        control_command = position_error * reduced_stiffness_factor\n\n        # Add damping to reduce oscillations\n        damping_factor = 0.3 + (1 - friction_coeff) * 0.4  # Higher damping on slippery surfaces\n        control_command *= (1 - damping_factor)\n\n        return control_command\n\n    def evaluate_traction_maintenance(self, foot_force_data, friction_coeff):\n        \"\"\"Evaluate how well traction is being maintained\"\"\"\n        traction_score = 0.0\n\n        if 'ground_reaction_forces' in foot_force_data:\n            forces = foot_force_data['ground_reaction_forces']\n            for force in forces:\n                tangential = np.linalg.norm(force[:2])  # X, Y forces\n                normal = abs(force[2])  # Z force\n\n                if normal > 0:\n                    friction_utilization = tangential / normal\n                    # Score is higher when friction utilization is lower (more margin)\n                    margin = friction_coeff - friction_utilization\n                    traction_score += max(0, margin) / friction_coeff\n\n        return traction_score / len(forces) if forces else 1.0  # Perfect score if no data\n\n# Example: Slippery surface navigation\nslippery_navigator = SlipperySurfaceNavigator()\n\n# Simulate different surface conditions\nsurfaces = ['dry_concrete', 'wet_surface', 'ice']\nfor surface in surfaces:\n    friction = slippery_navigator.friction_coefficients[surface]\n    print(f\"{surface}: friction coefficient = {friction}\")\n\n    # Adapt gait for this surface\n    base_params = {\n        'step_length': 0.3,\n        'step_time': 0.8,\n        'swing_height': 0.05,\n        'step_width': 0.2\n    }\n\n    adapted_params = slippery_navigator.adapt_gait_for_low_friction(base_params, friction)\n    print(f\"  Adapted step length: {adapted_params['step_length']:.3f}m \"\n          f\"(reduction: {(1-adapted_params['step_length']/base_params['step_length'])*100:.1f}%)\")\n\n# Simulate slip detection\nsensor_data = {\n    'tangential_force': [20, 10, 5],  # High tangential force may indicate slip\n    'normal_force': 400  # Normal force from foot\n}\n\nslip_detected, slip_mag = slippery_navigator.detect_slip_conditions(\n    sensor_data, {'foot_acceleration': [1.0, 2.0, 9.0]}\n)\nprint(f\"\\nSlip detection: {slip_detected}, magnitude: {slip_mag:.3f}\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"integration-with-whole-body-control",children:"Integration with Whole-Body Control"}),"\n",(0,a.jsx)(e.h3,{id:"coordinated-multi-system-navigation",children:"Coordinated Multi-System Navigation"}),"\n",(0,a.jsx)(e.p,{children:"Integrating all complex terrain capabilities into a unified system:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ComplexTerrainNavigator:\n    def __init__(self):\n        # Initialize all subsystems\n        self.stair_detector = StairDetector()\n        self.stair_gait_gen = StairClimbingGaitGenerator()\n        self.stair_controller = StairNegotiationController()\n        self.narrow_navigator = NarrowPassageNavigator()\n        self.dynamic_avoider = DynamicObstacleAvoider()\n        self.slippery_navigator = SlipperySurfaceNavigator()\n\n        # Navigation state\n        self.current_mode = 'walking'  # walking, stair_ascent, stair_descent, narrow_passage, avoidance\n        self.navigation_context = {}\n        self.safety_monitor = SafetyMonitor()\n\n    def analyze_environment(self, sensor_data):\n        \"\"\"Analyze environment to determine navigation requirements\"\"\"\n        environment_analysis = {\n            'terrain_type': 'flat',\n            'obstacles': [],\n            'passages': [],\n            'stairs': [],\n            'surface_conditions': 'dry',\n            'dynamic_objects': []\n        }\n\n        # Detect stairs\n        if 'point_cloud' in sensor_data:\n            stairs = self.stair_detector.detect_stairs_from_3d_point_cloud(\n                sensor_data['point_cloud']\n            )\n            environment_analysis['stairs'] = stairs\n\n        # Detect narrow passages\n        if 'point_cloud' in sensor_data and 'robot_position' in sensor_data:\n            passages = self.narrow_navigator.detect_passage_width(\n                sensor_data['point_cloud'],\n                sensor_data['robot_position']\n            )\n            environment_analysis['passages'] = passages\n\n        # Detect dynamic obstacles\n        if 'dynamic_objects' in sensor_data:\n            environment_analysis['dynamic_objects'] = sensor_data['dynamic_objects']\n\n        # Estimate surface conditions\n        if 'force_data' in sensor_data:\n            slip_detected, _ = self.slippery_navigator.detect_slip_conditions(\n                sensor_data['force_data'], {}\n            )\n            if slip_detected:\n                environment_analysis['surface_conditions'] = 'slippery'\n\n        return environment_analysis\n\n    def select_navigation_mode(self, environment_analysis, robot_state):\n        \"\"\"Select appropriate navigation mode based on environment\"\"\"\n        # Priority order for mode selection\n        if environment_analysis['dynamic_objects']:\n            # Check if immediate collision avoidance is needed\n            for obj in environment_analysis['dynamic_objects']:\n                distance = np.linalg.norm(\n                    robot_state['position'][:2] - obj['position'][:2]\n                )\n                if distance < 0.5:  # 50cm critical zone\n                    return 'collision_avoidance'\n\n        # Check for stairs\n        if environment_analysis['stairs']:\n            # Determine if we need to climb or descend\n            robot_x = robot_state['position'][0]\n            for stair in environment_analysis['stairs']:\n                if abs(robot_x - stair['start_x']) < 1.0:  # Within approach distance\n                    if stair['type'] == 'ascending':\n                        return 'stair_ascent'\n                    else:\n                        return 'stair_descent'\n\n        # Check for narrow passages\n        if environment_analysis['passages']:\n            for passage in environment_analysis['passages']:\n                if passage['width'] < self.narrow_navigator.min_passage_width * 1.5:\n                    return 'narrow_passage'\n\n        # Surface conditions\n        if environment_analysis['surface_conditions'] == 'slippery':\n            return 'slippery_surface'\n\n        # Default to normal walking\n        return 'walking'\n\n    def generate_navigation_plan(self, environment_analysis, robot_state, goal):\n        \"\"\"Generate navigation plan based on environment analysis\"\"\"\n        navigation_plan = {\n            'mode': self.select_navigation_mode(environment_analysis, robot_state),\n            'waypoints': [],\n            'control_parameters': {},\n            'safety_checks': []\n        }\n\n        if navigation_plan['mode'] == 'stair_ascent':\n            if environment_analysis['stairs']:\n                stair_info = environment_analysis['stairs'][0]  # Use first detected stairs\n                trajectory = self.stair_gait_gen.generate_complete_stair_trajectory(stair_info)\n                navigation_plan['waypoints'] = self.extract_waypoints_from_trajectory(trajectory)\n                navigation_plan['control_parameters'] = self.get_stair_control_params()\n\n        elif navigation_plan['mode'] == 'narrow_passage':\n            if environment_analysis['passages']:\n                passage = environment_analysis['passages'][0]  # Use first narrow passage\n                navigation_plan['waypoints'] = self.plan_narrow_passage_path(passage, robot_state, goal)\n\n        elif navigation_plan['mode'] == 'collision_avoidance':\n            if environment_analysis['dynamic_objects']:\n                navigation_plan['waypoints'] = self.plan_avoidance_path(\n                    robot_state, environment_analysis['dynamic_objects'], goal\n                )\n\n        elif navigation_plan['mode'] == 'slippery_surface':\n            navigation_plan['control_parameters'] = self.get_slippery_surface_params(\n                environment_analysis\n            )\n\n        else:  # normal walking\n            navigation_plan['waypoints'] = self.plan_normal_path(robot_state, goal)\n\n        return navigation_plan\n\n    def extract_waypoints_from_trajectory(self, trajectory):\n        \"\"\"Extract waypoints from complex trajectory\"\"\"\n        waypoints = []\n\n        # Combine approach, climbing, and departure trajectories\n        for phase in ['approach', 'climbing', 'departure']:\n            if phase in trajectory and trajectory[phase]:\n                phase_data = trajectory[phase]\n                for i in range(len(phase_data.get('left_foot', []))):\n                    # Average left and right foot positions for CoM guidance\n                    if i < len(phase_data.get('left_foot', [])) and i < len(phase_data.get('right_foot', [])):\n                        left_pos = phase_data['left_foot'][i]\n                        right_pos = phase_data['right_foot'][i]\n                        avg_pos = [(l + r) / 2 for l, r in zip(left_pos, right_pos)]\n                        avg_pos[2] = (left_pos[2] + right_pos[2]) / 2  # Average height\n                        waypoints.append(avg_pos)\n\n        return waypoints\n\n    def get_stair_control_params(self):\n        \"\"\"Get control parameters for stair climbing\"\"\"\n        return {\n            'ankle_stiffness': 250,\n            'step_timing': 1.2,\n            'com_height_offset': 0.03,\n            'foot_lift_height': 0.08\n        }\n\n    def plan_narrow_passage_path(self, passage, robot_state, goal):\n        \"\"\"Plan path through narrow passage\"\"\"\n        # Use narrow passage navigator to plan the path\n        navigation_plan = self.narrow_navigator.plan_passage_navigation(\n            robot_state['position'], goal, self.get_current_point_cloud()\n        )\n        return self.extract_waypoints_from_navigation_plan(navigation_plan)\n\n    def plan_avoidance_path(self, robot_state, dynamic_objects, goal):\n        \"\"\"Plan path to avoid dynamic obstacles\"\"\"\n        # Use dynamic avoider to plan around obstacles\n        avoidance_plan = self.dynamic_avoider.plan_reactive_avoidance(\n            robot_state, dynamic_objects\n        )\n\n        if avoidance_plan['needs_avoidance'] and avoidance_plan['avoidance_trajectory']:\n            return avoidance_plan['avoidance_trajectory']\n        else:\n            return [goal]  # Direct path if no immediate danger\n\n    def get_slippery_surface_params(self, environment_analysis):\n        \"\"\"Get parameters for slippery surface navigation\"\"\"\n        # Estimate friction from environment\n        friction_coeff = self.slippery_navigator.estimate_surface_friction(\n            environment_analysis\n        )\n        return self.slippery_navigator.adapt_gait_for_low_friction(\n            {'step_length': 0.3, 'step_time': 0.8, 'swing_height': 0.05},\n            friction_coeff\n        )\n\n    def plan_normal_path(self, robot_state, goal):\n        \"\"\"Plan normal walking path\"\"\"\n        # Simple straight-line path for normal walking\n        direction = goal - robot_state['position']\n        distance = np.linalg.norm(direction)\n        direction = direction / distance if distance > 0 else np.array([1, 0, 0])\n\n        waypoints = []\n        step_size = 0.3  # Normal step size\n        num_steps = int(distance / step_size)\n\n        for i in range(num_steps + 1):\n            pos = robot_state['position'] + direction * step_size * i\n            waypoints.append(pos)\n\n        return waypoints\n\n    def extract_waypoints_from_navigation_plan(self, plan):\n        \"\"\"Extract waypoints from navigation plan\"\"\"\n        waypoints = []\n        for phase in ['approach', 'passage_traversal', 'departure']:\n            if phase in plan:\n                for step in plan[phase]:\n                    if isinstance(step, dict) and 'position' in step:\n                        waypoints.append(step['position'])\n                    elif isinstance(step, dict) and 'type' in step:\n                        # For narrow passage steps\n                        waypoints.append([step.get('x', 0), step.get('y', 0), 0.85])\n        return waypoints\n\n    def get_current_point_cloud(self):\n        \"\"\"Get current point cloud (placeholder for actual sensor data)\"\"\"\n        # In a real system, this would come from sensors\n        return np.array([[0, 0, 0], [1, 0, 0], [2, 0, 0]])  # Placeholder\n\n    def execute_navigation_step(self, robot_state, navigation_plan):\n        \"\"\"Execute one step of the navigation plan\"\"\"\n        # This would interface with the robot's control system\n        # For simulation, return the next planned position\n        if navigation_plan['waypoints']:\n            return navigation_plan['waypoints'][0]  # Return first waypoint\n        else:\n            return robot_state['position']  # Stay in place if no plan\n\n    def monitor_safety(self, robot_state, environment_analysis):\n        \"\"\"Monitor safety during navigation\"\"\"\n        safety_status = {\n            'stable': True,\n            'emergency_stop': False,\n            'warnings': []\n        }\n\n        # Check for critical conditions\n        if environment_analysis['surface_conditions'] == 'slippery':\n            if 'force_data' in robot_state:\n                slip_detected, slip_mag = self.slippery_navigator.detect_slip_conditions(\n                    robot_state['force_data'], {}\n                )\n                if slip_detected and slip_mag > 0.2:\n                    safety_status['warnings'].append('High slip risk detected')\n                    if slip_mag > 0.3:\n                        safety_status['emergency_stop'] = True\n\n        # Check balance\n        if 'com_position' in robot_state and 'zmp' in robot_state:\n            com_pos = robot_state['com_position']\n            zmp_pos = robot_state['zmp']\n            stability_margin = np.linalg.norm(com_pos[:2] - zmp_pos[:2])\n            if stability_margin > 0.3:  # Too far from ZMP\n                safety_status['warnings'].append('Stability margin exceeded')\n                if stability_margin > 0.5:\n                    safety_status['emergency_stop'] = True\n\n        return safety_status\n\nclass SafetyMonitor:\n    def __init__(self):\n        self.safety_thresholds = {\n            'com_zmp_distance': 0.3,      # Max distance from ZMP\n            'angular_velocity': 1.0,      # Max angular velocity (rad/s)\n            'joint_limit_margin': 0.1,    # Min margin from joint limits\n            'collision_distance': 0.2     # Min distance to obstacles\n        }\n\n    def check_safety(self, robot_state):\n        \"\"\"Check if current robot state is safe\"\"\"\n        safety_issues = []\n\n        # Check ZMP stability\n        if 'com_position' in robot_state and 'zmp' in robot_state:\n            com_zmp_dist = np.linalg.norm(\n                robot_state['com_position'][:2] - robot_state['zmp'][:2]\n            )\n            if com_zmp_dist > self.safety_thresholds['com_zmp_distance']:\n                safety_issues.append(f\"ZMP stability exceeded: {com_zmp_dist:.3f}m\")\n\n        # Check angular velocity\n        if 'angular_velocity' in robot_state:\n            ang_vel_mag = np.linalg.norm(robot_state['angular_velocity'])\n            if ang_vel_mag > self.safety_thresholds['angular_velocity']:\n                safety_issues.append(f\"High angular velocity: {ang_vel_mag:.3f} rad/s\")\n\n        return len(safety_issues) == 0, safety_issues\n\n# Example: Complex terrain navigation\ncomplex_navigator = ComplexTerrainNavigator()\n\n# Simulate environment analysis\nsensor_data = {\n    'point_cloud': stair_points,  # Use the stair point cloud from earlier\n    'robot_position': [0, 0, 0.85],\n    'dynamic_objects': [],\n    'force_data': {\n        'tangential_force': [10, 5, 2],\n        'normal_force': 600\n    }\n}\n\nenvironment_analysis = complex_navigator.analyze_environment(sensor_data)\nprint(f\"Environment analysis:\")\nprint(f\"  Terrain type: {environment_analysis['terrain_type']}\")\nprint(f\"  Detected stairs: {len(environment_analysis['stairs'])}\")\nprint(f\"  Surface condition: {environment_analysis['surface_conditions']}\")\n\n# Generate navigation plan\nrobot_state = {\n    'position': [0, 0, 0.85],\n    'com_position': [0, 0, 0.85],\n    'zmp': [0, 0, 0],\n    'angular_velocity': [0.1, 0.05, 0.02]\n}\ngoal = [2, 0, 0.85]\n\nnavigation_plan = complex_navigator.generate_navigation_plan(\n    environment_analysis, robot_state, goal\n)\n\nprint(f\"\\nNavigation plan:\")\nprint(f\"  Mode: {navigation_plan['mode']}\")\nprint(f\"  Waypoints: {len(navigation_plan['waypoints'])}\")\nprint(f\"  Control parameters: {list(navigation_plan['control_parameters'].keys())}\")\n\n# Check safety\nsafety_ok, issues = complex_navigator.safety_monitor.check_safety(robot_state)\nprint(f\"\\nSafety check: {'OK' if safety_ok else 'ISSUES'}\")\nif issues:\n    for issue in issues:\n        print(f\"  - {issue}\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"performance-evaluation-and-benchmarking",children:"Performance Evaluation and Benchmarking"}),"\n",(0,a.jsx)(e.h3,{id:"complex-terrain-navigation-metrics",children:"Complex Terrain Navigation Metrics"}),"\n",(0,a.jsx)(e.p,{children:"Evaluating performance on complex terrain scenarios:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:"class ComplexTerrainEvaluator:\n    def __init__(self):\n        self.metrics = {\n            'success_rate': [],\n            'navigation_time': [],\n            'energy_efficiency': [],\n            'stability_score': [],\n            'adaptation_accuracy': [],\n            'safety_incidents': []\n        }\n\n    def evaluate_stair_navigation(self, robot_trajectory, stair_reference, execution_time):\n        \"\"\"Evaluate stair navigation performance\"\"\"\n        success = self.check_stair_navigation_success(robot_trajectory, stair_reference)\n        time_efficiency = self.evaluate_time_efficiency(execution_time, stair_reference['num_steps'])\n        stability = self.evaluate_stability(robot_trajectory)\n\n        return {\n            'success': success,\n            'time_efficiency': time_efficiency,\n            'stability': stability,\n            'overall_score': (success + time_efficiency + stability) / 3\n        }\n\n    def check_stair_navigation_success(self, trajectory, stair_reference):\n        \"\"\"Check if stair navigation was successful\"\"\"\n        if len(trajectory) < stair_reference['num_steps']:\n            return 0.0  # Incomplete\n\n        # Check if robot reached appropriate height\n        expected_height = stair_reference['step_heights'][-1]\n        actual_height = trajectory[-1][2] if len(trajectory) > 0 else 0\n\n        height_error = abs(expected_height - actual_height)\n        if height_error > 0.1:  # 10cm tolerance\n            return 0.5  # Partial success\n\n        # Check step accuracy (how close to expected step positions)\n        step_accuracy = 0.0\n        if len(trajectory) >= stair_reference['num_steps']:\n            for i in range(min(len(stair_reference['step_heights']), len(trajectory))):\n                expected_xy = [stair_reference['start_x'] + i * stair_reference['avg_run'], 0]\n                actual_xy = trajectory[i][:2]\n                step_error = np.linalg.norm(np.array(expected_xy) - actual_xy[:2])\n                step_accuracy += max(0, 1 - step_error / 0.2)  # 20cm tolerance\n\n            step_accuracy /= len(stair_reference['step_heights'])\n\n        return 0.7 * (1 if height_error <= 0.05 else 0.5) + 0.3 * step_accuracy\n\n    def evaluate_narrow_passage_navigation(self, trajectory, passage_width, execution_time):\n        \"\"\"Evaluate narrow passage navigation\"\"\"\n        success = 1.0  # Assume success for now\n        efficiency = len(trajectory) / max(1, execution_time)  # Steps per second\n        safety_margin = passage_width / 0.4  # Ratio to robot width\n\n        return {\n            'success_rate': success,\n            'navigation_efficiency': efficiency,\n            'safety_margin': min(1.0, safety_margin),\n            'overall_score': (success + min(1.0, efficiency/2) + min(1.0, safety_margin)) / 3\n        }\n\n    def evaluate_dynamic_obstacle_avoidance(self, robot_path, obstacle_trajectories, goal_reached):\n        \"\"\"Evaluate dynamic obstacle avoidance\"\"\"\n        if not goal_reached:\n            return {'success': 0.0, 'efficiency': 0.0, 'safety': 0.0}\n\n        # Calculate path efficiency (how direct was the path despite obstacles)\n        direct_distance = np.linalg.norm(robot_path[-1] - robot_path[0])\n        actual_distance = sum(np.linalg.norm(robot_path[i+1] - robot_path[i])\n                            for i in range(len(robot_path)-1))\n\n        path_efficiency = direct_distance / actual_distance if actual_distance > 0 else 0.0\n\n        # Calculate safety (minimum distance to obstacles)\n        min_distance_to_obstacles = float('inf')\n        for obs_traj in obstacle_trajectories:\n            for robot_pos in robot_path:\n                for obs_pos in [obs['position'] for obs in obs_traj]:\n                    dist = np.linalg.norm(robot_pos[:2] - obs_pos[:2])\n                    min_distance_to_obstacles = min(min_distance_to_obstacles, dist)\n\n        safety_score = 1.0 if min_distance_to_obstacles > 0.5 else min_distance_to_obstacles / 0.5\n\n        return {\n            'success': 1.0,\n            'path_efficiency': max(0.0, path_efficiency),\n            'safety_score': safety_score,\n            'overall_score': (1.0 + max(0.0, path_efficiency) + safety_score) / 3\n        }\n\n    def evaluate_slippery_surface_navigation(self, trajectory, surface_friction, slip_events):\n        \"\"\"Evaluate slippery surface navigation\"\"\"\n        # Count successful steps without excessive slip\n        successful_steps = sum(1 for slip in slip_events if slip < 0.1)  # Less than 10cm slip\n        total_steps = len(slip_events)\n\n        success_rate = successful_steps / total_steps if total_steps > 0 else 1.0\n\n        # Evaluate energy efficiency (may be higher on slippery surfaces due to caution)\n        energy_cost = len(trajectory) * 1.0  # Simplified energy model\n        efficiency = 1.0 / (1.0 + energy_cost * 0.1)  # Higher cost = lower efficiency\n\n        return {\n            'success_rate': success_rate,\n            'energy_efficiency': efficiency,\n            'stability': success_rate,  # Stability related to slip control\n            'overall_score': (success_rate + efficiency + success_rate) / 3\n        }\n\n    def evaluate_overall_complexity_handling(self, scenario_results):\n        \"\"\"Evaluate overall ability to handle complex terrain\"\"\"\n        total_score = 0\n        scenario_count = 0\n\n        for scenario_type, results in scenario_results.items():\n            if isinstance(results, dict) and 'overall_score' in results:\n                total_score += results['overall_score']\n                scenario_count += 1\n\n        return total_score / scenario_count if scenario_count > 0 else 0.0\n\n    def generate_performance_report(self, scenario_results):\n        \"\"\"Generate comprehensive performance report\"\"\"\n        report = {\n            'overall_complexity_score': self.evaluate_overall_complexity_handling(scenario_results),\n            'detailed_results': scenario_results,\n            'improvement_recommendations': []\n        }\n\n        # Analyze results to provide recommendations\n        if report['overall_complexity_score'] < 0.7:\n            report['improvement_recommendations'].append(\n                \"Consider improving stair detection and gait generation algorithms\"\n            )\n        if any(results.get('safety_score', 1.0) < 0.8 for results in scenario_results.values() if isinstance(results, dict)):\n            report['improvement_recommendations'].append(\n                \"Enhance safety monitoring and emergency stop capabilities\"\n            )\n\n        return report\n\n# Example: Performance evaluation\nevaluator = ComplexTerrainEvaluator()\n\n# Simulate evaluation of different scenarios\nscenario_results = {\n    'stair_navigation': evaluator.check_stair_navigation_success(\n        [[0, 0, 0], [0.3, 0.1, 0.17], [0.6, -0.1, 0.34]],  # Sample trajectory\n        {'num_steps': 2, 'step_heights': [0.17, 0.34], 'start_x': 0, 'avg_run': 0.3}\n    ),\n    'narrow_passage': evaluator.evaluate_narrow_passage_navigation(\n        [[0, 0, 0.85], [0.5, 0.1, 0.85], [1, 0, 0.85]],  # Trajectory\n        0.5,  # Passage width\n        5.0   # Execution time\n    ),\n    'obstacle_avoidance': evaluator.evaluate_dynamic_obstacle_avoidance(\n        [[0, 0, 0.85], [0.5, 0.2, 0.85], [1, 0, 0.85]],  # Robot path\n        [[{'position': [0.5, 0.5, 0]}]],  # Obstacle trajectory\n        True  # Goal reached\n    )\n}\n\n# Generate report\nreport = evaluator.generate_performance_report(scenario_results)\nprint(f\"\\nComplex Terrain Navigation Performance Report:\")\nprint(f\"Overall Complexity Score: {report['overall_complexity_score']:.3f}\")\nprint(f\"Improvement Recommendations: {len(report['improvement_recommendations'])}\")\nfor rec in report['improvement_recommendations']:\n    print(f\"  - {rec}\")\n"})}),"\n",(0,a.jsx)(e.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,a.jsx)(e.p,{children:"Complex terrain navigation represents the pinnacle of humanoid robotics capabilities, requiring the integration of perception, planning, control, and adaptation systems. The ability to navigate stairs, narrow passages, dynamic obstacles, and challenging surface conditions demonstrates the sophisticated engineering required for truly autonomous humanoid robots."}),"\n",(0,a.jsx)(e.p,{children:"The key to successful complex terrain navigation lies in:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Robust perception systems"})," that can accurately understand the environment"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Adaptive planning algorithms"})," that can respond to changing conditions"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Stable control systems"})," that maintain balance in challenging situations"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Real-time processing capabilities"})," that enable quick responses to unexpected events"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Integrated safety systems"})," that protect both the robot and its environment"]}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"Modern approaches combine traditional control theory with machine learning and adaptive algorithms to create systems that can handle the wide variety of real-world scenarios that humanoid robots encounter. The evaluation of these systems requires comprehensive metrics that consider success rates, efficiency, safety, and adaptability."}),"\n",(0,a.jsx)(e.p,{children:"The next section will explore energy efficiency considerations in humanoid locomotion, which becomes increasingly important as robots operate in complex environments for extended periods."})]})}function p(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(_,{...n})}):_(n)}},8453:(n,e,t)=>{t.d(e,{R:()=>s,x:()=>r});var a=t(6540);const i={},o=a.createContext(i);function s(n){const e=a.useContext(o);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function r(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),a.createElement(o.Provider,{value:e},n.children)}}}]);