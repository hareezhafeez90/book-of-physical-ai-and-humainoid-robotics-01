"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[964],{2127:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>s,contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>a,toc:()=>c});var o=t(4848),i=t(8453);const r={},l="Practical Examples and Exercises: Humanoid Control Implementation",a={id:"module-2-humanoid-control/practical-examples",title:"Practical Examples and Exercises: Humanoid Control Implementation",description:"Introduction: From Theory to Practice",source:"@site/docs/module-2-humanoid-control/practical-examples.md",sourceDirName:"module-2-humanoid-control",slug:"/module-2-humanoid-control/practical-examples",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/practical-examples",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-2-humanoid-control/practical-examples.md",tags:[],version:"current",frontMatter:{},sidebar:"textbookSidebar",previous:{title:"Motor Control Systems: From High-Level Commands to Actuator Commands",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-2-humanoid-control/motor-control"},next:{title:"Module 3: Perception and Sensing Systems",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-3-perception-sensing/"}},s={},c=[{value:"Introduction: From Theory to Practice",id:"introduction-from-theory-to-practice",level:2},{value:"Exercise 1: Simple Joint Control with PID",id:"exercise-1-simple-joint-control-with-pid",level:2},{value:"Exercise 2: Forward and Inverse Kinematics for a Simple Arm",id:"exercise-2-forward-and-inverse-kinematics-for-a-simple-arm",level:2},{value:"Exercise 3: Balance Control with Center of Mass Tracking",id:"exercise-3-balance-control-with-center-of-mass-tracking",level:2},{value:"Exercise 4: ROS 2 Integration Example",id:"exercise-4-ros-2-integration-example",level:2},{value:"Exercise 5: Whole-Body Control Simulation",id:"exercise-5-whole-body-control-simulation",level:2},{value:"Exercise 6: Practical Implementation Tips",id:"exercise-6-practical-implementation-tips",level:2},{value:"Safety Considerations",id:"safety-considerations",level:3},{value:"Performance Optimization",id:"performance-optimization",level:3},{value:"Conclusion",id:"conclusion",level:2}];function p(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,i.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(n.h1,{id:"practical-examples-and-exercises-humanoid-control-implementation",children:"Practical Examples and Exercises: Humanoid Control Implementation"}),"\n",(0,o.jsx)(n.h2,{id:"introduction-from-theory-to-practice",children:"Introduction: From Theory to Practice"}),"\n",(0,o.jsx)(n.p,{children:"This section provides hands-on examples and exercises that demonstrate the implementation of humanoid control concepts using Python and ROS 2. Through these practical examples, students will gain experience implementing the theoretical concepts covered in previous sections, from basic joint control to complex whole-body behaviors."}),"\n",(0,o.jsx)(n.h2,{id:"exercise-1-simple-joint-control-with-pid",children:"Exercise 1: Simple Joint Control with PID"}),"\n",(0,o.jsx)(n.p,{children:"Let's start with a basic PID joint controller implementation:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport time\nimport matplotlib.pyplot as plt\n\nclass SimpleJointController:\n    def __init__(self, kp=50, ki=10, kd=5):\n        self.kp = kp  # Proportional gain\n        self.ki = ki  # Integral gain\n        self.kd = kd  # Derivative gain\n\n        self.integral = 0\n        self.previous_error = 0\n        self.max_integral = 10  # Anti-windup limit\n        self.max_torque = 50    # Torque limit (Nm)\n\n    def update(self, desired_pos, current_pos, dt):\n        \"\"\"Update controller and return torque command\"\"\"\n        # Calculate error\n        error = desired_pos - current_pos\n\n        # Update integral with anti-windup\n        self.integral += error * dt\n        self.integral = np.clip(self.integral, -self.max_integral, self.max_integral)\n\n        # Calculate derivative\n        derivative = (error - self.previous_error) / dt if dt > 0 else 0\n        self.previous_error = error\n\n        # Calculate control output\n        output = (self.kp * error +\n                 self.ki * self.integral +\n                 self.kd * derivative)\n\n        # Apply torque limits\n        output = np.clip(output, -self.max_torque, self.max_torque)\n\n        return output\n\n# Simulation of a simple joint\nclass SimpleJoint:\n    def __init__(self, inertia=1.0, damping=0.1):\n        self.position = 0.0\n        self.velocity = 0.0\n        self.acceleration = 0.0\n        self.inertia = inertia\n        self.damping = damping\n\n    def update(self, torque, dt):\n        \"\"\"Update joint dynamics\"\"\"\n        # Calculate acceleration: T = I*alpha => alpha = T/I\n        self.acceleration = (torque - self.damping * self.velocity) / self.inertia\n\n        # Integrate to get velocity and position\n        self.velocity += self.acceleration * dt\n        self.position += self.velocity * dt\n\n        return self.position, self.velocity\n\n# Run simulation\ndef run_joint_control_simulation():\n    controller = SimpleJointController(kp=100, ki=20, kd=10)\n    joint = SimpleJoint(inertia=0.5, damping=0.05)\n\n    dt = 0.001  # 1ms control loop\n    simulation_time = 5.0  # 5 seconds\n    steps = int(simulation_time / dt)\n\n    # Desired trajectory: step input\n    desired_positions = [0.0 if t < 1.0 else 1.0 for t in np.arange(0, simulation_time, dt)]\n\n    # Store results for plotting\n    times = []\n    actual_positions = []\n    desired_pos_log = []\n    torques = []\n\n    for i, t in enumerate(np.arange(0, simulation_time, dt)):\n        # Get desired position\n        desired_pos = desired_positions[i]\n\n        # Get current position from joint\n        current_pos = joint.position\n\n        # Calculate control command\n        torque = controller.update(desired_pos, current_pos, dt)\n\n        # Apply torque to joint\n        joint.update(torque, dt)\n\n        # Log data\n        times.append(t)\n        actual_positions.append(joint.position)\n        desired_pos_log.append(desired_pos)\n        torques.append(torque)\n\n    # Plot results\n    plt.figure(figsize=(12, 8))\n\n    plt.subplot(2, 1, 1)\n    plt.plot(times, desired_pos_log, 'r--', label='Desired Position')\n    plt.plot(times, actual_positions, 'b-', label='Actual Position')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (rad)')\n    plt.title('PID Joint Control Simulation')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(2, 1, 2)\n    plt.plot(times, torques, 'g-', label='Applied Torque')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Torque (Nm)')\n    plt.title('Control Torque')\n    plt.legend()\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\n    print(f\"Final position error: {abs(desired_positions[-1] - actual_positions[-1]):.3f} rad\")\n\n# Run the simulation\nrun_joint_control_simulation()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-2-forward-and-inverse-kinematics-for-a-simple-arm",children:"Exercise 2: Forward and Inverse Kinematics for a Simple Arm"}),"\n",(0,o.jsx)(n.p,{children:"Now let's implement kinematics for a simple 2-DOF planar arm:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\n\nclass PlanarArm:\n    def __init__(self, link_lengths=[1.0, 1.0]):\n        self.l1, self.l2 = link_lengths\n\n    def forward_kinematics(self, theta1, theta2):\n        """Calculate end-effector position from joint angles"""\n        # Calculate end-effector position\n        x = self.l1 * np.cos(theta1) + self.l2 * np.cos(theta1 + theta2)\n        y = self.l1 * np.sin(theta1) + self.l2 * np.sin(theta1 + theta2)\n        return x, y\n\n    def jacobian(self, theta1, theta2):\n        """Calculate the Jacobian matrix"""\n        # Partial derivatives of end-effector position w.r.t. joint angles\n        J = np.array([\n            [-self.l1*np.sin(theta1) - self.l2*np.sin(theta1+theta2),\n             -self.l2*np.sin(theta1+theta2)],\n            [self.l1*np.cos(theta1) + self.l2*np.cos(theta1+theta2),\n             self.l2*np.cos(theta1+theta2)]\n        ])\n        return J\n\n    def inverse_kinematics_jacobian(self, target_x, target_y,\n                                   initial_theta1=0, initial_theta2=0,\n                                   max_iterations=100, tolerance=1e-4):\n        """Solve inverse kinematics using Jacobian transpose method"""\n        theta1, theta2 = initial_theta1, initial_theta2\n\n        for i in range(max_iterations):\n            # Calculate current position\n            curr_x, curr_y = self.forward_kinematics(theta1, theta2)\n\n            # Calculate error\n            error_x = target_x - curr_x\n            error_y = target_y - curr_y\n            error = np.array([error_x, error_y])\n\n            # Check convergence\n            if np.linalg.norm(error) < tolerance:\n                print(f"Converged after {i+1} iterations")\n                break\n\n            # Calculate Jacobian\n            J = self.jacobian(theta1, theta2)\n\n            # Update joint angles using Jacobian transpose\n            # dq = J^T * dx (simple transpose method)\n            joint_delta = 0.01 * J.T @ error\n            theta1 += joint_delta[0]\n            theta2 += joint_delta[1]\n        else:\n            print(f"Did not converge after {max_iterations} iterations")\n\n        return theta1, theta2\n\n# Demonstrate forward kinematics\narm = PlanarArm([0.7, 0.5])  # 70cm and 50cm links\n\n# Test different joint angles\nangles = [(0, 0), (np.pi/4, np.pi/4), (np.pi/2, -np.pi/4)]\nprint("Forward Kinematics Results:")\nfor theta1, theta2 in angles:\n    x, y = arm.forward_kinematics(theta1, theta2)\n    print(f"Angles: ({theta1:.2f}, {theta2:.2f}) -> Position: ({x:.2f}, {y:.2f})")\n\n# Test inverse kinematics\nprint("\\nInverse Kinematics Test:")\ntarget_x, target_y = 0.8, 0.6\ntheta1, theta2 = arm.inverse_kinematics_jacobian(target_x, target_y)\n\nprint(f"Target: ({target_x}, {target_y})")\nprint(f"Solution: ({theta1:.3f}, {theta2:.3f})")\n\n# Verify solution\nx_verify, y_verify = arm.forward_kinematics(theta1, theta2)\nprint(f"Verification: ({x_verify:.3f}, {y_verify:.3f})")\nprint(f"Error: {np.sqrt((target_x-x_verify)**2 + (target_y-y_verify)**2):.4f}")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-3-balance-control-with-center-of-mass-tracking",children:"Exercise 3: Balance Control with Center of Mass Tracking"}),"\n",(0,o.jsx)(n.p,{children:"Let's implement a simple balance controller using CoM tracking:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:"import numpy as np\nimport matplotlib.pyplot as plt\n\nclass SimpleBalanceController:\n    def __init__(self, com_height=0.8, control_gain=10.0):\n        self.com_height = com_height  # Height of CoM (m)\n        self.g = 9.81  # Gravity (m/s^2)\n        self.omega = np.sqrt(self.g / self.com_height)  # Natural frequency\n        self.K = control_gain  # Control gain\n\n    def compute_zmp_from_com(self, com_pos, com_vel):\n        \"\"\"Compute ZMP from CoM position and velocity\"\"\"\n        # ZMP = CoM - [0; 0; h] * CoM_ddot / g\n        # For LIPM: CoM_ddot = omega^2 * (CoM - ZMP)\n        # Solving for ZMP: ZMP = CoM - CoM_ddot / omega^2\n        # But we need to estimate CoM_ddot from position and velocity\n        # For now, we'll use a simplified approach\n\n        zmp_x = com_pos[0] - com_vel[0] / self.omega\n        zmp_y = com_pos[1] - com_vel[1] / self.omega\n\n        return np.array([zmp_x, zmp_y])\n\n    def compute_com_acceleration(self, desired_zmp, current_com_pos, current_com_vel):\n        \"\"\"Compute CoM acceleration to achieve desired ZMP\"\"\"\n        # LIPM dynamics: x_ddot = omega^2 * (x - zmp)\n        com_acc_x = self.omega**2 * (current_com_pos[0] - desired_zmp[0])\n        com_acc_y = self.omega**2 * (current_com_pos[1] - desired_zmp[1])\n\n        return np.array([com_acc_x, com_acc_y])\n\n# Simulate balance control\ndef simulate_balance_control():\n    controller = SimpleBalanceController(com_height=0.85)\n\n    dt = 0.01  # 100Hz control\n    simulation_time = 10.0\n    steps = int(simulation_time / dt)\n\n    # Initialize state\n    com_pos = np.array([0.0, 0.0])  # Initial CoM position\n    com_vel = np.array([0.0, 0.0])  # Initial CoM velocity\n    com_acc = np.array([0.0, 0.0])  # Initial CoM acceleration\n\n    # Desired ZMP trajectory (start at origin, move to offset at t=3s)\n    desired_zmp = []\n    for t in np.arange(0, simulation_time, dt):\n        if t < 3.0:\n            zmp = np.array([0.0, 0.0])\n        elif t < 6.0:\n            zmp = np.array([0.05, 0.0])  # Small offset in x\n        else:\n            zmp = np.array([0.0, 0.05])  # Small offset in y\n        desired_zmp.append(zmp)\n\n    # Store simulation results\n    times = []\n    com_positions = []\n    zmp_positions = []\n    desired_zmp_log = []\n\n    for i, t in enumerate(np.arange(0, simulation_time, dt)):\n        # Get desired ZMP\n        des_zmp = desired_zmp[i]\n\n        # Compute CoM acceleration to achieve desired ZMP\n        com_acc = controller.compute_com_acceleration(des_zmp, com_pos, com_vel)\n\n        # Integrate to get velocity and position\n        com_vel += com_acc * dt\n        com_pos += com_vel * dt\n\n        # Compute actual ZMP from current CoM state\n        actual_zmp = controller.compute_zmp_from_com(com_pos, com_vel)\n\n        # Log data\n        times.append(t)\n        com_positions.append(com_pos.copy())\n        zmp_positions.append(actual_zmp)\n        desired_zmp_log.append(des_zmp)\n\n    # Convert to numpy arrays for plotting\n    com_positions = np.array(com_positions)\n    zmp_positions = np.array(zmp_positions)\n    desired_zmp_log = np.array(desired_zmp_log)\n\n    # Plot results\n    plt.figure(figsize=(15, 5))\n\n    plt.subplot(1, 3, 1)\n    plt.plot(times, com_positions[:, 0], 'b-', label='CoM X')\n    plt.plot(times, desired_zmp_log[:, 0], 'r--', label='Desired ZMP X')\n    plt.plot(times, zmp_positions[:, 0], 'g:', label='Actual ZMP X')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('X-Axis Balance Control')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(1, 3, 2)\n    plt.plot(times, com_positions[:, 1], 'b-', label='CoM Y')\n    plt.plot(times, desired_zmp_log[:, 1], 'r--', label='Desired ZMP Y')\n    plt.plot(times, zmp_positions[:, 1], 'g:', label='Actual ZMP Y')\n    plt.xlabel('Time (s)')\n    plt.ylabel('Position (m)')\n    plt.title('Y-Axis Balance Control')\n    plt.legend()\n    plt.grid(True)\n\n    plt.subplot(1, 3, 3)\n    plt.plot(com_positions[:, 0], com_positions[:, 1], 'b-', label='CoM Trajectory')\n    plt.plot(desired_zmp_log[:, 0], desired_zmp_log[:, 1], 'ro', label='Desired ZMP')\n    plt.plot(zmp_positions[:, 0], zmp_positions[:, 1], 'g+', label='Actual ZMP')\n    plt.xlabel('X Position (m)')\n    plt.ylabel('Y Position (m)')\n    plt.title('Balance Control in XY Plane')\n    plt.legend()\n    plt.axis('equal')\n    plt.grid(True)\n\n    plt.tight_layout()\n    plt.show()\n\nsimulate_balance_control()\n"})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-4-ros-2-integration-example",children:"Exercise 4: ROS 2 Integration Example"}),"\n",(0,o.jsx)(n.p,{children:"Now let's create a practical ROS 2 example that demonstrates integration with the control system:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'# Save this as a separate Python file: balance_controller_ros2.py\n"""\nROS 2 Node for Humanoid Balance Control\nThis example demonstrates how to integrate balance control with ROS 2\n"""\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\nfrom geometry_msgs.msg import Point, Vector3\nfrom std_msgs.msg import Float64MultiArray\nimport numpy as np\n\nclass BalanceControllerROS2(Node):\n    def __init__(self):\n        super().__init__(\'balance_controller\')\n\n        # Declare parameters\n        self.declare_parameter(\'com_height\', 0.85)\n        self.declare_parameter(\'control_frequency\', 100)\n\n        self.com_height = self.get_parameter(\'com_height\').value\n        self.g = 9.81\n        self.omega = np.sqrt(self.g / self.com_height)\n\n        # Subscribers\n        self.joint_state_sub = self.create_subscription(\n            JointState,\n            \'/joint_states\',\n            self.joint_state_callback,\n            10\n        )\n\n        self.desired_zmp_sub = self.create_subscription(\n            Point,\n            \'/desired_zmp\',\n            self.desired_zmp_callback,\n            10\n        )\n\n        # Publishers\n        self.joint_command_pub = self.create_publisher(\n            Float64MultiArray,\n            \'/joint_commands\',\n            10\n        )\n\n        self.com_state_pub = self.create_publisher(\n            Point,\n            \'/com_state\',\n            10\n        )\n\n        # Timer for control loop\n        control_period = 1.0 / self.get_parameter(\'control_frequency\').value\n        self.control_timer = self.create_timer(control_period, self.control_loop)\n\n        # Internal state\n        self.current_joint_positions = []\n        self.current_joint_velocities = []\n        self.desired_zmp = np.array([0.0, 0.0])\n\n        self.get_logger().info(\'Balance Controller initialized\')\n\n    def joint_state_callback(self, msg):\n        """Callback for joint state messages"""\n        self.current_joint_positions = list(msg.position)\n        if msg.velocity:\n            self.current_joint_velocities = list(msg.velocity)\n\n        # For this example, we\'ll assume we can estimate CoM from joint positions\n        # In a real system, this would use forward kinematics and mass distribution\n        self.estimated_com = self.estimate_com_from_joints(msg.position)\n\n    def desired_zmp_callback(self, msg):\n        """Callback for desired ZMP"""\n        self.desired_zmp = np.array([msg.x, msg.y])\n\n    def estimate_com_from_joints(self, joint_positions):\n        """Estimate CoM position from joint positions (simplified model)"""\n        # This is a simplified estimation - in reality, this would use\n        # forward kinematics and a detailed mass distribution model\n        # For this example, we\'ll return a placeholder\n        return np.array([0.0, 0.0, self.com_height])\n\n    def compute_balance_control(self):\n        """Compute balance control commands"""\n        # This would implement the actual balance control algorithm\n        # For this example, we\'ll return placeholder joint commands\n        # that would help achieve the desired ZMP\n\n        # Simplified approach: adjust joint positions based on ZMP error\n        com_pos = self.estimated_com[:2]  # X, Y only\n        zmp_error = self.desired_zmp - com_pos\n\n        # Generate joint commands to correct ZMP error\n        # This would involve inverse kinematics and whole-body control\n        joint_commands = [0.0] * len(self.current_joint_positions)\n\n        # Add simple proportional correction based on ZMP error\n        if len(joint_commands) >= 6:  # At least 6 joints\n            # Adjust hip joints for balance (simplified)\n            joint_commands[0] = 0.1 * zmp_error[0]  # Left hip roll\n            joint_commands[1] = 0.1 * zmp_error[1]  # Left hip pitch\n            joint_commands[3] = 0.1 * zmp_error[0]  # Right hip roll\n            joint_commands[4] = 0.1 * zmp_error[1]  # Right hip pitch\n\n        return joint_commands\n\n    def control_loop(self):\n        """Main control loop"""\n        if not self.current_joint_positions:\n            return  # Wait for first joint state message\n\n        # Compute balance control commands\n        joint_commands = self.compute_balance_control()\n\n        # Publish joint commands\n        cmd_msg = Float64MultiArray()\n        cmd_msg.data = joint_commands\n        self.joint_command_pub.publish(cmd_msg)\n\n        # Publish CoM state\n        com_msg = Point()\n        com_msg.x = float(self.estimated_com[0])\n        com_msg.y = float(self.estimated_com[1])\n        com_msg.z = float(self.estimated_com[2])\n        self.com_state_pub.publish(com_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    balance_controller = BalanceControllerROS2()\n\n    try:\n        rclpy.spin(balance_controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        balance_controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-5-whole-body-control-simulation",children:"Exercise 5: Whole-Body Control Simulation"}),"\n",(0,o.jsx)(n.p,{children:"Let's create a more comprehensive example that combines multiple control concepts:"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.animation import FuncAnimation\n\nclass WholeBodyController:\n    def __init__(self):\n        # Robot parameters (simplified humanoid model)\n        self.left_foot = np.array([0.1, -0.1])  # Position relative to body\n        self.right_foot = np.array([0.1, 0.1])\n        self.com_height = 0.85  # Fixed CoM height for simplicity\n\n        # Control parameters\n        self.zmp_gain = 10.0\n        self.com_gain = 5.0\n\n    def compute_support_polygon(self):\n        """Compute the support polygon for balance"""\n        # For this example, assume feet positions are fixed\n        # In reality, this would come from forward kinematics\n        support_points = np.array([\n            self.left_foot,\n            [self.left_foot[0], self.left_foot[1] - 0.1],  # Foot width\n            [self.right_foot[0], self.right_foot[1] + 0.1],\n            self.right_foot\n        ])\n        return support_points\n\n    def is_stable(self, zmp):\n        """Check if ZMP is within support polygon"""\n        support_poly = self.compute_support_polygon()\n\n        # Simple check: ZMP between feet in y-direction,\n        # and within foot length in x-direction\n        y_min = min(self.left_foot[1], self.right_foot[1]) - 0.05\n        y_max = max(self.left_foot[1], self.right_foot[1]) + 0.05\n        x_min = min(self.left_foot[0], self.right_foot[0]) - 0.1\n        x_max = max(self.left_foot[0], self.right_foot[0]) + 0.1\n\n        return (x_min <= zmp[0] <= x_max and y_min <= zmp[1] <= y_max)\n\n    def compute_balance_correction(self, desired_com, current_com, current_zmp):\n        """Compute balance correction based on CoM and ZMP errors"""\n        # CoM tracking error\n        com_error = desired_com[:2] - current_com[:2]\n\n        # ZMP tracking error\n        zmp_error = desired_com[:2] - current_zmp  # Drive ZMP to desired CoM\n\n        # Combined balance correction\n        balance_correction = self.com_gain * com_error + self.zmp_gain * zmp_error\n\n        return balance_correction\n\n# Create an animation to visualize the control\nfig, ax = plt.subplots(figsize=(10, 8))\nax.set_xlim(-0.5, 0.5)\nax.set_ylim(-0.3, 0.3)\nax.set_aspect(\'equal\')\nax.grid(True)\nax.set_title(\'Whole-Body Balance Control Simulation\')\n\n# Initialize robot state\ncontroller = WholeBodyController()\ntime_step = 0.02\ncurrent_com = np.array([0.0, 0.0, controller.com_height])\ncurrent_com_vel = np.array([0.0, 0.0, 0.0])\ndesired_com_trajectory = []\n\n# Generate a desired CoM trajectory (circle motion)\nt_values = np.linspace(0, 4*np.pi, 400)\nfor t in t_values:\n    x = 0.1 * np.cos(t * 0.5)\n    y = 0.05 * np.sin(t * 0.5)\n    desired_com_trajectory.append(np.array([x, y, controller.com_height]))\n\n# Plot elements\ncom_point, = ax.plot([], [], \'bo\', markersize=10, label=\'CoM\')\nzmp_point, = ax.plot([], [], \'ro\', markersize=8, label=\'ZMP\')\nfoot_left, = ax.plot([], [], \'ks\', markersize=12, label=\'Left Foot\')\nfoot_right, = ax.plot([], [], \'gs\', markersize=12, label=\'Right Foot\')\nsupport_polygon = plt.Polygon(controller.compute_support_polygon(),\n                             alpha=0.2, color=\'gray\', label=\'Support Polygon\')\nax.add_patch(support_polygon)\n\nax.legend()\n\ndef animate(frame):\n    global current_com, current_com_vel\n\n    if frame >= len(desired_com_trajectory):\n        return com_point, zmp_point, foot_left, foot_right, support_polygon\n\n    # Get desired CoM\n    desired_com = desired_com_trajectory[frame]\n\n    # Compute ZMP from current CoM (simplified)\n    # ZMP = CoM - CoM_vel / omega (for LIPM)\n    omega = np.sqrt(9.81 / controller.com_height)\n    current_zmp = current_com[:2] - current_com_vel[:2] / omega if omega > 0 else current_com[:2]\n\n    # Compute balance correction\n    balance_correction = controller.compute_balance_correction(\n        desired_com, current_com, current_zmp\n    )\n\n    # Simple dynamics update (in reality, this would involve full robot dynamics)\n    # Apply balance correction to CoM velocity\n    current_com_vel[:2] += balance_correction * time_step\n    current_com[:2] += current_com_vel[:2] * time_step\n\n    # Update plot\n    com_point.set_data([current_com[0]], [current_com[1]])\n    zmp_point.set_data([current_zmp[0]], [current_zmp[1]])\n    foot_left.set_data([controller.left_foot[0]], [controller.left_foot[1]])\n    foot_right.set_data([controller.right_foot[0]], [controller.right_foot[1]])\n\n    # Update support polygon\n    support_points = controller.compute_support_polygon()\n    support_polygon.set_xy(support_points)\n\n    # Color code based on stability\n    is_stable = controller.is_stable(current_zmp)\n    com_point.set_color(\'blue\' if is_stable else \'red\')\n\n    ax.set_title(f\'Whole-Body Balance Control - Stable: {is_stable}\')\n\n    return com_point, zmp_point, foot_left, foot_right, support_polygon\n\n# Create animation\nanim = FuncAnimation(fig, animate, frames=len(desired_com_trajectory),\n                     interval=time_step*1000, blit=True, repeat=True)\n\nplt.show()\n\nprint("Whole-body balance control simulation completed.")\nprint("The animation shows:")\nprint("- Blue dot: Center of Mass (CoM)")\nprint("- Red dot: Zero-Moment Point (ZMP)")\nprint("- Black/Green squares: Feet positions")\nprint("- Gray polygon: Support polygon")\nprint("- Color changes to red when robot is unstable (ZMP outside support polygon)")\n'})}),"\n",(0,o.jsx)(n.h2,{id:"exercise-6-practical-implementation-tips",children:"Exercise 6: Practical Implementation Tips"}),"\n",(0,o.jsx)(n.p,{children:"Here are some practical considerations for implementing humanoid control systems:"}),"\n",(0,o.jsx)(n.h3,{id:"safety-considerations",children:"Safety Considerations"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'class SafetyMonitor:\n    def __init__(self):\n        self.emergency_stop = False\n        self.max_joint_velocity = 5.0  # rad/s\n        self.max_joint_torque = 100.0  # Nm\n        self.torque_threshold = 80.0   # Threshold for safety checks\n\n    def check_safety(self, joint_positions, joint_velocities, joint_torques):\n        """Check if robot state is safe"""\n        # Check joint limits\n        for vel in joint_velocities:\n            if abs(vel) > self.max_joint_velocity:\n                print(f"WARNING: High joint velocity detected: {vel}")\n                return False\n\n        # Check torque limits\n        for torque in joint_torques:\n            if abs(torque) > self.max_joint_torque:\n                print(f"WARNING: High joint torque detected: {torque}")\n                return False\n\n        # Check for sudden torque changes (indicating collision)\n        for torque in joint_torques:\n            if abs(torque) > self.torque_threshold:\n                print(f"WARNING: High torque detected: {torque}")\n                return False\n\n        return True\n\n    def emergency_stop_procedure(self):\n        """Execute emergency stop"""\n        print("EMERGENCY STOP ACTIVATED")\n        # Set all joint torques to zero\n        # Log the incident\n        # Wait for manual reset\n        self.emergency_stop = True\n'})}),"\n",(0,o.jsx)(n.h3,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,o.jsx)(n.pre,{children:(0,o.jsx)(n.code,{className:"language-python",children:'import time\nfrom functools import wraps\n\ndef timing_decorator(func):\n    """Decorator to measure function execution time"""\n    @wraps(func)\n    def wrapper(*args, **kwargs):\n        start = time.perf_counter()\n        result = func(*args, **kwargs)\n        end = time.perf_counter()\n        print(f"{func.__name__} executed in {(end-start)*1000:.2f} ms")\n        return result\n    return wrapper\n\nclass OptimizedController:\n    def __init__(self):\n        self.previous_values = {}  # Cache for expensive calculations\n\n    @timing_decorator\n    def compute_inverse_kinematics(self, target_pos, current_joints):\n        """Optimized inverse kinematics with caching"""\n        # Simple caching mechanism\n        target_key = tuple(np.round(target_pos, decimals=3))\n\n        if target_key in self.previous_values:\n            # Return cached result if target is similar\n            cached_joints, cached_time = self.previous_values[target_key]\n            if time.time() - cached_time < 0.1:  # Cache for 100ms\n                return cached_joints\n\n        # Perform expensive IK calculation\n        result = self._expensive_ik_calculation(target_pos, current_joints)\n\n        # Cache the result\n        self.previous_values[target_key] = (result, time.time())\n\n        return result\n\n    def _expensive_ik_calculation(self, target_pos, current_joints):\n        """Placeholder for actual IK algorithm"""\n        # In a real implementation, this would contain the actual\n        # inverse kinematics calculation\n        return current_joints  # Placeholder\n'})}),"\n",(0,o.jsx)(n.h2,{id:"conclusion",children:"Conclusion"}),"\n",(0,o.jsx)(n.p,{children:"These practical examples demonstrate the implementation of key humanoid control concepts:"}),"\n",(0,o.jsxs)(n.ol,{children:["\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Basic Control"}),": PID controllers form the foundation of joint control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Kinematics"}),": Forward and inverse kinematics enable spatial control"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Balance"}),": ZMP-based control maintains stability"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Integration"}),": ROS 2 enables system integration"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Whole-Body"}),": Coordinated control of multiple subsystems"]}),"\n",(0,o.jsxs)(n.li,{children:[(0,o.jsx)(n.strong,{children:"Safety"}),": Essential for real-world deployment"]}),"\n"]}),"\n",(0,o.jsx)(n.p,{children:"Students should experiment with these examples, modify parameters, and observe the effects on system behavior. Understanding both the theoretical concepts and their practical implementation is crucial for developing effective humanoid control systems."}),"\n",(0,o.jsx)(n.p,{children:"The next module will explore perception and sensing systems that provide the sensory input necessary for intelligent physical behavior."})]})}function m(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,o.jsx)(n,{...e,children:(0,o.jsx)(p,{...e})}):p(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var o=t(6540);const i={},r=o.createContext(i);function l(e){const n=o.useContext(r);return o.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:l(e.components),o.createElement(r.Provider,{value:n},e.children)}}}]);