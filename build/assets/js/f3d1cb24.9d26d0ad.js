"use strict";(globalThis.webpackChunkphysical_ai_textbook=globalThis.webpackChunkphysical_ai_textbook||[]).push([[466],{4348:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var s=r(4848),i=r(8453);const o={sidebar_label:"The rclpy Bridge",sidebar_position:7},a="The rclpy Bridge: Connecting High-Level AI to Low-Level Hardware",t={id:"module-1-ros2/rclpy-bridge",title:"The rclpy Bridge: Connecting High-Level AI to Low-Level Hardware",description:"Learning Objectives",source:"@site/docs/module-1-ros2/rclpy-bridge.md",sourceDirName:"module-1-ros2",slug:"/module-1-ros2/rclpy-bridge",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-1-ros2/rclpy-bridge",draft:!1,unlisted:!1,editUrl:"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1-ros2/rclpy-bridge.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_label:"The rclpy Bridge",sidebar_position:7},sidebar:"textbookSidebar",previous:{title:"Understanding URDF",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-1-ros2/urdf-structure"},next:{title:"Practical Examples",permalink:"/book-of-physical-ai-and-humainoid-robotics-01/docs/module-1-ros2/practical-examples"}},l={},c=[{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"The Bridge Between Worlds: AI and Hardware",id:"the-bridge-between-worlds-ai-and-hardware",level:2},{value:"The Challenge of Hardware Interface",id:"the-challenge-of-hardware-interface",level:3},{value:"The Biological Analogy",id:"the-biological-analogy",level:3},{value:"Understanding rclpy: The Python-ROS 2 Client Library",id:"understanding-rclpy-the-python-ros-2-client-library",level:2},{value:"Core Components of rclpy",id:"core-components-of-rclpy",level:3},{value:"Creating Your First rclpy Node",id:"creating-your-first-rclpy-node",level:2},{value:"The AI-to-Hardware Communication Pipeline",id:"the-ai-to-hardware-communication-pipeline",level:2},{value:"1. Sensor Data Flow",id:"1-sensor-data-flow",level:3},{value:"2. AI Processing",id:"2-ai-processing",level:3},{value:"3. Hardware Command Flow",id:"3-hardware-command-flow",level:3},{value:"Practical Example: AI-Based Motor Control",id:"practical-example-ai-based-motor-control",level:2},{value:"Integration with Robot Hardware Controllers",id:"integration-with-robot-hardware-controllers",level:2},{value:"1. Motor Controllers",id:"1-motor-controllers",level:3},{value:"2. Sensor Interfaces",id:"2-sensor-interfaces",level:3},{value:"3. Manipulator Controllers",id:"3-manipulator-controllers",level:3},{value:"Best Practices for AI-Hardware Integration",id:"best-practices-for-ai-hardware-integration",level:2},{value:"1. Safety First",id:"1-safety-first",level:3},{value:"2. Error Handling",id:"2-error-handling",level:3},{value:"3. Real-time Considerations",id:"3-real-time-considerations",level:3},{value:"Advanced: Working with Action Servers for Complex Tasks",id:"advanced-working-with-action-servers-for-complex-tasks",level:2},{value:"The Complete AI-Hardware Ecosystem",id:"the-complete-ai-hardware-ecosystem",level:2},{value:"Debugging and Monitoring",id:"debugging-and-monitoring",level:2},{value:"Summary",id:"summary",level:2},{value:"Key Terms",id:"key-terms",level:2},{value:"Review Questions",id:"review-questions",level:2}];function d(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,i.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{id:"the-rclpy-bridge-connecting-high-level-ai-to-low-level-hardware",children:"The rclpy Bridge: Connecting High-Level AI to Low-Level Hardware"}),"\n",(0,s.jsx)(n.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,s.jsx)(n.p,{children:"By the end of this section, you will be able to:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Explain the role of rclpy as the bridge between Python and ROS 2"}),"\n",(0,s.jsx)(n.li,{children:"Understand how rclpy enables Python programs to interact with robot hardware"}),"\n",(0,s.jsx)(n.li,{children:"Implement basic rclpy nodes that interface with physical systems"}),"\n",(0,s.jsx)(n.li,{children:"Describe the relationship between high-level AI code and low-level motor controllers"}),"\n",(0,s.jsx)(n.li,{children:"Create Python nodes that can control robot hardware through ROS 2"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"the-bridge-between-worlds-ai-and-hardware",children:"The Bridge Between Worlds: AI and Hardware"}),"\n",(0,s.jsxs)(n.p,{children:["In the robotic nervous system, ",(0,s.jsx)(n.strong,{children:"rclpy"}),' serves as the critical "bridge" connecting high-level artificial intelligence code to low-level robot hardware controllers. Think of rclpy as the interface between the "mind" (AI algorithms) and the "body" (physical actuators and sensors) of the robot.']}),"\n",(0,s.jsx)(n.h3,{id:"the-challenge-of-hardware-interface",children:"The Challenge of Hardware Interface"}),"\n",(0,s.jsx)(n.p,{children:"Robots must bridge two very different worlds:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"High-level AI"}),": Python algorithms for perception, planning, and decision-making"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Low-level Hardware"}),": C++ controllers for motors, sensors, and real-time systems"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"rclpy provides the Python interface to ROS 2's core functionality, allowing Python-based AI systems to communicate seamlessly with hardware controllers."}),"\n",(0,s.jsx)(n.h3,{id:"the-biological-analogy",children:"The Biological Analogy"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Biological Component"}),(0,s.jsx)(n.th,{children:"rclpy Component"}),(0,s.jsx)(n.th,{children:"Function"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Motor Cortex"}),(0,s.jsx)(n.td,{children:"Python AI nodes"}),(0,s.jsx)(n.td,{children:"High-level movement planning"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Spinal Cord"}),(0,s.jsx)(n.td,{children:"rclpy bridge"}),(0,s.jsx)(n.td,{children:"Translates high-level commands"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Motor Neurons"}),(0,s.jsx)(n.td,{children:"Hardware controllers"}),(0,s.jsx)(n.td,{children:"Execute physical movements"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"Sensor Feedback"}),(0,s.jsx)(n.td,{children:"Sensor nodes"}),(0,s.jsx)(n.td,{children:"Provide information back to AI"})]})]})]}),"\n",(0,s.jsx)(n.h2,{id:"understanding-rclpy-the-python-ros-2-client-library",children:"Understanding rclpy: The Python-ROS 2 Client Library"}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"rclpy"})," (ROS Client Library for Python) is the Python binding for ROS 2. It provides:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Node Creation"}),": Interface for creating ROS 2 nodes in Python"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Communication Primitives"}),": Publishers, subscribers, services, and actions"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Message Handling"}),": Tools for creating and processing ROS 2 messages"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Lifecycle Management"}),": Node initialization, execution, and cleanup"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"core-components-of-rclpy",children:"Core Components of rclpy"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Node"}),": The fundamental execution unit"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Publisher"}),": Interface for sending messages to topics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Subscriber"}),": Interface for receiving messages from topics"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Service Client/Server"}),": Interface for request/response communication"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Client/Server"}),": Interface for long-running tasks with feedback"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"creating-your-first-rclpy-node",children:"Creating Your First rclpy Node"}),"\n",(0,s.jsx)(n.p,{children:"Let's examine the structure of a basic rclpy node:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass AINode(Node):\n    def __init__(self):\n        super().__init__(\'ai_node\')\n\n        # Create a publisher to send commands to hardware\n        self.publisher_ = self.create_publisher(String, \'motor_commands\', 10)\n\n        # Create a subscriber to receive sensor data\n        self.subscription = self.create_subscription(\n            String,\n            \'sensor_data\',\n            self.sensor_callback,\n            10)\n\n        # Create a timer for periodic AI processing\n        self.timer = self.create_timer(0.5, self.ai_processing_callback)\n\n        self.get_logger().info(\'AI Node initialized\')\n\n    def sensor_callback(self, msg):\n        """Process incoming sensor data from the robot"""\n        self.get_logger().info(f\'Received sensor data: {msg.data}\')\n        # Process sensor data with AI algorithms\n        self.process_sensor_data(msg.data)\n\n    def ai_processing_callback(self):\n        """Main AI processing loop"""\n        # Run AI algorithms to determine next action\n        command = self.run_ai_decision()\n        if command:\n            self.send_command(command)\n\n    def process_sensor_data(self, sensor_data):\n        """Implement AI processing of sensor information"""\n        # This is where AI algorithms would process the data\n        pass\n\n    def run_ai_decision(self):\n        """Run AI algorithms to determine robot action"""\n        # This is where high-level AI decisions are made\n        return "MOVE_FORWARD"\n\n    def send_command(self, command):\n        """Send command to robot hardware"""\n        msg = String()\n        msg.data = command\n        self.publisher_.publish(msg)\n        self.get_logger().info(f\'Sent command: {command}\')\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ai_node = AINode()\n\n    try:\n        rclpy.spin(ai_node)\n    except KeyboardInterrupt:\n        ai_node.get_logger().info(\'Shutting down AI Node\')\n    finally:\n        ai_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == \'__main__\':\n    main()\n'})}),"\n",(0,s.jsx)(n.h2,{id:"the-ai-to-hardware-communication-pipeline",children:"The AI-to-Hardware Communication Pipeline"}),"\n",(0,s.jsx)(n.p,{children:"rclpy enables a complete pipeline from AI algorithms to hardware control:"}),"\n",(0,s.jsx)(n.h3,{id:"1-sensor-data-flow",children:"1. Sensor Data Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[Physical Sensors] \u2192 [Sensor Drivers] \u2192 [ROS 2 Topics] \u2192 [Python AI Node]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"2-ai-processing",children:"2. AI Processing"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[Sensor Data] \u2192 [AI Algorithms] \u2192 [Decision Making] \u2192 [Command Generation]\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-hardware-command-flow",children:"3. Hardware Command Flow"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[Python AI Node] \u2192 [ROS 2 Topics] \u2192 [Hardware Controllers] \u2192 [Physical Actuators]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"practical-example-ai-based-motor-control",children:"Practical Example: AI-Based Motor Control"}),"\n",(0,s.jsx)(n.p,{children:"Let's look at a more complete example that demonstrates how rclpy bridges AI code to motor control:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Example: Simple obstacle avoidance using AI decision making\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import LaserScan\nfrom geometry_msgs.msg import Twist\n\nclass ObstacleAvoidanceAI(Node):\n    def __init__(self):\n        super().__init__('obstacle_avoidance_ai')\n\n        # Subscribe to laser scanner data\n        self.scan_subscription = self.create_subscription(\n            LaserScan,\n            'scan',\n            self.scan_callback,\n            10)\n\n        # Publish velocity commands to robot\n        self.cmd_publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n\n        # Timer for AI processing\n        self.timer = self.create_timer(0.1, self.ai_decision_loop)\n\n        self.latest_scan = None\n        self.get_logger().info('Obstacle Avoidance AI initialized')\n\n    def scan_callback(self, msg):\n        \"\"\"Receive and store laser scan data\"\"\"\n        self.latest_scan = msg\n\n    def ai_decision_loop(self):\n        \"\"\"Main AI decision making loop\"\"\"\n        if self.latest_scan is None:\n            return\n\n        # Simple AI: if obstacle is close, turn; otherwise go forward\n        min_distance = min(self.latest_scan.ranges)\n\n        cmd_msg = Twist()\n        if min_distance < 1.0:  # Obstacle within 1 meter\n            cmd_msg.angular.z = 0.5  # Turn right\n            cmd_msg.linear.x = 0.0   # Stop forward motion\n        else:\n            cmd_msg.linear.x = 0.5   # Move forward\n            cmd_msg.angular.z = 0.0  # No turning\n\n        # Send command to robot hardware\n        self.cmd_publisher.publish(cmd_msg)\n\ndef main(args=None):\n    rclpy.init(args=args)\n    ai_node = ObstacleAvoidanceAI()\n\n    try:\n        rclpy.spin(ai_node)\n    except KeyboardInterrupt:\n        ai_node.get_logger().info('Shutting down obstacle avoidance AI')\n    finally:\n        ai_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,s.jsx)(n.h2,{id:"integration-with-robot-hardware-controllers",children:"Integration with Robot Hardware Controllers"}),"\n",(0,s.jsx)(n.p,{children:"rclpy connects to various types of hardware controllers:"}),"\n",(0,s.jsx)(n.h3,{id:"1-motor-controllers",children:"1. Motor Controllers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Receive velocity commands (Twist messages)"}),"\n",(0,s.jsx)(n.li,{children:"Send motor commands to physical actuators"}),"\n",(0,s.jsx)(n.li,{children:"Provide feedback on motor status"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"2-sensor-interfaces",children:"2. Sensor Interfaces"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Receive raw sensor data (LaserScan, Image, etc.)"}),"\n",(0,s.jsx)(n.li,{children:"Process and interpret sensor information"}),"\n",(0,s.jsx)(n.li,{children:"Provide processed data to AI algorithms"}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"3-manipulator-controllers",children:"3. Manipulator Controllers"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Receive joint position/velocity commands"}),"\n",(0,s.jsx)(n.li,{children:"Execute complex manipulation tasks"}),"\n",(0,s.jsx)(n.li,{children:"Provide feedback on gripper status"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"best-practices-for-ai-hardware-integration",children:"Best Practices for AI-Hardware Integration"}),"\n",(0,s.jsx)(n.p,{children:"When using rclpy to bridge AI and hardware:"}),"\n",(0,s.jsx)(n.h3,{id:"1-safety-first",children:"1. Safety First"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:'def send_command(self, command):\n    """Always validate commands before sending to hardware"""\n    if self.is_command_safe(command):\n        self.publisher_.publish(command)\n    else:\n        self.get_logger().error(\'Unsafe command blocked\')\n'})}),"\n",(0,s.jsx)(n.h3,{id:"2-error-handling",children:"2. Error Handling"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"def sensor_callback(self, msg):\n    try:\n        processed_data = self.process_sensor_data(msg)\n        self.execute_ai_decision(processed_data)\n    except Exception as e:\n        self.get_logger().error(f'Error processing sensor data: {e}')\n        self.fallback_behavior()\n"})}),"\n",(0,s.jsx)(n.h3,{id:"3-real-time-considerations",children:"3. Real-time Considerations"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Use appropriate timer rates for your application"}),"\n",(0,s.jsx)(n.li,{children:"Keep callback functions lightweight"}),"\n",(0,s.jsx)(n.li,{children:"Consider thread safety for complex operations"}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"advanced-working-with-action-servers-for-complex-tasks",children:"Advanced: Working with Action Servers for Complex Tasks"}),"\n",(0,s.jsx)(n.p,{children:"For complex hardware tasks that require feedback and cancellation, rclpy supports action servers:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.action import ActionServer\nfrom rclpy.node import Node\nfrom rclpy.executors import MultiThreadedExecutor\nfrom rclpy.callback_groups import ReentrantCallbackGroup\n\nclass NavigationAIAction(Node):\n    def __init__(self):\n        super().__init__('navigation_ai_action')\n        self._action_server = ActionServer(\n            self,\n            NavigateToPose,  # Navigation action type\n            'navigate_to_pose',\n            self.execute_callback,\n            callback_group=ReentrantCallbackGroup())\n\n        self.cmd_publisher = self.create_publisher(Twist, 'cmd_vel', 10)\n        self.feedback_publisher = self.create_publisher(NavFeedback, 'nav_feedback', 10)\n\n    async def execute_callback(self, goal_handle):\n        \"\"\"Execute navigation with continuous feedback\"\"\"\n        target_pose = goal_handle.request.pose\n        self.get_logger().info(f'Navigating to: {target_pose}')\n\n        # AI-driven navigation algorithm with feedback\n        while not self.reached_target(target_pose):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                return NavigateToPose.Result()\n\n            # Get current position and calculate next move\n            next_command = self.ai_navigation_algorithm(target_pose)\n            self.cmd_publisher.publish(next_command)\n\n            # Publish feedback\n            feedback_msg = NavFeedback()\n            feedback_msg.current_pose = self.get_current_pose()\n            goal_handle.publish_feedback(feedback_msg)\n\n            await asyncio.sleep(0.1)  # Small delay for system stability\n\n        goal_handle.succeed()\n        result = NavigateToPose.Result()\n        result.success = True\n        return result\n"})}),"\n",(0,s.jsx)(n.h2,{id:"the-complete-ai-hardware-ecosystem",children:"The Complete AI-Hardware Ecosystem"}),"\n",(0,s.jsx)(n.p,{children:"rclpy is part of a larger ecosystem that connects AI to hardware:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"[AI Algorithms in Python] \u2190\u2192 [rclpy] \u2190\u2192 [ROS 2 Middleware] \u2190\u2192 [Hardware Drivers]\n       |                      |             |                      |\n[Perception]           [Bridge]    [Communication]      [Motor Controllers]\n[Planning]            [Interface]    [Framework]        [Sensor Interfaces]\n[Learning]            [Library]     [Standard]          [Actuator Drivers]\n"})}),"\n",(0,s.jsx)(n.h2,{id:"debugging-and-monitoring",children:"Debugging and Monitoring"}),"\n",(0,s.jsx)(n.p,{children:"When connecting AI to hardware, debugging tools are essential:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-python",children:"# Use logging to track AI decisions\nself.get_logger().info(f'AI decided: {action} based on {sensor_data}')\n\n# Monitor hardware status\ndef check_hardware_status(self):\n    if not self.motors_enabled:\n        self.get_logger().warn('Motors not enabled, stopping commands')\n\n# Implement safety checks\ndef validate_command(self, cmd):\n    return abs(cmd.linear.x) <= MAX_LINEAR_VEL and abs(cmd.angular.z) <= MAX_ANGULAR_VEL\n"})}),"\n",(0,s.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,s.jsx)(n.p,{children:"rclpy serves as the essential bridge between high-level AI algorithms and low-level robot hardware. It enables Python-based AI systems to communicate with hardware controllers through the ROS 2 middleware, creating a complete pipeline from perception and decision-making to physical action. Understanding this bridge is crucial for developing intelligent robotic systems that can interact with the physical world."}),"\n",(0,s.jsx)(n.p,{children:"The rclpy library provides the tools needed to implement sophisticated AI behaviors that control real hardware, from simple sensor processing to complex navigation tasks with continuous feedback and safety considerations."}),"\n",(0,s.jsx)(n.h2,{id:"key-terms",children:"Key Terms"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"rclpy"}),": ROS Client Library for Python, the Python interface to ROS 2"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"AI-Hardware Bridge"}),": Connection between high-level algorithms and low-level controllers"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Hardware Controllers"}),": Low-level software that directly controls robot actuators"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Motor Commands"}),": Messages sent to control robot movement"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Sensor Data"}),": Information received from robot sensors"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Action Server"}),": Long-running tasks with feedback and cancellation capability"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.strong,{children:"Safety Validation"}),": Checking commands before sending to hardware"]}),"\n"]}),"\n",(0,s.jsx)(n.h2,{id:"review-questions",children:"Review Questions"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"What is the role of rclpy in connecting AI algorithms to robot hardware?"}),"\n",(0,s.jsx)(n.li,{children:"How does the rclpy bridge handle the timing differences between AI processing and hardware control?"}),"\n",(0,s.jsx)(n.li,{children:"What safety considerations should be implemented when using rclpy to control hardware?"}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>t});var s=r(6540);const i={},o=s.createContext(i);function a(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function t(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:a(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);